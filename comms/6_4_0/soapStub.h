/* soapStub.h
   Generated by gSOAP 2.7.15 from Services.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"urn:hpccsystems:ws:ws_account"
#define SOAP_NAMESPACE_OF_ns2	"urn:hpccsystems:ws:wsattributes"
#define SOAP_NAMESPACE_OF_ns3	"urn:hpccsystems:ws:wsdfu"
#define SOAP_NAMESPACE_OF_ns4	"urn:hpccsystems:ws:wssmc"
#define SOAP_NAMESPACE_OF_ns5	"urn:hpccsystems:ws:wstopology"
#define SOAP_NAMESPACE_OF_ns6	"urn:hpccsystems:ws:wsworkunits"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns3__DFUArrayActions
#define SOAP_TYPE_ns3__DFUArrayActions (502)
/* ns3:DFUArrayActions */
enum ns3__DFUArrayActions {ns3__DFUArrayActions__Delete = 0, ns3__DFUArrayActions__Add_x0020To_x0020Superfile = 1};
#endif

#ifndef SOAP_TYPE_ns4__LockModes
#define SOAP_TYPE_ns4__LockModes (503)
/* ns4:LockModes */
enum ns4__LockModes {ns4__LockModes__ALL = 0, ns4__LockModes__READ = 1, ns4__LockModes__WRITE = 2, ns4__LockModes__HOLD = 3, ns4__LockModes__SUB = 4};
#endif

#ifndef SOAP_TYPE_ns6__ECLWUActions
#define SOAP_TYPE_ns6__ECLWUActions (504)
/* ns6:ECLWUActions */
enum ns6__ECLWUActions {ns6__ECLWUActions__Abort = 0, ns6__ECLWUActions__Delete = 1, ns6__ECLWUActions__Deschedule = 2, ns6__ECLWUActions__Reschedule = 3, ns6__ECLWUActions__Pause = 4, ns6__ECLWUActions__PauseNow = 5, ns6__ECLWUActions__Protect = 6, ns6__ECLWUActions__Unprotect = 7, ns6__ECLWUActions__Restore = 8, ns6__ECLWUActions__Resume = 9, ns6__ECLWUActions__SetToFailed = 10};
#endif

#ifndef SOAP_TYPE_ns6__WUExceptionSeverity
#define SOAP_TYPE_ns6__WUExceptionSeverity (505)
/* ns6:WUExceptionSeverity */
enum ns6__WUExceptionSeverity {ns6__WUExceptionSeverity__info = 0, ns6__WUExceptionSeverity__warning = 1, ns6__WUExceptionSeverity__error = 2, ns6__WUExceptionSeverity__alert = 3};
#endif

#ifndef SOAP_TYPE_ns6__WUQuerySetFilterType
#define SOAP_TYPE_ns6__WUQuerySetFilterType (506)
/* ns6:WUQuerySetFilterType */
enum ns6__WUQuerySetFilterType {ns6__WUQuerySetFilterType__All = 0, ns6__WUQuerySetFilterType__Id = 1, ns6__WUQuerySetFilterType__Name = 2, ns6__WUQuerySetFilterType__Alias = 3, ns6__WUQuerySetFilterType__Status = 4};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAliasActionTypes
#define SOAP_TYPE_ns6__QuerySetAliasActionTypes (507)
/* ns6:QuerySetAliasActionTypes */
enum ns6__QuerySetAliasActionTypes {ns6__QuerySetAliasActionTypes__Deactivate = 0};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryActionTypes
#define SOAP_TYPE_ns6__QuerySetQueryActionTypes (508)
/* ns6:QuerySetQueryActionTypes */
enum ns6__QuerySetQueryActionTypes {ns6__QuerySetQueryActionTypes__Suspend = 0, ns6__QuerySetQueryActionTypes__Unsuspend = 1, ns6__QuerySetQueryActionTypes__ToggleSuspend = 2, ns6__QuerySetQueryActionTypes__Activate = 3, ns6__QuerySetQueryActionTypes__Delete = 4, ns6__QuerySetQueryActionTypes__RemoveAllAliases = 5, ns6__QuerySetQueryActionTypes__ResetQueryStats = 6};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() : __ptr(NULL), __size(0), id(NULL), type(NULL), options(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__EspException
#define SOAP_TYPE_ns1__EspException (16)
/* ns1:EspException */
class SOAP_CMAC ns1__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns1__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfEspException
#define SOAP_TYPE_ns1__ArrayOfEspException (17)
/* ns1:ArrayOfEspException */
class SOAP_CMAC ns1__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns1__EspException * >Exception;	/* optional element of type ns1:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns1__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE__ns1__MyAccountRequest
#define SOAP_TYPE__ns1__MyAccountRequest (18)
/* ns1:MyAccountRequest */
class SOAP_CMAC _ns1__MyAccountRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE__ns1__MyAccountRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__MyAccountRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__MyAccountRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__MyAccountResponse
#define SOAP_TYPE__ns1__MyAccountResponse (19)
/* ns1:MyAccountResponse */
class SOAP_CMAC _ns1__MyAccountResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	std::wstring *username;	/* optional element of type xsd:string */
	std::wstring *firstName;	/* optional element of type xsd:string */
	std::wstring *lastName;	/* optional element of type xsd:string */
	std::wstring *passwordExpiration;	/* optional element of type xsd:string */
	int *passwordDaysRemaining;	/* optional element of type xsd:int */
	int *passwordExpirationWarningDays;	/* optional element of type xsd:int */
	std::wstring *employeeID;	/* optional element of type xsd:string */
	std::wstring *distinguishedName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__ns1__MyAccountResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__MyAccountResponse() : Exceptions(NULL), username(NULL), firstName(NULL), lastName(NULL), passwordExpiration(NULL), passwordDaysRemaining(NULL), passwordExpirationWarningDays(NULL), employeeID(NULL), distinguishedName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__MyAccountResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserRequest
#define SOAP_TYPE__ns1__UpdateUserRequest (20)
/* ns1:UpdateUserRequest */
class SOAP_CMAC _ns1__UpdateUserRequest
{
public:
	std::wstring *username;	/* optional element of type xsd:string */
	std::wstring *oldpass;	/* optional element of type xsd:string */
	std::wstring *newpass1;	/* optional element of type xsd:string */
	std::wstring *newpass2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__ns1__UpdateUserRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserRequest() : username(NULL), oldpass(NULL), newpass1(NULL), newpass2(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserResponse
#define SOAP_TYPE__ns1__UpdateUserResponse (21)
/* ns1:UpdateUserResponse */
class SOAP_CMAC _ns1__UpdateUserResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	int *retcode;	/* optional element of type xsd:int */
	std::wstring *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__ns1__UpdateUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserResponse() : Exceptions(NULL), retcode(NULL), message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserInputRequest
#define SOAP_TYPE__ns1__UpdateUserInputRequest (22)
/* ns1:UpdateUserInputRequest */
class SOAP_CMAC _ns1__UpdateUserInputRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns1__UpdateUserInputRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserInputRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserInputRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserInputResponse
#define SOAP_TYPE__ns1__UpdateUserInputResponse (23)
/* ns1:UpdateUserInputResponse */
class SOAP_CMAC _ns1__UpdateUserInputResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	std::wstring *username;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns1__UpdateUserInputResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserInputResponse() : Exceptions(NULL), username(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserInputResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__VerifyUserRequest
#define SOAP_TYPE__ns1__VerifyUserRequest (24)
/* ns1:VerifyUserRequest */
class SOAP_CMAC _ns1__VerifyUserRequest
{
public:
	std::wstring *application;	/* optional element of type xsd:string */
	std::wstring *version;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns1__VerifyUserRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__VerifyUserRequest() : application(NULL), version(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__VerifyUserRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__VerifyUserResponse
#define SOAP_TYPE__ns1__VerifyUserResponse (25)
/* ns1:VerifyUserResponse */
class SOAP_CMAC _ns1__VerifyUserResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	int *retcode;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__ns1__VerifyUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__VerifyUserResponse() : Exceptions(NULL), retcode(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__VerifyUserResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EspException
#define SOAP_TYPE_ns2__EspException (26)
/* ns2:EspException */
class SOAP_CMAC ns2__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns2__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfEspException
#define SOAP_TYPE_ns2__ArrayOfEspException (27)
/* ns2:ArrayOfEspException */
class SOAP_CMAC ns2__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns2__EspException * >Exception;	/* optional element of type ns2:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns2__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RenameAttributeRequest
#define SOAP_TYPE_ns2__RenameAttributeRequest (28)
/* ns2:RenameAttributeRequest */
class SOAP_CMAC ns2__RenameAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *NewModuleName;	/* optional element of type xsd:string */
	std::wstring *NewAttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns2__RenameAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RenameAttributeRequest() : ModuleName(NULL), AttributeName(NULL), NewModuleName(NULL), NewAttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__RenameAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImportAttributeRequest
#define SOAP_TYPE_ns2__ImportAttributeRequest (29)
/* ns2:ImportAttributeRequest */
class SOAP_CMAC ns2__ImportAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Flags;	/* optional element of type xsd:int */
	int *ResultType;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Text;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns2__ImportAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImportAttributeRequest() : ModuleName(NULL), AttributeName(NULL), Type(NULL), Flags(NULL), ResultType(NULL), Description(NULL), Text(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ImportAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RollbackAttributeRequest
#define SOAP_TYPE_ns2__RollbackAttributeRequest (30)
/* ns2:RollbackAttributeRequest */
class SOAP_CMAC ns2__RollbackAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns2__RollbackAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RollbackAttributeRequest() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__RollbackAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CheckinAttributeRequest
#define SOAP_TYPE_ns2__CheckinAttributeRequest (31)
/* ns2:CheckinAttributeRequest */
class SOAP_CMAC ns2__CheckinAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns2__CheckinAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CheckinAttributeRequest() : ModuleName(NULL), AttributeName(NULL), Description(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__CheckinAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CheckoutAttributeRequest
#define SOAP_TYPE_ns2__CheckoutAttributeRequest (32)
/* ns2:CheckoutAttributeRequest */
class SOAP_CMAC ns2__CheckoutAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns2__CheckoutAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CheckoutAttributeRequest() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__CheckoutAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLLabel
#define SOAP_TYPE_ns2__ECLLabel (33)
/* ns2:ECLLabel */
class SOAP_CMAC ns2__ECLLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *ModifiedDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns2__ECLLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLLabel() : Name(NULL), ModifiedDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLModule
#define SOAP_TYPE_ns2__ECLModule (34)
/* ns2:ECLModule */
class SOAP_CMAC ns2__ECLModule
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	int *Flags;	/* optional element of type xsd:int */
	int *Access;	/* optional element of type xsd:int */
	LONG64 *Timestamp;	/* optional element of type xsd:long */
	bool *IsPlugin;	/* optional element of type xsd:boolean */
	int *Rank;	/* optional element of type xsd:int */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *FileCRC;	/* optional element of type xsd:string */
	std::wstring *Version;	/* optional element of type xsd:string */
	std::wstring *Checksum;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns2__ECLModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLModule() : Name(NULL), Flags(NULL), Access(NULL), Timestamp(NULL), IsPlugin(NULL), Rank(NULL), FileName(NULL), FileCRC(NULL), Version(NULL), Checksum(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ECLAttribute_MatchedLines
#define SOAP_TYPE__ns2__ECLAttribute_MatchedLines (519)
/* ns2:ECLAttribute-MatchedLines */
class SOAP_CMAC _ns2__ECLAttribute_MatchedLines
{
public:
	std::vector<class ns2__ECLTextLine * >Line;	/* optional element of type ns2:ECLTextLine */
public:
	virtual int soap_type() const { return 519; } /* = unique id SOAP_TYPE__ns2__ECLAttribute_MatchedLines */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ECLAttribute_MatchedLines()  { this->soap_default(NULL); }
	virtual ~_ns2__ECLAttribute_MatchedLines() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLAttribute
#define SOAP_TYPE_ns2__ECLAttribute (35)
/* ns2:ECLAttribute */
class SOAP_CMAC ns2__ECLAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Version;	/* optional element of type xsd:int */
	int *LatestVersion;	/* optional element of type xsd:int */
	int *SandboxVersion;	/* optional element of type xsd:int */
	int *Flags;	/* optional element of type xsd:int */
	int *Access;	/* optional element of type xsd:int */
	bool *IsLocked;	/* optional element of type xsd:boolean */
	bool *IsCheckedOut;	/* optional element of type xsd:boolean */
	bool *IsSandbox;	/* optional element of type xsd:boolean */
	bool *IsOrphaned;	/* optional element of type xsd:boolean */
	int *ResultType;	/* optional element of type xsd:int */
	std::wstring *LockedBy;	/* optional element of type xsd:string */
	std::wstring *ModifiedBy;	/* optional element of type xsd:string */
	std::wstring *ModifiedDate;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Checksum;	/* optional element of type xsd:string */
	std::wstring *Text;	/* optional element of type xsd:string */
	_ns2__ECLAttribute_MatchedLines *MatchedLines;	/* optional element of type ns2:ECLAttribute-MatchedLines */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns2__ECLAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLAttribute() : ModuleName(NULL), Name(NULL), Type(NULL), Version(NULL), LatestVersion(NULL), SandboxVersion(NULL), Flags(NULL), Access(NULL), IsLocked(NULL), IsCheckedOut(NULL), IsSandbox(NULL), IsOrphaned(NULL), ResultType(NULL), LockedBy(NULL), ModifiedBy(NULL), ModifiedDate(NULL), Description(NULL), Checksum(NULL), Text(NULL), MatchedLines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLAttribute() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLTextLine
#define SOAP_TYPE_ns2__ECLTextLine (36)
/* ns2:ECLTextLine */
class SOAP_CMAC ns2__ECLTextLine
{
public:
	int *LineNumber;	/* optional element of type xsd:int */
	std::wstring *LineText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns2__ECLTextLine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLTextLine() : LineNumber(NULL), LineText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLTextLine() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfCheckinAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfCheckinAttributeRequest (37)
/* ns2:ArrayOfCheckinAttributeRequest */
class SOAP_CMAC ns2__ArrayOfCheckinAttributeRequest
{
public:
	std::vector<ns2__CheckinAttributeRequest * >CheckinAttributeRequest;	/* optional element of type ns2:CheckinAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns2__ArrayOfCheckinAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfCheckinAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfCheckinAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLAttribute
#define SOAP_TYPE_ns2__ArrayOfECLAttribute (38)
/* ns2:ArrayOfECLAttribute */
class SOAP_CMAC ns2__ArrayOfECLAttribute
{
public:
	std::vector<ns2__ECLAttribute * >ECLAttribute;	/* optional element of type ns2:ECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLAttribute() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLAttribute() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfCheckoutAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfCheckoutAttributeRequest (39)
/* ns2:ArrayOfCheckoutAttributeRequest */
class SOAP_CMAC ns2__ArrayOfCheckoutAttributeRequest
{
public:
	std::vector<ns2__CheckoutAttributeRequest * >CheckoutAttributeRequest;	/* optional element of type ns2:CheckoutAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns2__ArrayOfCheckoutAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfCheckoutAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfCheckoutAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DeleteAttributeRequest
#define SOAP_TYPE_ns2__DeleteAttributeRequest (40)
/* ns2:DeleteAttributeRequest */
class SOAP_CMAC ns2__DeleteAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns2__DeleteAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DeleteAttributeRequest() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__DeleteAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfDeleteAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfDeleteAttributeRequest (41)
/* ns2:ArrayOfDeleteAttributeRequest */
class SOAP_CMAC ns2__ArrayOfDeleteAttributeRequest
{
public:
	std::vector<ns2__DeleteAttributeRequest * >DeleteAttributeRequest;	/* optional element of type ns2:DeleteAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns2__ArrayOfDeleteAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfDeleteAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfDeleteAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EspStringArray
#define SOAP_TYPE_ns2__EspStringArray (42)
/* ns2:EspStringArray */
class SOAP_CMAC ns2__EspStringArray
{
public:
	std::vector<std::wstring * >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns2__EspStringArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EspStringArray() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__EspStringArray() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLAttributeLabel
#define SOAP_TYPE_ns2__ECLAttributeLabel (43)
/* ns2:ECLAttributeLabel */
class SOAP_CMAC ns2__ECLAttributeLabel
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	int *AttributeVersion;	/* optional element of type xsd:int */
	std::wstring *LabelName;	/* optional element of type xsd:string */
	std::wstring *ModifiedDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns2__ECLAttributeLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLAttributeLabel() : ModuleName(NULL), AttributeName(NULL), AttributeVersion(NULL), LabelName(NULL), ModifiedDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLAttributeLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLAttributeLabel
#define SOAP_TYPE_ns2__ArrayOfECLAttributeLabel (44)
/* ns2:ArrayOfECLAttributeLabel */
class SOAP_CMAC ns2__ArrayOfECLAttributeLabel
{
public:
	std::vector<ns2__ECLAttributeLabel * >ECLAttributeLabel;	/* optional element of type ns2:ECLAttributeLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLAttributeLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLAttributeLabel() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLAttributeLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLLabel
#define SOAP_TYPE_ns2__ArrayOfECLLabel (45)
/* ns2:ArrayOfECLLabel */
class SOAP_CMAC ns2__ArrayOfECLLabel
{
public:
	std::vector<ns2__ECLLabel * >ECLLabel;	/* optional element of type ns2:ECLLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLLabel() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLModule
#define SOAP_TYPE_ns2__ArrayOfECLModule (46)
/* ns2:ArrayOfECLModule */
class SOAP_CMAC ns2__ArrayOfECLModule
{
public:
	std::vector<ns2__ECLModule * >ECLModule;	/* optional element of type ns2:ECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLModule() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLModule() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfImportAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfImportAttributeRequest (47)
/* ns2:ArrayOfImportAttributeRequest */
class SOAP_CMAC ns2__ArrayOfImportAttributeRequest
{
public:
	std::vector<ns2__ImportAttributeRequest * >ImportAttributeRequest;	/* optional element of type ns2:ImportAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns2__ArrayOfImportAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfImportAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfImportAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AttributeType
#define SOAP_TYPE_ns2__AttributeType (48)
/* ns2:AttributeType */
class SOAP_CMAC ns2__AttributeType
{
public:
	int *ID;	/* optional element of type xsd:int */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns2__AttributeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AttributeType() : ID(NULL), Name(NULL), Description(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__AttributeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfRenameAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfRenameAttributeRequest (49)
/* ns2:ArrayOfRenameAttributeRequest */
class SOAP_CMAC ns2__ArrayOfRenameAttributeRequest
{
public:
	std::vector<ns2__RenameAttributeRequest * >RenameAttributeRequest;	/* optional element of type ns2:RenameAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns2__ArrayOfRenameAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfRenameAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfRenameAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfRollbackAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfRollbackAttributeRequest (50)
/* ns2:ArrayOfRollbackAttributeRequest */
class SOAP_CMAC ns2__ArrayOfRollbackAttributeRequest
{
public:
	std::vector<ns2__RollbackAttributeRequest * >RollbackAttributeRequest;	/* optional element of type ns2:RollbackAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns2__ArrayOfRollbackAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfRollbackAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfRollbackAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SaveAttributeRequest
#define SOAP_TYPE_ns2__SaveAttributeRequest (51)
/* ns2:SaveAttributeRequest */
class SOAP_CMAC ns2__SaveAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	int *Flags;	/* optional element of type xsd:int */
	int *ResultType;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Text;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns2__SaveAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SaveAttributeRequest() : ModuleName(NULL), AttributeName(NULL), Flags(NULL), ResultType(NULL), Description(NULL), Text(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__SaveAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfSaveAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfSaveAttributeRequest (52)
/* ns2:ArrayOfSaveAttributeRequest */
class SOAP_CMAC ns2__ArrayOfSaveAttributeRequest
{
public:
	std::vector<ns2__SaveAttributeRequest * >SaveAttributeRequest;	/* optional element of type ns2:SaveAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns2__ArrayOfSaveAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfSaveAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfSaveAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CheckinAttributes
#define SOAP_TYPE__ns2__CheckinAttributes (53)
/* ns2:CheckinAttributes */
class SOAP_CMAC _ns2__CheckinAttributes
{
public:
	ns2__ArrayOfCheckinAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfCheckinAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__ns2__CheckinAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CheckinAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CheckinAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__UpdateAttributesResponse
#define SOAP_TYPE__ns2__UpdateAttributesResponse (54)
/* ns2:UpdateAttributesResponse */
class SOAP_CMAC _ns2__UpdateAttributesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__ns2__UpdateAttributesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__UpdateAttributesResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__UpdateAttributesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CheckoutAttributes
#define SOAP_TYPE__ns2__CheckoutAttributes (55)
/* ns2:CheckoutAttributes */
class SOAP_CMAC _ns2__CheckoutAttributes
{
public:
	ns2__ArrayOfCheckoutAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfCheckoutAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns2__CheckoutAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CheckoutAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CheckoutAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateAttribute
#define SOAP_TYPE__ns2__CreateAttribute (56)
/* ns2:CreateAttribute */
class SOAP_CMAC _ns2__CreateAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns2__CreateAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateAttribute() : ModuleName(NULL), AttributeName(NULL), Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateAttribute() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateAttributeResponse
#define SOAP_TYPE__ns2__CreateAttributeResponse (57)
/* ns2:CreateAttributeResponse */
class SOAP_CMAC _ns2__CreateAttributeResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLAttribute *AttributeInfo;	/* optional element of type ns2:ECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns2__CreateAttributeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateAttributeResponse() : Exceptions(NULL), AttributeInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateAttributeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateLabel
#define SOAP_TYPE__ns2__CreateLabel (58)
/* ns2:CreateLabel */
class SOAP_CMAC _ns2__CreateLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns2__CreateLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateLabel() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateLabel() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateLabelResponse
#define SOAP_TYPE__ns2__CreateLabelResponse (59)
/* ns2:CreateLabelResponse */
class SOAP_CMAC _ns2__CreateLabelResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__ns2__CreateLabelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateLabelResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateLabelResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateModule
#define SOAP_TYPE__ns2__CreateModule (60)
/* ns2:CreateModule */
class SOAP_CMAC _ns2__CreateModule
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__ns2__CreateModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateModule() : ModuleName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateModuleResponse
#define SOAP_TYPE__ns2__CreateModuleResponse (61)
/* ns2:CreateModuleResponse */
class SOAP_CMAC _ns2__CreateModuleResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLModule *ModuleInfo;	/* optional element of type ns2:ECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__ns2__CreateModuleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateModuleResponse() : Exceptions(NULL), ModuleInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateModuleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteAttributes
#define SOAP_TYPE__ns2__DeleteAttributes (62)
/* ns2:DeleteAttributes */
class SOAP_CMAC _ns2__DeleteAttributes
{
public:
	ns2__ArrayOfDeleteAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfDeleteAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__ns2__DeleteAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteLabel
#define SOAP_TYPE__ns2__DeleteLabel (63)
/* ns2:DeleteLabel */
class SOAP_CMAC _ns2__DeleteLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__ns2__DeleteLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteLabel() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteLabel() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteLabelResponse
#define SOAP_TYPE__ns2__DeleteLabelResponse (64)
/* ns2:DeleteLabelResponse */
class SOAP_CMAC _ns2__DeleteLabelResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__ns2__DeleteLabelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteLabelResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteLabelResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteModule
#define SOAP_TYPE__ns2__DeleteModule (65)
/* ns2:DeleteModule */
class SOAP_CMAC _ns2__DeleteModule
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__ns2__DeleteModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteModule() : ModuleName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteModuleResponse
#define SOAP_TYPE__ns2__DeleteModuleResponse (66)
/* ns2:DeleteModuleResponse */
class SOAP_CMAC _ns2__DeleteModuleResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__ns2__DeleteModuleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteModuleResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteModuleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__FindAttributes
#define SOAP_TYPE__ns2__FindAttributes (67)
/* ns2:FindAttributes */
class SOAP_CMAC _ns2__FindAttributes
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *UserName;	/* optional element of type xsd:string */
	std::wstring *label;	/* optional element of type xsd:string */
	std::wstring *Pattern;	/* optional element of type xsd:string */
	std::wstring *Regexp;	/* optional element of type xsd:string */
	std::wstring *Plain;	/* optional element of type xsd:string */
	std::wstring *ChangedSince;	/* optional element of type xsd:string */
	ns2__EspStringArray *TypeList;	/* optional element of type ns2:EspStringArray */
	bool Sandboxed;	/* optional element of type xsd:boolean */
	bool Locked;	/* optional element of type xsd:boolean */
	bool CheckedOut;	/* optional element of type xsd:boolean */
	bool Orphaned;	/* optional element of type xsd:boolean */
	bool GetText;	/* optional element of type xsd:boolean */
	bool GetMatchedLines;	/* optional element of type xsd:boolean */
	bool IncludeHistory;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__ns2__FindAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__FindAttributes() : ModuleName(NULL), AttributeName(NULL), UserName(NULL), label(NULL), Pattern(NULL), Regexp(NULL), Plain(NULL), ChangedSince(NULL), TypeList(NULL), Sandboxed((bool)0), Locked((bool)0), CheckedOut((bool)0), Orphaned((bool)0), GetText((bool)0), GetMatchedLines((bool)0), IncludeHistory((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__FindAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__FindAttributesResponse
#define SOAP_TYPE__ns2__FindAttributesResponse (68)
/* ns2:FindAttributesResponse */
class SOAP_CMAC _ns2__FindAttributesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__ns2__FindAttributesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__FindAttributesResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__FindAttributesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttribute
#define SOAP_TYPE__ns2__GetAttribute (69)
/* ns2:GetAttribute */
class SOAP_CMAC _ns2__GetAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Version;	/* optional element of type xsd:int */
	bool GetSandbox;	/* optional element of type xsd:boolean */
	bool GetText;	/* optional element of type xsd:boolean */
	std::wstring *Label;	/* optional element of type xsd:string */
	bool SandboxForLabel;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__ns2__GetAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttribute() : ModuleName(NULL), AttributeName(NULL), Type(NULL), Version(NULL), GetSandbox((bool)0), GetText((bool)0), Label(NULL), SandboxForLabel((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttribute() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeResponse
#define SOAP_TYPE__ns2__GetAttributeResponse (70)
/* ns2:GetAttributeResponse */
class SOAP_CMAC _ns2__GetAttributeResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLAttribute *outAttribute;	/* optional element of type ns2:ECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__ns2__GetAttributeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeResponse() : Exceptions(NULL), outAttribute(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeHistory
#define SOAP_TYPE__ns2__GetAttributeHistory (71)
/* ns2:GetAttributeHistory */
class SOAP_CMAC _ns2__GetAttributeHistory
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *FromDate;	/* optional element of type xsd:string */
	std::wstring *ToDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE__ns2__GetAttributeHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeHistory() : ModuleName(NULL), AttributeName(NULL), FromDate(NULL), ToDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeHistory() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeHistoryResponse
#define SOAP_TYPE__ns2__GetAttributeHistoryResponse (72)
/* ns2:GetAttributeHistoryResponse */
class SOAP_CMAC _ns2__GetAttributeHistoryResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE__ns2__GetAttributeHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeHistoryResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeLabels
#define SOAP_TYPE__ns2__GetAttributeLabels (73)
/* ns2:GetAttributeLabels */
class SOAP_CMAC _ns2__GetAttributeLabels
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE__ns2__GetAttributeLabels */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeLabels() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeLabels() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeLabelsResponse
#define SOAP_TYPE__ns2__GetAttributeLabelsResponse (74)
/* ns2:GetAttributeLabelsResponse */
class SOAP_CMAC _ns2__GetAttributeLabelsResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttributeLabel *Labels;	/* optional element of type ns2:ArrayOfECLAttributeLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE__ns2__GetAttributeLabelsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeLabelsResponse() : Exceptions(NULL), Labels(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeLabelsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributes
#define SOAP_TYPE__ns2__GetAttributes (75)
/* ns2:GetAttributes */
class SOAP_CMAC _ns2__GetAttributes
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	ns2__EspStringArray *TypeList;	/* optional element of type ns2:EspStringArray */
	std::wstring *Label;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE__ns2__GetAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributes() : ModuleName(NULL), TypeList(NULL), Label(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributesResponse
#define SOAP_TYPE__ns2__GetAttributesResponse (76)
/* ns2:GetAttributesResponse */
class SOAP_CMAC _ns2__GetAttributesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE__ns2__GetAttributesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributesResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetLabels
#define SOAP_TYPE__ns2__GetLabels (77)
/* ns2:GetLabels */
class SOAP_CMAC _ns2__GetLabels
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE__ns2__GetLabels */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetLabels() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetLabels() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetLabelsResponse
#define SOAP_TYPE__ns2__GetLabelsResponse (78)
/* ns2:GetLabelsResponse */
class SOAP_CMAC _ns2__GetLabelsResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLLabel *outLabels;	/* optional element of type ns2:ArrayOfECLLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE__ns2__GetLabelsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetLabelsResponse() : Exceptions(NULL), outLabels(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetLabelsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetModules
#define SOAP_TYPE__ns2__GetModules (79)
/* ns2:GetModules */
class SOAP_CMAC _ns2__GetModules
{
public:
	LONG64 *ModifiedSince;	/* optional element of type xsd:long */
	bool IncludeDeleted;	/* optional element of type xsd:boolean */
	bool GetChecksum;	/* optional element of type xsd:boolean */
	std::wstring *Label;	/* optional element of type xsd:string */
	std::wstring *EarMark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE__ns2__GetModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetModules() : ModifiedSince(NULL), IncludeDeleted((bool)0), GetChecksum((bool)0), Label(NULL), EarMark(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetModules() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetModulesResponse
#define SOAP_TYPE__ns2__GetModulesResponse (80)
/* ns2:GetModulesResponse */
class SOAP_CMAC _ns2__GetModulesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLModule *outModules;	/* optional element of type ns2:ArrayOfECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE__ns2__GetModulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetModulesResponse() : Exceptions(NULL), outModules(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetModulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ImportAttributes
#define SOAP_TYPE__ns2__ImportAttributes (81)
/* ns2:ImportAttributes */
class SOAP_CMAC _ns2__ImportAttributes
{
public:
	ns2__ArrayOfImportAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfImportAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE__ns2__ImportAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ImportAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__ImportAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ListAttributeTypes
#define SOAP_TYPE__ns2__ListAttributeTypes (82)
/* ns2:ListAttributeTypes */
class SOAP_CMAC _ns2__ListAttributeTypes
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE__ns2__ListAttributeTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ListAttributeTypes() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__ListAttributeTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ListAttributeTypesResponse_Types
#define SOAP_TYPE__ns2__ListAttributeTypesResponse_Types (556)
/* ns2:ListAttributeTypesResponse-Types */
class SOAP_CMAC _ns2__ListAttributeTypesResponse_Types
{
public:
	std::vector<ns2__AttributeType * >Type;	/* optional element of type ns2:AttributeType */
public:
	virtual int soap_type() const { return 556; } /* = unique id SOAP_TYPE__ns2__ListAttributeTypesResponse_Types */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ListAttributeTypesResponse_Types()  { this->soap_default(NULL); }
	virtual ~_ns2__ListAttributeTypesResponse_Types() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ListAttributeTypesResponse
#define SOAP_TYPE__ns2__ListAttributeTypesResponse (83)
/* ns2:ListAttributeTypesResponse */
class SOAP_CMAC _ns2__ListAttributeTypesResponse
{
public:
	_ns2__ListAttributeTypesResponse_Types *Types;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ListAttributeTypesResponse-Types */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE__ns2__ListAttributeTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ListAttributeTypesResponse() : Types(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__ListAttributeTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RenameAttributes
#define SOAP_TYPE__ns2__RenameAttributes (84)
/* ns2:RenameAttributes */
class SOAP_CMAC _ns2__RenameAttributes
{
public:
	ns2__ArrayOfRenameAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfRenameAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE__ns2__RenameAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RenameAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RenameAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RenameModule
#define SOAP_TYPE__ns2__RenameModule (85)
/* ns2:RenameModule */
class SOAP_CMAC _ns2__RenameModule
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *NewModuleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE__ns2__RenameModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RenameModule() : ModuleName(NULL), NewModuleName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RenameModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RenameModuleResponse
#define SOAP_TYPE__ns2__RenameModuleResponse (86)
/* ns2:RenameModuleResponse */
class SOAP_CMAC _ns2__RenameModuleResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLModule *ModuleInfo;	/* optional element of type ns2:ECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE__ns2__RenameModuleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RenameModuleResponse() : Exceptions(NULL), ModuleInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RenameModuleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RollbackAttributes
#define SOAP_TYPE__ns2__RollbackAttributes (87)
/* ns2:RollbackAttributes */
class SOAP_CMAC _ns2__RollbackAttributes
{
public:
	ns2__ArrayOfRollbackAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfRollbackAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE__ns2__RollbackAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RollbackAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RollbackAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__SaveAttributes
#define SOAP_TYPE__ns2__SaveAttributes (88)
/* ns2:SaveAttributes */
class SOAP_CMAC _ns2__SaveAttributes
{
public:
	ns2__ArrayOfSaveAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfSaveAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE__ns2__SaveAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__SaveAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__SaveAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__SupportsEarMark
#define SOAP_TYPE__ns2__SupportsEarMark (89)
/* ns2:SupportsEarMark */
class SOAP_CMAC _ns2__SupportsEarMark
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE__ns2__SupportsEarMark */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__SupportsEarMark() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__SupportsEarMark() { }
};
#endif

#ifndef SOAP_TYPE__ns2__SupportsEarMarkResponse
#define SOAP_TYPE__ns2__SupportsEarMarkResponse (90)
/* ns2:SupportsEarMarkResponse */
class SOAP_CMAC _ns2__SupportsEarMarkResponse
{
public:
	bool Support;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE__ns2__SupportsEarMarkResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__SupportsEarMarkResponse() : Support((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__SupportsEarMarkResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__UpdateLabel
#define SOAP_TYPE__ns2__UpdateLabel (91)
/* ns2:UpdateLabel */
class SOAP_CMAC _ns2__UpdateLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AtributeName;	/* optional element of type xsd:string */
	int *AttrbuteVersion;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE__ns2__UpdateLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__UpdateLabel() : Name(NULL), ModuleName(NULL), AtributeName(NULL), AttrbuteVersion(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__UpdateLabel() { }
};
#endif

#ifndef SOAP_TYPE__ns2__UpdateLabelResponse
#define SOAP_TYPE__ns2__UpdateLabelResponse (92)
/* ns2:UpdateLabelResponse */
class SOAP_CMAC _ns2__UpdateLabelResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE__ns2__UpdateLabelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__UpdateLabelResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__UpdateLabelResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns3__EspException
#define SOAP_TYPE_ns3__EspException (93)
/* ns3:EspException */
class SOAP_CMAC ns3__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns3__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfEspException
#define SOAP_TYPE_ns3__ArrayOfEspException (94)
/* ns3:ArrayOfEspException */
class SOAP_CMAC ns3__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns3__EspException * >Exception;	/* optional element of type ns3:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns3__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUDataColumn
#define SOAP_TYPE_ns3__DFUDataColumn (95)
/* ns3:DFUDataColumn */
class SOAP_CMAC ns3__DFUDataColumn
{
public:
	int *ColumnID;	/* optional element of type xsd:int */
	std::wstring *ColumnLabel;	/* optional element of type xsd:string */
	std::wstring *ColumnType;	/* optional element of type xsd:string */
	std::wstring *ColumnValue;	/* optional element of type xsd:string */
	int *ColumnSize;	/* optional element of type xsd:int */
	int *MaxSize;	/* optional element of type xsd:int */
	std::wstring *ColumnEclType;	/* optional element of type xsd:string */
	int *ColumnRawSize;	/* optional element of type xsd:int */
	bool *IsNaturalColumn;	/* optional element of type xsd:boolean */
	bool *IsKeyedColumn;	/* optional element of type xsd:boolean */
	class ns3__ArrayOfDFUDataColumn *DataColumns;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns3__DFUDataColumn */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUDataColumn() : ColumnID(NULL), ColumnLabel(NULL), ColumnType(NULL), ColumnValue(NULL), ColumnSize(NULL), MaxSize(NULL), ColumnEclType(NULL), ColumnRawSize(NULL), IsNaturalColumn(NULL), IsKeyedColumn(NULL), DataColumns(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUDataColumn() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUDataColumn
#define SOAP_TYPE_ns3__ArrayOfDFUDataColumn (96)
/* ns3:ArrayOfDFUDataColumn */
class SOAP_CMAC ns3__ArrayOfDFUDataColumn
{
public:
	std::vector<ns3__DFUDataColumn * >DFUDataColumn;	/* optional element of type ns3:DFUDataColumn */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUDataColumn */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUDataColumn() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUDataColumn() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUFileDetail_Graphs
#define SOAP_TYPE__ns3__DFUFileDetail_Graphs (574)
/* ns3:DFUFileDetail-Graphs */
class SOAP_CMAC _ns3__DFUFileDetail_Graphs
{
public:
	std::vector<std::wstring * >ECLGraph;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 574; } /* = unique id SOAP_TYPE__ns3__DFUFileDetail_Graphs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUFileDetail_Graphs()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUFileDetail_Graphs() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUFileDetail
#define SOAP_TYPE_ns3__DFUFileDetail (97)
/* ns3:DFUFileDetail */
class SOAP_CMAC ns3__DFUFileDetail
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Filename;	/* optional element of type xsd:string */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *NodeGroup;	/* optional element of type xsd:string */
	int *NumParts;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Dir;	/* optional element of type xsd:string */
	std::wstring *PathMask;	/* optional element of type xsd:string */
	std::wstring *Filesize;	/* optional element of type xsd:string */
	std::wstring *ActualSize;	/* optional element of type xsd:string */
	std::wstring *RecordSize;	/* optional element of type xsd:string */
	std::wstring *RecordCount;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	std::wstring *Persistent;	/* optional element of type xsd:string */
	std::wstring *Format;	/* optional element of type xsd:string */
	std::wstring *MaxRecordSize;	/* optional element of type xsd:string */
	std::wstring *CsvSeparate;	/* optional element of type xsd:string */
	std::wstring *CsvQuote;	/* optional element of type xsd:string */
	std::wstring *CsvTerminate;	/* optional element of type xsd:string */
	std::wstring *CsvEscape;	/* optional element of type xsd:string */
	std::wstring *Modified;	/* optional element of type xsd:string */
	std::wstring *Ecl;	/* optional element of type xsd:string */
	bool ZipFile;	/* optional element of type xsd:boolean */
	class ns3__DFUFileStat *Stat;	/* optional element of type ns3:DFUFileStat */
	class ns3__ArrayOfDFUPart *DFUFileParts;	/* optional element of type ns3:ArrayOfDFUPart */
	class ns3__ArrayOfDFUFilePartsOnCluster *DFUFilePartsOnClusters;	/* optional element of type ns3:ArrayOfDFUFilePartsOnCluster */
	bool isSuperfile;	/* optional element of type xsd:boolean */
	bool ShowFileContent;	/* optional element of type xsd:boolean */
	class ns3__EspStringArray *subfiles;	/* optional element of type ns3:EspStringArray */
	class ns3__ArrayOfDFULogicalFile *Superfiles;	/* optional element of type ns3:ArrayOfDFULogicalFile */
	class ns3__ArrayOfDFUFileProtect *ProtectList;	/* optional element of type ns3:ArrayOfDFUFileProtect */
	bool *FromRoxieCluster;	/* optional element of type xsd:boolean */
	_ns3__DFUFileDetail_Graphs *Graphs;	/* optional element of type ns3:DFUFileDetail-Graphs */
	std::wstring *UserPermission;	/* optional element of type xsd:string */
	std::wstring *ContentType;	/* optional element of type xsd:string */
	LONG64 *CompressedFileSize;	/* optional element of type xsd:long */
	std::wstring *PercentCompressed;	/* optional element of type xsd:string */
	bool IsCompressed;	/* optional element of type xsd:boolean */
	bool BrowseData;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns3__DFUFileDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUFileDetail() : Name(NULL), Filename(NULL), Prefix(NULL), NodeGroup(NULL), NumParts(NULL), Description(NULL), Dir(NULL), PathMask(NULL), Filesize(NULL), ActualSize(NULL), RecordSize(NULL), RecordCount(NULL), Wuid(NULL), Owner(NULL), Cluster(NULL), JobName(NULL), Persistent(NULL), Format(NULL), MaxRecordSize(NULL), CsvSeparate(NULL), CsvQuote(NULL), CsvTerminate(NULL), CsvEscape(NULL), Modified(NULL), Ecl(NULL), ZipFile((bool)0), Stat(NULL), DFUFileParts(NULL), DFUFilePartsOnClusters(NULL), isSuperfile((bool)0), ShowFileContent((bool)0), subfiles(NULL), Superfiles(NULL), ProtectList(NULL), FromRoxieCluster(NULL), Graphs(NULL), UserPermission(NULL), ContentType(NULL), CompressedFileSize(NULL), PercentCompressed(NULL), IsCompressed((bool)0), BrowseData((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUFileDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUFileStat
#define SOAP_TYPE_ns3__DFUFileStat (98)
/* ns3:DFUFileStat */
class SOAP_CMAC ns3__DFUFileStat
{
public:
	std::wstring *MinSkew;	/* optional element of type xsd:string */
	std::wstring *MaxSkew;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns3__DFUFileStat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUFileStat() : MinSkew(NULL), MaxSkew(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUFileStat() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUPart
#define SOAP_TYPE_ns3__DFUPart (99)
/* ns3:DFUPart */
class SOAP_CMAC ns3__DFUPart
{
public:
	int *Id;	/* optional element of type xsd:int */
	int *Copy;	/* optional element of type xsd:int */
	std::wstring *ActualSize;	/* optional element of type xsd:string */
	std::wstring *Ip;	/* optional element of type xsd:string */
	std::wstring *Partsize;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns3__DFUPart */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUPart() : Id(NULL), Copy(NULL), ActualSize(NULL), Ip(NULL), Partsize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUPart() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUFilePartsOnCluster
#define SOAP_TYPE_ns3__DFUFilePartsOnCluster (100)
/* ns3:DFUFilePartsOnCluster */
class SOAP_CMAC ns3__DFUFilePartsOnCluster
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *BaseDir;	/* optional element of type xsd:string */
	std::wstring *ReplicateDir;	/* optional element of type xsd:string */
	bool *Replicate;	/* optional element of type xsd:boolean */
	bool *CanReplicate;	/* optional element of type xsd:boolean */
	ns3__ArrayOfDFUPart *DFUFileParts;	/* optional element of type ns3:ArrayOfDFUPart */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns3__DFUFilePartsOnCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUFilePartsOnCluster() : Cluster(NULL), BaseDir(NULL), ReplicateDir(NULL), Replicate(NULL), CanReplicate(NULL), DFUFileParts(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUFilePartsOnCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUPart
#define SOAP_TYPE_ns3__ArrayOfDFUPart (101)
/* ns3:ArrayOfDFUPart */
class SOAP_CMAC ns3__ArrayOfDFUPart
{
public:
	std::vector<ns3__DFUPart * >DFUPart;	/* optional element of type ns3:DFUPart */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUPart */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUPart() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUPart() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFULogicalFile
#define SOAP_TYPE_ns3__DFULogicalFile (102)
/* ns3:DFULogicalFile */
class SOAP_CMAC ns3__DFULogicalFile
{
public:
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *NodeGroup;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Parts;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Totalsize;	/* optional element of type xsd:string */
	std::wstring *RecordCount;	/* optional element of type xsd:string */
	std::wstring *Modified;	/* optional element of type xsd:string */
	std::wstring *LongSize;	/* optional element of type xsd:string */
	std::wstring *LongRecordCount;	/* optional element of type xsd:string */
	bool *isSuperfile;	/* optional element of type xsd:boolean */
	bool *isZipfile;	/* optional element of type xsd:boolean */
	bool isDirectory;	/* optional element of type xsd:boolean */
	bool Replicate;	/* optional element of type xsd:boolean */
	LONG64 *IntSize;	/* optional element of type xsd:long */
	LONG64 *IntRecordCount;	/* optional element of type xsd:long */
	bool *FromRoxieCluster;	/* optional element of type xsd:boolean */
	bool *BrowseData;	/* optional element of type xsd:boolean */
	bool *IsKeyFile;	/* optional element of type xsd:boolean */
	bool *IsCompressed;	/* optional element of type xsd:boolean */
	std::wstring *ContentType;	/* optional element of type xsd:string */
	LONG64 *CompressedFileSize;	/* optional element of type xsd:long */
	std::wstring *SuperOwners;	/* optional element of type xsd:string */
	bool Persistent;	/* optional element of type xsd:boolean */
	bool IsProtected;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns3__DFULogicalFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFULogicalFile() : Prefix(NULL), ClusterName(NULL), NodeGroup(NULL), Directory(NULL), Description(NULL), Parts(NULL), Name(NULL), Owner(NULL), Totalsize(NULL), RecordCount(NULL), Modified(NULL), LongSize(NULL), LongRecordCount(NULL), isSuperfile(NULL), isZipfile(NULL), isDirectory((bool)0), Replicate((bool)0), IntSize(NULL), IntRecordCount(NULL), FromRoxieCluster(NULL), BrowseData(NULL), IsKeyFile(NULL), IsCompressed(NULL), ContentType(NULL), CompressedFileSize(NULL), SuperOwners(NULL), Persistent((bool)0), IsProtected((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFULogicalFile() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUFileProtect
#define SOAP_TYPE_ns3__DFUFileProtect (103)
/* ns3:DFUFileProtect */
class SOAP_CMAC ns3__DFUFileProtect
{
public:
	std::wstring *Owner;	/* optional element of type xsd:string */
	int *Count;	/* optional element of type xsd:int */
	std::wstring *Modified;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns3__DFUFileProtect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUFileProtect() : Owner(NULL), Count(NULL), Modified(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUFileProtect() { }
};
#endif

#ifndef SOAP_TYPE_ns3__EspStringArray
#define SOAP_TYPE_ns3__EspStringArray (104)
/* ns3:EspStringArray */
class SOAP_CMAC ns3__EspStringArray
{
public:
	std::vector<std::wstring * >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns3__EspStringArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__EspStringArray() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__EspStringArray() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUFilePartsOnCluster
#define SOAP_TYPE_ns3__ArrayOfDFUFilePartsOnCluster (105)
/* ns3:ArrayOfDFUFilePartsOnCluster */
class SOAP_CMAC ns3__ArrayOfDFUFilePartsOnCluster
{
public:
	std::vector<ns3__DFUFilePartsOnCluster * >DFUFilePartsOnCluster;	/* optional element of type ns3:DFUFilePartsOnCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUFilePartsOnCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUFilePartsOnCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUFilePartsOnCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUFileProtect
#define SOAP_TYPE_ns3__ArrayOfDFUFileProtect (106)
/* ns3:ArrayOfDFUFileProtect */
class SOAP_CMAC ns3__ArrayOfDFUFileProtect
{
public:
	std::vector<ns3__DFUFileProtect * >DFUFileProtect;	/* optional element of type ns3:DFUFileProtect */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUFileProtect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUFileProtect() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUFileProtect() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFULogicalFile
#define SOAP_TYPE_ns3__ArrayOfDFULogicalFile (107)
/* ns3:ArrayOfDFULogicalFile */
class SOAP_CMAC ns3__ArrayOfDFULogicalFile
{
public:
	std::vector<ns3__DFULogicalFile * >DFULogicalFile;	/* optional element of type ns3:DFULogicalFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFULogicalFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFULogicalFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFULogicalFile() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUActionInfo
#define SOAP_TYPE_ns3__DFUActionInfo (108)
/* ns3:DFUActionInfo */
class SOAP_CMAC ns3__DFUActionInfo
{
public:
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *NodeGroup;	/* optional element of type xsd:string */
	std::wstring *ActionResult;	/* optional element of type xsd:string */
	bool *Failed;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns3__DFUActionInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUActionInfo() : FileName(NULL), NodeGroup(NULL), ActionResult(NULL), Failed(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUActionInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUActionInfo
#define SOAP_TYPE_ns3__ArrayOfDFUActionInfo (109)
/* ns3:ArrayOfDFUActionInfo */
class SOAP_CMAC ns3__ArrayOfDFUActionInfo
{
public:
	std::vector<ns3__DFUActionInfo * >DFUActionInfo;	/* optional element of type ns3:DFUActionInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUActionInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUActionInfo() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUActionInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUSpaceItem
#define SOAP_TYPE_ns3__DFUSpaceItem (110)
/* ns3:DFUSpaceItem */
class SOAP_CMAC ns3__DFUSpaceItem
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *NumOfFiles;	/* optional element of type xsd:string */
	std::wstring *NumOfFilesUnknown;	/* optional element of type xsd:string */
	std::wstring *TotalSize;	/* optional element of type xsd:string */
	std::wstring *LargestFile;	/* optional element of type xsd:string */
	std::wstring *LargestSize;	/* optional element of type xsd:string */
	std::wstring *SmallestFile;	/* optional element of type xsd:string */
	std::wstring *SmallestSize;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns3__DFUSpaceItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUSpaceItem() : Name(NULL), NumOfFiles(NULL), NumOfFilesUnknown(NULL), TotalSize(NULL), LargestFile(NULL), LargestSize(NULL), SmallestFile(NULL), SmallestSize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUSpaceItem() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUSpaceItem
#define SOAP_TYPE_ns3__ArrayOfDFUSpaceItem (111)
/* ns3:ArrayOfDFUSpaceItem */
class SOAP_CMAC ns3__ArrayOfDFUSpaceItem
{
public:
	std::vector<ns3__DFUSpaceItem * >DFUSpaceItem;	/* optional element of type ns3:DFUSpaceItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUSpaceItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUSpaceItem() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUSpaceItem() { }
};
#endif

#ifndef SOAP_TYPE_ns3__History
#define SOAP_TYPE_ns3__History (112)
/* ns3:History */
class SOAP_CMAC ns3__History
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Operation;	/* optional element of type xsd:string */
	std::wstring *Timestamp;	/* optional element of type xsd:string */
	std::wstring *IP;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Workunit;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_ns3__History */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__History() : Name(NULL), Operation(NULL), Timestamp(NULL), IP(NULL), Path(NULL), Owner(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__History() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddRequest
#define SOAP_TYPE__ns3__AddRequest (113)
/* ns3:AddRequest */
class SOAP_CMAC _ns3__AddRequest
{
public:
	std::wstring *dstname;	/* optional element of type xsd:string */
	xsd__base64Binary *xmlmap;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE__ns3__AddRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddRequest() : dstname(NULL), xmlmap(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddResponse
#define SOAP_TYPE__ns3__AddResponse (114)
/* ns3:AddResponse */
class SOAP_CMAC _ns3__AddResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE__ns3__AddResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddRemoteRequest
#define SOAP_TYPE__ns3__AddRemoteRequest (115)
/* ns3:AddRemoteRequest */
class SOAP_CMAC _ns3__AddRemoteRequest
{
public:
	std::wstring *dstname;	/* optional element of type xsd:string */
	std::wstring *srcname;	/* optional element of type xsd:string */
	std::wstring *srcdali;	/* optional element of type xsd:string */
	std::wstring *srcusername;	/* optional element of type xsd:string */
	std::wstring *srcpassword;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE__ns3__AddRemoteRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddRemoteRequest() : dstname(NULL), srcname(NULL), srcdali(NULL), srcusername(NULL), srcpassword(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddRemoteRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddRemoteResponse
#define SOAP_TYPE__ns3__AddRemoteResponse (116)
/* ns3:AddRemoteResponse */
class SOAP_CMAC _ns3__AddRemoteResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE__ns3__AddRemoteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddRemoteResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddRemoteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddtoSuperfileRequest
#define SOAP_TYPE__ns3__AddtoSuperfileRequest (117)
/* ns3:AddtoSuperfileRequest */
class SOAP_CMAC _ns3__AddtoSuperfileRequest
{
public:
	std::wstring *Superfile;	/* optional element of type xsd:string */
	std::wstring *Subfiles;	/* optional element of type xsd:string */
	ns3__EspStringArray *names;	/* optional element of type ns3:EspStringArray */
	bool ExistingFile;	/* optional element of type xsd:boolean */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE__ns3__AddtoSuperfileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddtoSuperfileRequest() : Superfile(NULL), Subfiles(NULL), names(NULL), ExistingFile((bool)0), BackToPage(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddtoSuperfileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddtoSuperfileResponse_SubfileNames
#define SOAP_TYPE__ns3__AddtoSuperfileResponse_SubfileNames (590)
/* ns3:AddtoSuperfileResponse-SubfileNames */
class SOAP_CMAC _ns3__AddtoSuperfileResponse_SubfileNames
{
public:
	std::vector<std::wstring * >SubfileName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 590; } /* = unique id SOAP_TYPE__ns3__AddtoSuperfileResponse_SubfileNames */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddtoSuperfileResponse_SubfileNames()  { this->soap_default(NULL); }
	virtual ~_ns3__AddtoSuperfileResponse_SubfileNames() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddtoSuperfileResponse
#define SOAP_TYPE__ns3__AddtoSuperfileResponse (118)
/* ns3:AddtoSuperfileResponse */
class SOAP_CMAC _ns3__AddtoSuperfileResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *Subfiles;	/* optional element of type xsd:string */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	_ns3__AddtoSuperfileResponse_SubfileNames *SubfileNames;	/* optional element of type ns3:AddtoSuperfileResponse-SubfileNames */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE__ns3__AddtoSuperfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddtoSuperfileResponse() : Exceptions(NULL), Subfiles(NULL), BackToPage(NULL), SubfileNames(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddtoSuperfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUArrayActionRequest
#define SOAP_TYPE__ns3__DFUArrayActionRequest (119)
/* ns3:DFUArrayActionRequest */
class SOAP_CMAC _ns3__DFUArrayActionRequest
{
public:
	enum ns3__DFUArrayActions *Type;	/* optional element of type ns3:DFUArrayActions */
	bool *NoDelete;	/* optional element of type xsd:boolean */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	ns3__EspStringArray *LogicalFiles;	/* optional element of type ns3:EspStringArray */
	bool removeFromSuperfiles;	/* optional element of type xsd:boolean */
	bool removeRecursively;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE__ns3__DFUArrayActionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUArrayActionRequest() : Type(NULL), NoDelete(NULL), BackToPage(NULL), LogicalFiles(NULL), removeFromSuperfiles((bool)0), removeRecursively((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUArrayActionRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUArrayActionResponse
#define SOAP_TYPE__ns3__DFUArrayActionResponse (120)
/* ns3:DFUArrayActionResponse */
class SOAP_CMAC _ns3__DFUArrayActionResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	std::wstring *RedirectTo;	/* optional element of type xsd:string */
	ns3__ArrayOfDFUActionInfo *ActionResults;	/* optional element of type ns3:ArrayOfDFUActionInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE__ns3__DFUArrayActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUArrayActionResponse() : Exceptions(NULL), BackToPage(NULL), RedirectTo(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUArrayActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUBrowseDataRequest
#define SOAP_TYPE__ns3__DFUBrowseDataRequest (121)
/* ns3:DFUBrowseDataRequest */
class SOAP_CMAC _ns3__DFUBrowseDataRequest
{
public:
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	bool SchemaOnly;	/* optional element of type xsd:boolean */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE__ns3__DFUBrowseDataRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUBrowseDataRequest() : LogicalName(NULL), FilterBy(NULL), ShowColumns(NULL), SchemaOnly((bool)0), StartForGoback(NULL), CountForGoback(NULL), ChooseFile(NULL), Cluster(NULL), ClusterType(NULL), ParentName(NULL), Start(NULL), Count(NULL), DisableUppercaseTranslation(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUBrowseDataRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUBrowseDataResponse_ColumnsHidden
#define SOAP_TYPE__ns3__DFUBrowseDataResponse_ColumnsHidden (594)
/* ns3:DFUBrowseDataResponse-ColumnsHidden */
class SOAP_CMAC _ns3__DFUBrowseDataResponse_ColumnsHidden
{
public:
	std::vector<ns3__DFUDataColumn * >ColumnHidden;	/* optional element of type ns3:DFUDataColumn */
public:
	virtual int soap_type() const { return 594; } /* = unique id SOAP_TYPE__ns3__DFUBrowseDataResponse_ColumnsHidden */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUBrowseDataResponse_ColumnsHidden()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUBrowseDataResponse_ColumnsHidden() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUBrowseDataResponse
#define SOAP_TYPE__ns3__DFUBrowseDataResponse (122)
/* ns3:DFUBrowseDataResponse */
class SOAP_CMAC _ns3__DFUBrowseDataResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *FilterForGoBack;	/* optional element of type xsd:string */
	_ns3__DFUBrowseDataResponse_ColumnsHidden *ColumnsHidden;	/* optional element of type ns3:DFUBrowseDataResponse-ColumnsHidden */
	int *ColumnCount;	/* optional element of type xsd:int */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	int *ChooseFile;	/* optional element of type xsd:int */
	bool SchemaOnly;	/* optional element of type xsd:boolean */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	LONG64 *Count;	/* optional element of type xsd:long */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *Total;	/* optional element of type xsd:long */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *MsgToDisplay;	/* optional element of type xsd:string */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE__ns3__DFUBrowseDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUBrowseDataResponse() : Exceptions(NULL), Name(NULL), LogicalName(NULL), FilterBy(NULL), FilterForGoBack(NULL), ColumnsHidden(NULL), ColumnCount(NULL), StartForGoback(NULL), CountForGoback(NULL), ChooseFile(NULL), SchemaOnly((bool)0), Cluster(NULL), ClusterType(NULL), ParentName(NULL), Start(NULL), Count(NULL), PageSize(NULL), Total(NULL), Result(NULL), MsgToDisplay(NULL), DisableUppercaseTranslation(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUBrowseDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUDefFileRequest
#define SOAP_TYPE__ns3__DFUDefFileRequest (123)
/* ns3:DFUDefFileRequest */
class SOAP_CMAC _ns3__DFUDefFileRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Format;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE__ns3__DFUDefFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUDefFileRequest() : Name(NULL), Format(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUDefFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUDefFileResponse
#define SOAP_TYPE__ns3__DFUDefFileResponse (124)
/* ns3:DFUDefFileResponse */
class SOAP_CMAC _ns3__DFUDefFileResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	xsd__base64Binary *defFile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE__ns3__DFUDefFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUDefFileResponse() : Exceptions(NULL), defFile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUDefFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUFileViewRequest
#define SOAP_TYPE__ns3__DFUFileViewRequest (125)
/* ns3:DFUFileViewRequest */
class SOAP_CMAC _ns3__DFUFileViewRequest
{
public:
	std::wstring *Scope;	/* optional element of type xsd:string */
	bool *IncludeSuperOwner;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 125; } /* = unique id SOAP_TYPE__ns3__DFUFileViewRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUFileViewRequest() : Scope(NULL), IncludeSuperOwner(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUFileViewRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUFileViewResponse
#define SOAP_TYPE__ns3__DFUFileViewResponse (126)
/* ns3:DFUFileViewResponse */
class SOAP_CMAC _ns3__DFUFileViewResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *Scope;	/* optional element of type xsd:string */
	int *NumFiles;	/* optional element of type xsd:int */
	ns3__ArrayOfDFULogicalFile *DFULogicalFiles;	/* optional element of type ns3:ArrayOfDFULogicalFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE__ns3__DFUFileViewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUFileViewResponse() : Exceptions(NULL), Scope(NULL), NumFiles(NULL), DFULogicalFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUFileViewResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUGetDataColumnsRequest
#define SOAP_TYPE__ns3__DFUGetDataColumnsRequest (127)
/* ns3:DFUGetDataColumnsRequest */
class SOAP_CMAC _ns3__DFUGetDataColumnsRequest
{
public:
	std::wstring *OpenLogicalName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE__ns3__DFUGetDataColumnsRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUGetDataColumnsRequest() : OpenLogicalName(NULL), LogicalName(NULL), FilterBy(NULL), ShowColumns(NULL), ChooseFile(NULL), Cluster(NULL), ClusterType(NULL), StartIndex(NULL), EndIndex(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUGetDataColumnsRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUGetDataColumnsResponse
#define SOAP_TYPE__ns3__DFUGetDataColumnsResponse (128)
/* ns3:DFUGetDataColumnsResponse */
class SOAP_CMAC _ns3__DFUGetDataColumnsResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	LONG64 *RowCount;	/* optional element of type xsd:long */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE__ns3__DFUGetDataColumnsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUGetDataColumnsResponse() : Exceptions(NULL), LogicalName(NULL), StartIndex(NULL), EndIndex(NULL), DFUDataKeyedColumns1(NULL), DFUDataKeyedColumns2(NULL), DFUDataKeyedColumns3(NULL), DFUDataKeyedColumns4(NULL), DFUDataKeyedColumns5(NULL), DFUDataKeyedColumns6(NULL), DFUDataKeyedColumns7(NULL), DFUDataKeyedColumns8(NULL), DFUDataKeyedColumns9(NULL), DFUDataKeyedColumns10(NULL), DFUDataKeyedColumns11(NULL), DFUDataKeyedColumns12(NULL), DFUDataKeyedColumns13(NULL), DFUDataKeyedColumns14(NULL), DFUDataKeyedColumns15(NULL), DFUDataKeyedColumns16(NULL), DFUDataKeyedColumns17(NULL), DFUDataKeyedColumns18(NULL), DFUDataKeyedColumns19(NULL), DFUDataKeyedColumns20(NULL), DFUDataNonKeyedColumns1(NULL), DFUDataNonKeyedColumns2(NULL), DFUDataNonKeyedColumns3(NULL), DFUDataNonKeyedColumns4(NULL), DFUDataNonKeyedColumns5(NULL), DFUDataNonKeyedColumns6(NULL), DFUDataNonKeyedColumns7(NULL), DFUDataNonKeyedColumns8(NULL), DFUDataNonKeyedColumns9(NULL), DFUDataNonKeyedColumns10(NULL), DFUDataNonKeyedColumns11(NULL), DFUDataNonKeyedColumns12(NULL), DFUDataNonKeyedColumns13(NULL), DFUDataNonKeyedColumns14(NULL), DFUDataNonKeyedColumns15(NULL), DFUDataNonKeyedColumns16(NULL), DFUDataNonKeyedColumns17(NULL), DFUDataNonKeyedColumns18(NULL), DFUDataNonKeyedColumns19(NULL), DFUDataNonKeyedColumns20(NULL), RowCount(NULL), ShowColumns(NULL), ChooseFile(NULL), Cluster(NULL), ClusterType(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUGetDataColumnsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUGetFileMetaDataRequest
#define SOAP_TYPE__ns3__DFUGetFileMetaDataRequest (129)
/* ns3:DFUGetFileMetaDataRequest */
class SOAP_CMAC _ns3__DFUGetFileMetaDataRequest
{
public:
	std::wstring *LogicalFileName;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	bool IncludeXmlSchema;	/* optional element of type xsd:boolean */
	bool AddHeaderInXmlSchema;	/* optional element of type xsd:boolean */
	bool IncludeXmlXPathSchema;	/* optional element of type xsd:boolean */
	bool AddHeaderInXmlXPathSchema;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE__ns3__DFUGetFileMetaDataRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUGetFileMetaDataRequest() : LogicalFileName(NULL), ClusterName(NULL), IncludeXmlSchema((bool)0), AddHeaderInXmlSchema((bool)0), IncludeXmlXPathSchema((bool)0), AddHeaderInXmlXPathSchema((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUGetFileMetaDataRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUGetFileMetaDataResponse
#define SOAP_TYPE__ns3__DFUGetFileMetaDataResponse (130)
/* ns3:DFUGetFileMetaDataResponse */
class SOAP_CMAC _ns3__DFUGetFileMetaDataResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	int *TotalColumnCount;	/* optional element of type xsd:int */
	int *KeyedColumnCount;	/* optional element of type xsd:int */
	ns3__ArrayOfDFUDataColumn *DataColumns;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	std::wstring *XmlSchema;	/* optional element of type xsd:string */
	std::wstring *XmlXPathSchema;	/* optional element of type xsd:string */
	LONG64 *TotalResultRows;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE__ns3__DFUGetFileMetaDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUGetFileMetaDataResponse() : Exceptions(NULL), TotalColumnCount(NULL), KeyedColumnCount(NULL), DataColumns(NULL), XmlSchema(NULL), XmlXPathSchema(NULL), TotalResultRows(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUGetFileMetaDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUInfoRequest
#define SOAP_TYPE__ns3__DFUInfoRequest (131)
/* ns3:DFUInfoRequest */
class SOAP_CMAC _ns3__DFUInfoRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	bool UpdateDescription;	/* optional element of type xsd:boolean */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *FileDesc;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE__ns3__DFUInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUInfoRequest() : Name(NULL), Cluster(NULL), UpdateDescription((bool)0), FileName(NULL), FileDesc(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUInfoResponse
#define SOAP_TYPE__ns3__DFUInfoResponse (132)
/* ns3:DFUInfoResponse */
class SOAP_CMAC _ns3__DFUInfoResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	ns3__DFUFileDetail *FileDetail;	/* optional element of type ns3:DFUFileDetail */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE__ns3__DFUInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUInfoResponse() : Exceptions(NULL), FileDetail(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUQueryRequest
#define SOAP_TYPE__ns3__DFUQueryRequest (133)
/* ns3:DFUQueryRequest */
class SOAP_CMAC _ns3__DFUQueryRequest
{
public:
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *NodeGroup;	/* optional element of type xsd:string */
	std::wstring *ContentType;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *FileType;	/* optional element of type xsd:string */
	LONG64 FileSizeFrom;	/* optional element of type xsd:long */
	LONG64 FileSizeTo;	/* optional element of type xsd:long */
	int FirstN;	/* optional element of type xsd:int */
	int *PageSize;	/* optional element of type xsd:int */
	int *PageStartFrom;	/* optional element of type xsd:int */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	bool OneLevelDirFileReturn;	/* optional element of type xsd:boolean */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	int *MaxNumberOfFiles;	/* optional element of type xsd:int */
	bool *IncludeSuperOwner;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE__ns3__DFUQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUQueryRequest() : Prefix(NULL), NodeGroup(NULL), ContentType(NULL), LogicalName(NULL), Description(NULL), Owner(NULL), StartDate(NULL), EndDate(NULL), FileType(NULL), FileSizeFrom(0), FileSizeTo(0), FirstN(0), PageSize(NULL), PageStartFrom(NULL), Sortby(NULL), Descending((bool)0), OneLevelDirFileReturn((bool)0), CacheHint(NULL), MaxNumberOfFiles(NULL), IncludeSuperOwner(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUQueryResponse
#define SOAP_TYPE__ns3__DFUQueryResponse (134)
/* ns3:DFUQueryResponse */
class SOAP_CMAC _ns3__DFUQueryResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	ns3__ArrayOfDFULogicalFile *DFULogicalFiles;	/* optional element of type ns3:ArrayOfDFULogicalFile */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *NodeGroup;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *FileType;	/* optional element of type xsd:string */
	LONG64 FileSizeFrom;	/* optional element of type xsd:long */
	LONG64 FileSizeTo;	/* optional element of type xsd:long */
	int FirstN;	/* optional element of type xsd:int */
	int PageSize;	/* optional element of type xsd:int */
	LONG64 PageStartFrom;	/* optional element of type xsd:long */
	LONG64 LastPageFrom;	/* optional element of type xsd:long */
	LONG64 *PageEndAt;	/* optional element of type xsd:long */
	LONG64 PrevPageFrom;	/* optional element of type xsd:long */
	LONG64 NextPageFrom;	/* optional element of type xsd:long */
	LONG64 *NumFiles;	/* optional element of type xsd:long */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	std::wstring *BasicQuery;	/* optional element of type xsd:string */
	std::wstring *ParametersForPaging;	/* optional element of type xsd:string */
	std::wstring *Filters;	/* optional element of type xsd:string */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	bool *IsSubsetOfFiles;	/* optional element of type xsd:boolean */
	std::wstring *Warning;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE__ns3__DFUQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUQueryResponse() : Exceptions(NULL), DFULogicalFiles(NULL), Prefix(NULL), NodeGroup(NULL), LogicalName(NULL), Description(NULL), Owner(NULL), StartDate(NULL), EndDate(NULL), FileType(NULL), FileSizeFrom(0), FileSizeTo(0), FirstN(0), PageSize(0), PageStartFrom(0), LastPageFrom(0), PageEndAt(NULL), PrevPageFrom(0), NextPageFrom(0), NumFiles(NULL), Sortby(NULL), Descending((bool)0), BasicQuery(NULL), ParametersForPaging(NULL), Filters(NULL), CacheHint(NULL), IsSubsetOfFiles(NULL), Warning(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchRequest
#define SOAP_TYPE__ns3__DFUSearchRequest (135)
/* ns3:DFUSearchRequest */
class SOAP_CMAC _ns3__DFUSearchRequest
{
public:
	std::wstring *ShowExample;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE__ns3__DFUSearchRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchRequest() : ShowExample(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchResponse_ClusterNames
#define SOAP_TYPE__ns3__DFUSearchResponse_ClusterNames (597)
/* ns3:DFUSearchResponse-ClusterNames */
class SOAP_CMAC _ns3__DFUSearchResponse_ClusterNames
{
public:
	std::vector<std::wstring * >ClusterName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 597; } /* = unique id SOAP_TYPE__ns3__DFUSearchResponse_ClusterNames */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchResponse_ClusterNames()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchResponse_ClusterNames() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchResponse_FileTypes
#define SOAP_TYPE__ns3__DFUSearchResponse_FileTypes (599)
/* ns3:DFUSearchResponse-FileTypes */
class SOAP_CMAC _ns3__DFUSearchResponse_FileTypes
{
public:
	std::vector<std::wstring * >FileType;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 599; } /* = unique id SOAP_TYPE__ns3__DFUSearchResponse_FileTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchResponse_FileTypes()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchResponse_FileTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchResponse
#define SOAP_TYPE__ns3__DFUSearchResponse (136)
/* ns3:DFUSearchResponse */
class SOAP_CMAC _ns3__DFUSearchResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *ShowExample;	/* optional element of type xsd:string */
	_ns3__DFUSearchResponse_ClusterNames *ClusterNames;	/* optional element of type ns3:DFUSearchResponse-ClusterNames */
	_ns3__DFUSearchResponse_FileTypes *FileTypes;	/* optional element of type ns3:DFUSearchResponse-FileTypes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 136; } /* = unique id SOAP_TYPE__ns3__DFUSearchResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchResponse() : Exceptions(NULL), ShowExample(NULL), ClusterNames(NULL), FileTypes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchDataRequest
#define SOAP_TYPE__ns3__DFUSearchDataRequest (137)
/* ns3:DFUSearchDataRequest */
class SOAP_CMAC _ns3__DFUSearchDataRequest
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *OpenLogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	std::wstring *File;	/* optional element of type xsd:string */
	std::wstring *Key;	/* optional element of type xsd:string */
	bool SchemaOnly;	/* optional element of type xsd:boolean */
	bool RoxieSelections;	/* optional element of type xsd:boolean */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	std::wstring *SelectedKey;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE__ns3__DFUSearchDataRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchDataRequest() : Cluster(NULL), ClusterType(NULL), OpenLogicalName(NULL), FilterBy(NULL), ShowColumns(NULL), ChooseFile(NULL), StartIndex(NULL), EndIndex(NULL), LogicalName(NULL), ParentName(NULL), StartForGoback(NULL), CountForGoback(NULL), Start(NULL), Count(NULL), File(NULL), Key(NULL), SchemaOnly((bool)0), RoxieSelections((bool)0), DisableUppercaseTranslation(NULL), SelectedKey(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchDataRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchDataResponse_ColumnsHidden
#define SOAP_TYPE__ns3__DFUSearchDataResponse_ColumnsHidden (601)
/* ns3:DFUSearchDataResponse-ColumnsHidden */
class SOAP_CMAC _ns3__DFUSearchDataResponse_ColumnsHidden
{
public:
	std::vector<ns3__DFUDataColumn * >ColumnHidden;	/* optional element of type ns3:DFUDataColumn */
public:
	virtual int soap_type() const { return 601; } /* = unique id SOAP_TYPE__ns3__DFUSearchDataResponse_ColumnsHidden */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchDataResponse_ColumnsHidden()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchDataResponse_ColumnsHidden() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchDataResponse
#define SOAP_TYPE__ns3__DFUSearchDataResponse (138)
/* ns3:DFUSearchDataResponse */
class SOAP_CMAC _ns3__DFUSearchDataResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *OpenLogicalName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	LONG64 *RowCount;	/* optional element of type xsd:long */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *FilterForGoBack;	/* optional element of type xsd:string */
	_ns3__DFUSearchDataResponse_ColumnsHidden *ColumnsHidden;	/* optional element of type ns3:DFUSearchDataResponse-ColumnsHidden */
	int *ColumnCount;	/* optional element of type xsd:int */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	LONG64 *Start;	/* optional element of type xsd:long */
	LONG64 *Count;	/* optional element of type xsd:long */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *Total;	/* optional element of type xsd:long */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *MsgToDisplay;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *File;	/* optional element of type xsd:string */
	std::wstring *Key;	/* optional element of type xsd:string */
	bool *SchemaOnly;	/* optional element of type xsd:boolean */
	bool *RoxieSelections;	/* optional element of type xsd:boolean */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	bool *AutoUppercaseTranslation;	/* optional element of type xsd:boolean */
	std::wstring *SelectedKey;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE__ns3__DFUSearchDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchDataResponse() : Exceptions(NULL), OpenLogicalName(NULL), LogicalName(NULL), ParentName(NULL), StartIndex(NULL), EndIndex(NULL), DFUDataKeyedColumns1(NULL), DFUDataKeyedColumns2(NULL), DFUDataKeyedColumns3(NULL), DFUDataKeyedColumns4(NULL), DFUDataKeyedColumns5(NULL), DFUDataKeyedColumns6(NULL), DFUDataKeyedColumns7(NULL), DFUDataKeyedColumns8(NULL), DFUDataKeyedColumns9(NULL), DFUDataKeyedColumns10(NULL), DFUDataKeyedColumns11(NULL), DFUDataKeyedColumns12(NULL), DFUDataKeyedColumns13(NULL), DFUDataKeyedColumns14(NULL), DFUDataKeyedColumns15(NULL), DFUDataKeyedColumns16(NULL), DFUDataKeyedColumns17(NULL), DFUDataKeyedColumns18(NULL), DFUDataKeyedColumns19(NULL), DFUDataKeyedColumns20(NULL), DFUDataNonKeyedColumns1(NULL), DFUDataNonKeyedColumns2(NULL), DFUDataNonKeyedColumns3(NULL), DFUDataNonKeyedColumns4(NULL), DFUDataNonKeyedColumns5(NULL), DFUDataNonKeyedColumns6(NULL), DFUDataNonKeyedColumns7(NULL), DFUDataNonKeyedColumns8(NULL), DFUDataNonKeyedColumns9(NULL), DFUDataNonKeyedColumns10(NULL), DFUDataNonKeyedColumns11(NULL), DFUDataNonKeyedColumns12(NULL), DFUDataNonKeyedColumns13(NULL), DFUDataNonKeyedColumns14(NULL), DFUDataNonKeyedColumns15(NULL), DFUDataNonKeyedColumns16(NULL), DFUDataNonKeyedColumns17(NULL), DFUDataNonKeyedColumns18(NULL), DFUDataNonKeyedColumns19(NULL), DFUDataNonKeyedColumns20(NULL), RowCount(NULL), ShowColumns(NULL), ChooseFile(NULL), Name(NULL), FilterBy(NULL), FilterForGoBack(NULL), ColumnsHidden(NULL), ColumnCount(NULL), StartForGoback(NULL), CountForGoback(NULL), Start(NULL), Count(NULL), PageSize(NULL), Total(NULL), Result(NULL), MsgToDisplay(NULL), Cluster(NULL), ClusterType(NULL), File(NULL), Key(NULL), SchemaOnly(NULL), RoxieSelections(NULL), DisableUppercaseTranslation(NULL), AutoUppercaseTranslation(NULL), SelectedKey(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSpaceRequest
#define SOAP_TYPE__ns3__DFUSpaceRequest (139)
/* ns3:DFUSpaceRequest */
class SOAP_CMAC _ns3__DFUSpaceRequest
{
public:
	std::wstring *CountBy;	/* optional element of type xsd:string */
	std::wstring *ScopeUnder;	/* optional element of type xsd:string */
	std::wstring *OwnerUnder;	/* optional element of type xsd:string */
	std::wstring *Interval;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE__ns3__DFUSpaceRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSpaceRequest() : CountBy(NULL), ScopeUnder(NULL), OwnerUnder(NULL), Interval(NULL), StartDate(NULL), EndDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSpaceRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSpaceResponse
#define SOAP_TYPE__ns3__DFUSpaceResponse (140)
/* ns3:DFUSpaceResponse */
class SOAP_CMAC _ns3__DFUSpaceResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *CountBy;	/* optional element of type xsd:string */
	std::wstring *ScopeUnder;	/* optional element of type xsd:string */
	std::wstring *OwnerUnder;	/* optional element of type xsd:string */
	std::wstring *Interval;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	ns3__ArrayOfDFUSpaceItem *DFUSpaceItems;	/* optional element of type ns3:ArrayOfDFUSpaceItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE__ns3__DFUSpaceResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSpaceResponse() : Exceptions(NULL), CountBy(NULL), ScopeUnder(NULL), OwnerUnder(NULL), Interval(NULL), StartDate(NULL), EndDate(NULL), DFUSpaceItems(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSpaceResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__EraseHistoryRequest
#define SOAP_TYPE__ns3__EraseHistoryRequest (141)
/* ns3:EraseHistoryRequest */
class SOAP_CMAC _ns3__EraseHistoryRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 141; } /* = unique id SOAP_TYPE__ns3__EraseHistoryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__EraseHistoryRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__EraseHistoryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__EraseHistoryResponse_History
#define SOAP_TYPE__ns3__EraseHistoryResponse_History (604)
/* ns3:EraseHistoryResponse-History */
class SOAP_CMAC _ns3__EraseHistoryResponse_History
{
public:
	std::vector<ns3__History * >Origin;	/* optional element of type ns3:History */
public:
	virtual int soap_type() const { return 604; } /* = unique id SOAP_TYPE__ns3__EraseHistoryResponse_History */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__EraseHistoryResponse_History()  { this->soap_default(NULL); }
	virtual ~_ns3__EraseHistoryResponse_History() { }
};
#endif

#ifndef SOAP_TYPE__ns3__EraseHistoryResponse
#define SOAP_TYPE__ns3__EraseHistoryResponse (142)
/* ns3:EraseHistoryResponse */
class SOAP_CMAC _ns3__EraseHistoryResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	_ns3__EraseHistoryResponse_History *History;	/* optional element of type ns3:EraseHistoryResponse-History */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE__ns3__EraseHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__EraseHistoryResponse() : Exceptions(NULL), History(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__EraseHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ListHistoryRequest
#define SOAP_TYPE__ns3__ListHistoryRequest (143)
/* ns3:ListHistoryRequest */
class SOAP_CMAC _ns3__ListHistoryRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE__ns3__ListHistoryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ListHistoryRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__ListHistoryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ListHistoryResponse_History
#define SOAP_TYPE__ns3__ListHistoryResponse_History (608)
/* ns3:ListHistoryResponse-History */
class SOAP_CMAC _ns3__ListHistoryResponse_History
{
public:
	std::vector<ns3__History * >Origin;	/* optional element of type ns3:History */
public:
	virtual int soap_type() const { return 608; } /* = unique id SOAP_TYPE__ns3__ListHistoryResponse_History */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ListHistoryResponse_History()  { this->soap_default(NULL); }
	virtual ~_ns3__ListHistoryResponse_History() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ListHistoryResponse
#define SOAP_TYPE__ns3__ListHistoryResponse (144)
/* ns3:ListHistoryResponse */
class SOAP_CMAC _ns3__ListHistoryResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	_ns3__ListHistoryResponse_History *History;	/* optional element of type ns3:ListHistoryResponse-History */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE__ns3__ListHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ListHistoryResponse() : Exceptions(NULL), History(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__ListHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SavexmlRequest
#define SOAP_TYPE__ns3__SavexmlRequest (145)
/* ns3:SavexmlRequest */
class SOAP_CMAC _ns3__SavexmlRequest
{
public:
	std::wstring *name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 145; } /* = unique id SOAP_TYPE__ns3__SavexmlRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SavexmlRequest() : name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SavexmlRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SavexmlResponse
#define SOAP_TYPE__ns3__SavexmlResponse (146)
/* ns3:SavexmlResponse */
class SOAP_CMAC _ns3__SavexmlResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	xsd__base64Binary *xmlmap;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 146; } /* = unique id SOAP_TYPE__ns3__SavexmlResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SavexmlResponse() : Exceptions(NULL), xmlmap(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SavexmlResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileActionRequest
#define SOAP_TYPE__ns3__SuperfileActionRequest (147)
/* ns3:SuperfileActionRequest */
class SOAP_CMAC _ns3__SuperfileActionRequest
{
public:
	std::wstring *action;	/* optional element of type xsd:string */
	std::wstring *superfile;	/* optional element of type xsd:string */
	ns3__EspStringArray *subfiles;	/* optional element of type ns3:EspStringArray */
	std::wstring *before;	/* optional element of type xsd:string */
	bool *delete_;	/* optional element of type xsd:boolean */
	bool *removeSuperfile;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE__ns3__SuperfileActionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileActionRequest() : action(NULL), superfile(NULL), subfiles(NULL), before(NULL), delete_(NULL), removeSuperfile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileActionRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileActionResponse
#define SOAP_TYPE__ns3__SuperfileActionResponse (148)
/* ns3:SuperfileActionResponse */
class SOAP_CMAC _ns3__SuperfileActionResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *superfile;	/* optional element of type xsd:string */
	int *retcode;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE__ns3__SuperfileActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileActionResponse() : Exceptions(NULL), superfile(NULL), retcode(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileListRequest
#define SOAP_TYPE__ns3__SuperfileListRequest (149)
/* ns3:SuperfileListRequest */
class SOAP_CMAC _ns3__SuperfileListRequest
{
public:
	std::wstring *superfile;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE__ns3__SuperfileListRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileListRequest() : superfile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileListRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileListResponse
#define SOAP_TYPE__ns3__SuperfileListResponse (150)
/* ns3:SuperfileListResponse */
class SOAP_CMAC _ns3__SuperfileListResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *superfile;	/* optional element of type xsd:string */
	ns3__EspStringArray *subfiles;	/* optional element of type ns3:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 150; } /* = unique id SOAP_TYPE__ns3__SuperfileListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileListResponse() : Exceptions(NULL), superfile(NULL), subfiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileListResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns4__EspException
#define SOAP_TYPE_ns4__EspException (151)
/* ns4:EspException */
class SOAP_CMAC ns4__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE_ns4__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfEspException
#define SOAP_TYPE_ns4__ArrayOfEspException (152)
/* ns4:ArrayOfEspException */
class SOAP_CMAC ns4__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns4__EspException * >Exception;	/* optional element of type ns4:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 152; } /* = unique id SOAP_TYPE_ns4__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns4__TargetCluster
#define SOAP_TYPE_ns4__TargetCluster (153)
/* ns4:TargetCluster */
class SOAP_CMAC ns4__TargetCluster
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *QueueStatus;	/* optional element of type xsd:string */
	std::wstring *StatusDetails;	/* optional element of type xsd:string */
	std::wstring *Warning;	/* optional element of type xsd:string */
	int *ClusterType;	/* optional element of type xsd:int */
	int *ClusterSize;	/* optional element of type xsd:int */
	int *ClusterStatus;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 153; } /* = unique id SOAP_TYPE_ns4__TargetCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__TargetCluster() : ClusterName(NULL), QueueName(NULL), QueueStatus(NULL), StatusDetails(NULL), Warning(NULL), ClusterType(NULL), ClusterSize(NULL), ClusterStatus(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__TargetCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__DFUJob
#define SOAP_TYPE_ns4__DFUJob (154)
/* ns4:DFUJob */
class SOAP_CMAC ns4__DFUJob
{
public:
	std::wstring *TimeStarted;	/* optional element of type xsd:string */
	int *Done;	/* optional element of type xsd:int */
	int *Total;	/* optional element of type xsd:int */
	std::wstring *Command;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 154; } /* = unique id SOAP_TYPE_ns4__DFUJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__DFUJob() : TimeStarted(NULL), Done(NULL), Total(NULL), Command(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__DFUJob() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ActiveWorkunit
#define SOAP_TYPE_ns4__ActiveWorkunit (155)
/* ns4:ActiveWorkunit */
class SOAP_CMAC ns4__ActiveWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	int *StateID;	/* optional element of type xsd:int */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *Server;	/* optional element of type xsd:string */
	std::wstring *Instance;	/* optional element of type xsd:string */
	std::wstring *Priority;	/* optional element of type xsd:string */
	std::wstring *Extra;	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	std::wstring *Duration;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	int *MemoryBlocked;	/* optional element of type xsd:int */
	bool IsPausing;	/* optional element of type xsd:boolean */
	std::wstring *Warning;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *ClusterQueueName;	/* optional element of type xsd:string */
	std::wstring *TargetClusterName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE_ns4__ActiveWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ActiveWorkunit() : Wuid(NULL), State(NULL), StateID(NULL), Owner(NULL), Jobname(NULL), Server(NULL), Instance(NULL), Priority(NULL), Extra(NULL), GraphName(NULL), Duration(NULL), GID(NULL), QueueName(NULL), MemoryBlocked(NULL), IsPausing((bool)0), Warning(NULL), ClusterName(NULL), ClusterType(NULL), ClusterQueueName(NULL), TargetClusterName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ActiveWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ServerJobQueue
#define SOAP_TYPE_ns4__ServerJobQueue (156)
/* ns4:ServerJobQueue */
class SOAP_CMAC ns4__ServerJobQueue
{
public:
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *ServerName;	/* optional element of type xsd:string */
	std::wstring *ServerType;	/* optional element of type xsd:string */
	std::wstring *QueueStatus;	/* optional element of type xsd:string */
	std::wstring *StatusDetails;	/* optional element of type xsd:string */
	std::wstring *NetworkAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 156; } /* = unique id SOAP_TYPE_ns4__ServerJobQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ServerJobQueue() : QueueName(NULL), ServerName(NULL), ServerType(NULL), QueueStatus(NULL), StatusDetails(NULL), NetworkAddress(NULL), Port(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ServerJobQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfActiveWorkunit
#define SOAP_TYPE_ns4__ArrayOfActiveWorkunit (157)
/* ns4:ArrayOfActiveWorkunit */
class SOAP_CMAC ns4__ArrayOfActiveWorkunit
{
public:
	std::vector<ns4__ActiveWorkunit * >ActiveWorkunit;	/* optional element of type ns4:ActiveWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 157; } /* = unique id SOAP_TYPE_ns4__ArrayOfActiveWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfActiveWorkunit() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfActiveWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfDFUJob
#define SOAP_TYPE_ns4__ArrayOfDFUJob (158)
/* ns4:ArrayOfDFUJob */
class SOAP_CMAC ns4__ArrayOfDFUJob
{
public:
	std::vector<ns4__DFUJob * >DFUJob;	/* optional element of type ns4:DFUJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE_ns4__ArrayOfDFUJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfDFUJob() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfDFUJob() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfServerJobQueue
#define SOAP_TYPE_ns4__ArrayOfServerJobQueue (159)
/* ns4:ArrayOfServerJobQueue */
class SOAP_CMAC ns4__ArrayOfServerJobQueue
{
public:
	std::vector<ns4__ServerJobQueue * >ServerJobQueue;	/* optional element of type ns4:ServerJobQueue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE_ns4__ArrayOfServerJobQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfServerJobQueue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfServerJobQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfTargetCluster
#define SOAP_TYPE_ns4__ArrayOfTargetCluster (160)
/* ns4:ArrayOfTargetCluster */
class SOAP_CMAC ns4__ArrayOfTargetCluster
{
public:
	std::vector<ns4__TargetCluster * >TargetCluster;	/* optional element of type ns4:TargetCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 160; } /* = unique id SOAP_TYPE_ns4__ArrayOfTargetCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfTargetCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfTargetCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__HPCCResourceRepository
#define SOAP_TYPE_ns4__HPCCResourceRepository (161)
/* ns4:HPCCResourceRepository */
class SOAP_CMAC ns4__HPCCResourceRepository
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	class ns4__ArrayOfHPCCResource *HPCCResources;	/* optional element of type ns4:ArrayOfHPCCResource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE_ns4__HPCCResourceRepository */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__HPCCResourceRepository() : Name(NULL), Path(NULL), HPCCResources(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__HPCCResourceRepository() { }
};
#endif

#ifndef SOAP_TYPE_ns4__HPCCResource
#define SOAP_TYPE_ns4__HPCCResource (162)
/* ns4:HPCCResource */
class SOAP_CMAC ns4__HPCCResource
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *Version;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 162; } /* = unique id SOAP_TYPE_ns4__HPCCResource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__HPCCResource() : Name(NULL), Description(NULL), FileName(NULL), Version(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__HPCCResource() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfHPCCResource
#define SOAP_TYPE_ns4__ArrayOfHPCCResource (163)
/* ns4:ArrayOfHPCCResource */
class SOAP_CMAC ns4__ArrayOfHPCCResource
{
public:
	std::vector<ns4__HPCCResource * >HPCCResource;	/* optional element of type ns4:HPCCResource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE_ns4__ArrayOfHPCCResource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfHPCCResource() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfHPCCResource() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfHPCCResourceRepository
#define SOAP_TYPE_ns4__ArrayOfHPCCResourceRepository (164)
/* ns4:ArrayOfHPCCResourceRepository */
class SOAP_CMAC ns4__ArrayOfHPCCResourceRepository
{
public:
	std::vector<ns4__HPCCResourceRepository * >HPCCResourceRepository;	/* optional element of type ns4:HPCCResourceRepository */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE_ns4__ArrayOfHPCCResourceRepository */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfHPCCResourceRepository() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfHPCCResourceRepository() { }
};
#endif

#ifndef SOAP_TYPE_ns4__StatusServerInfo
#define SOAP_TYPE_ns4__StatusServerInfo (165)
/* ns4:StatusServerInfo */
class SOAP_CMAC ns4__StatusServerInfo
{
public:
	ns4__TargetCluster *TargetClusterInfo;	/* optional element of type ns4:TargetCluster */
	ns4__ServerJobQueue *ServerInfo;	/* optional element of type ns4:ServerJobQueue */
	ns4__ArrayOfActiveWorkunit *Workunits;	/* optional element of type ns4:ArrayOfActiveWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 165; } /* = unique id SOAP_TYPE_ns4__StatusServerInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__StatusServerInfo() : TargetClusterInfo(NULL), ServerInfo(NULL), Workunits(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__StatusServerInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ThorCluster
#define SOAP_TYPE_ns4__ThorCluster (166)
/* ns4:ThorCluster */
class SOAP_CMAC ns4__ThorCluster
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *QueueStatus;	/* optional element of type xsd:string */
	int *QueueAvailable;	/* optional element of type xsd:int */
	int *JobsRunning;	/* optional element of type xsd:int */
	int *JobsInQueue;	/* optional element of type xsd:int */
	int *QueueStatus2;	/* optional element of type xsd:int */
	std::wstring *ThorLCR;	/* optional element of type xsd:string */
	int *ClusterSize;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique id SOAP_TYPE_ns4__ThorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ThorCluster() : ClusterName(NULL), QueueName(NULL), QueueStatus(NULL), QueueAvailable(NULL), JobsRunning(NULL), JobsInQueue(NULL), QueueStatus2(NULL), ThorLCR(NULL), ClusterSize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ThorCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfThorCluster
#define SOAP_TYPE_ns4__ArrayOfThorCluster (167)
/* ns4:ArrayOfThorCluster */
class SOAP_CMAC ns4__ArrayOfThorCluster
{
public:
	std::vector<ns4__ThorCluster * >ThorCluster;	/* optional element of type ns4:ThorCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE_ns4__ArrayOfThorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfThorCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfThorCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Lock
#define SOAP_TYPE_ns4__Lock (168)
/* ns4:Lock */
class SOAP_CMAC ns4__Lock
{
public:
	std::wstring *EPIP;	/* optional element of type xsd:string */
	std::wstring *XPath;	/* optional element of type xsd:string */
	std::wstring *LogicalFile;	/* optional element of type xsd:string */
	LONG64 *SessionID;	/* optional element of type xsd:long */
	unsigned int *DurationMS;	/* optional element of type xsd:unsignedInt */
	std::wstring *TimeLocked;	/* optional element of type xsd:string */
	std::wstring *Modes;	/* optional element of type xsd:string */
	class ns4__EspStringArray *ModeNames;	/* optional element of type ns4:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE_ns4__Lock */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Lock() : EPIP(NULL), XPath(NULL), LogicalFile(NULL), SessionID(NULL), DurationMS(NULL), TimeLocked(NULL), Modes(NULL), ModeNames(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__Lock() { }
};
#endif

#ifndef SOAP_TYPE_ns4__EspStringArray
#define SOAP_TYPE_ns4__EspStringArray (169)
/* ns4:EspStringArray */
class SOAP_CMAC ns4__EspStringArray
{
public:
	std::vector<std::wstring * >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE_ns4__EspStringArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__EspStringArray() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__EspStringArray() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfLock
#define SOAP_TYPE_ns4__ArrayOfLock (170)
/* ns4:ArrayOfLock */
class SOAP_CMAC ns4__ArrayOfLock
{
public:
	std::vector<ns4__Lock * >Lock;	/* optional element of type ns4:Lock */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE_ns4__ArrayOfLock */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfLock() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfLock() { }
};
#endif

#ifndef SOAP_TYPE_ns4__RoxieControlEndpointInfo
#define SOAP_TYPE_ns4__RoxieControlEndpointInfo (171)
/* ns4:RoxieControlEndpointInfo */
class SOAP_CMAC ns4__RoxieControlEndpointInfo
{
public:
	std::wstring *Address;	/* optional element of type xsd:string */
	bool *Attached;	/* optional element of type xsd:boolean */
	std::wstring *StateHash;	/* optional element of type xsd:string */
	std::wstring *Status;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique id SOAP_TYPE_ns4__RoxieControlEndpointInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RoxieControlEndpointInfo() : Address(NULL), Attached(NULL), StateHash(NULL), Status(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__RoxieControlEndpointInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns4__SMCJob
#define SOAP_TYPE_ns4__SMCJob (172)
/* ns4:SMCJob */
class SOAP_CMAC ns4__SMCJob
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE_ns4__SMCJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__SMCJob() : Wuid(NULL), QueueName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__SMCJob() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfSMCJob
#define SOAP_TYPE_ns4__ArrayOfSMCJob (173)
/* ns4:ArrayOfSMCJob */
class SOAP_CMAC ns4__ArrayOfSMCJob
{
public:
	std::vector<ns4__SMCJob * >SMCJob;	/* optional element of type ns4:SMCJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique id SOAP_TYPE_ns4__ArrayOfSMCJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfSMCJob() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfSMCJob() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Activity
#define SOAP_TYPE__ns4__Activity (174)
/* ns4:Activity */
class SOAP_CMAC _ns4__Activity
{
public:
	std::wstring *ChatURL;	/* optional element of type xsd:string */
	std::wstring *BannerContent;	/* optional element of type xsd:string */
	std::wstring *BannerColor;	/* optional element of type xsd:string */
	std::wstring *BannerSize;	/* optional element of type xsd:string */
	std::wstring *BannerScroll;	/* optional element of type xsd:string */
	int *BannerAction;	/* optional element of type xsd:int */
	bool *EnableChatURL;	/* optional element of type xsd:boolean */
	bool FromSubmitBtn;	/* optional element of type xsd:boolean */
	std::wstring *SortBy;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE__ns4__Activity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Activity() : ChatURL(NULL), BannerContent(NULL), BannerColor(NULL), BannerSize(NULL), BannerScroll(NULL), BannerAction(NULL), EnableChatURL(NULL), FromSubmitBtn((bool)0), SortBy(NULL), Descending((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__Activity() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ActivityResponse
#define SOAP_TYPE__ns4__ActivityResponse (175)
/* ns4:ActivityResponse */
class SOAP_CMAC _ns4__ActivityResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	std::wstring *Build;	/* optional element of type xsd:string */
	ns4__ArrayOfTargetCluster *ThorClusterList;	/* optional element of type ns4:ArrayOfTargetCluster */
	ns4__ArrayOfTargetCluster *RoxieClusterList;	/* optional element of type ns4:ArrayOfTargetCluster */
	ns4__ArrayOfTargetCluster *HThorClusterList;	/* optional element of type ns4:ArrayOfTargetCluster */
	ns4__ArrayOfDFUJob *DFUJobs;	/* optional element of type ns4:ArrayOfDFUJob */
	ns4__ArrayOfActiveWorkunit *Running;	/* optional element of type ns4:ArrayOfActiveWorkunit */
	std::wstring *BannerContent;	/* optional element of type xsd:string */
	std::wstring *BannerColor;	/* optional element of type xsd:string */
	std::wstring *BannerSize;	/* optional element of type xsd:string */
	std::wstring *BannerScroll;	/* optional element of type xsd:string */
	std::wstring *ChatURL;	/* optional element of type xsd:string */
	int *ShowBanner;	/* optional element of type xsd:int */
	int *ShowChatURL;	/* optional element of type xsd:int */
	std::wstring *SortBy;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	bool SuperUser;	/* optional element of type xsd:boolean */
	std::wstring *AccessRight;	/* optional element of type xsd:string */
	ns4__ArrayOfServerJobQueue *ServerJobQueues;	/* optional element of type ns4:ArrayOfServerJobQueue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE__ns4__ActivityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ActivityResponse() : Exceptions(NULL), Build(NULL), ThorClusterList(NULL), RoxieClusterList(NULL), HThorClusterList(NULL), DFUJobs(NULL), Running(NULL), BannerContent(NULL), BannerColor(NULL), BannerSize(NULL), BannerScroll(NULL), ChatURL(NULL), ShowBanner(NULL), ShowChatURL(NULL), SortBy(NULL), Descending((bool)0), SuperUser((bool)0), AccessRight(NULL), ServerJobQueues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__ActivityResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__BrowseResources
#define SOAP_TYPE__ns4__BrowseResources (176)
/* ns4:BrowseResources */
class SOAP_CMAC _ns4__BrowseResources
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE__ns4__BrowseResources */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__BrowseResources() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__BrowseResources() { }
};
#endif

#ifndef SOAP_TYPE__ns4__BrowseResourcesResponse
#define SOAP_TYPE__ns4__BrowseResourcesResponse (177)
/* ns4:BrowseResourcesResponse */
class SOAP_CMAC _ns4__BrowseResourcesResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	std::wstring *PortalURL;	/* optional element of type xsd:string */
	std::wstring *NetAddress;	/* optional element of type xsd:string */
	int *OS;	/* optional element of type xsd:int */
	bool *UseResource;	/* optional element of type xsd:boolean */
	ns4__ArrayOfHPCCResourceRepository *HPCCResourceRepositories;	/* optional element of type ns4:ArrayOfHPCCResourceRepository */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique id SOAP_TYPE__ns4__BrowseResourcesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__BrowseResourcesResponse() : Exceptions(NULL), PortalURL(NULL), NetAddress(NULL), OS(NULL), UseResource(NULL), HPCCResourceRepositories(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__BrowseResourcesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ClearQueue
#define SOAP_TYPE__ns4__ClearQueue (178)
/* ns4:ClearQueue */
class SOAP_CMAC _ns4__ClearQueue
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	std::wstring *ServerType;	/* optional element of type xsd:string */
	std::wstring *NetworkAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE__ns4__ClearQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ClearQueue() : Cluster(NULL), QueueName(NULL), Comment(NULL), ServerType(NULL), NetworkAddress(NULL), Port(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__ClearQueue() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCQueueResponse
#define SOAP_TYPE__ns4__SMCQueueResponse (179)
/* ns4:SMCQueueResponse */
class SOAP_CMAC _ns4__SMCQueueResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	ns4__StatusServerInfo *StatusServerInfo;	/* optional element of type ns4:StatusServerInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE__ns4__SMCQueueResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCQueueResponse() : Exceptions(NULL), StatusServerInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCQueueResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__GetStatusServerInfo
#define SOAP_TYPE__ns4__GetStatusServerInfo (180)
/* ns4:GetStatusServerInfo */
class SOAP_CMAC _ns4__GetStatusServerInfo
{
public:
	std::wstring *ServerName;	/* optional element of type xsd:string */
	std::wstring *ServerType;	/* optional element of type xsd:string */
	std::wstring *NetworkAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique id SOAP_TYPE__ns4__GetStatusServerInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetStatusServerInfo() : ServerName(NULL), ServerType(NULL), NetworkAddress(NULL), Port(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__GetStatusServerInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns4__GetStatusServerInfoResponse
#define SOAP_TYPE__ns4__GetStatusServerInfoResponse (181)
/* ns4:GetStatusServerInfoResponse */
class SOAP_CMAC _ns4__GetStatusServerInfoResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	ns4__StatusServerInfo *StatusServerInfo;	/* optional element of type ns4:StatusServerInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 181; } /* = unique id SOAP_TYPE__ns4__GetStatusServerInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetStatusServerInfoResponse() : Exceptions(NULL), StatusServerInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__GetStatusServerInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__GetThorQueueAvailability
#define SOAP_TYPE__ns4__GetThorQueueAvailability (182)
/* ns4:GetThorQueueAvailability */
class SOAP_CMAC _ns4__GetThorQueueAvailability
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE__ns4__GetThorQueueAvailability */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetThorQueueAvailability() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__GetThorQueueAvailability() { }
};
#endif

#ifndef SOAP_TYPE__ns4__GetThorQueueAvailabilityResponse
#define SOAP_TYPE__ns4__GetThorQueueAvailabilityResponse (183)
/* ns4:GetThorQueueAvailabilityResponse */
class SOAP_CMAC _ns4__GetThorQueueAvailabilityResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	ns4__ArrayOfThorCluster *ThorClusters;	/* optional element of type ns4:ArrayOfThorCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique id SOAP_TYPE__ns4__GetThorQueueAvailabilityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetThorQueueAvailabilityResponse() : Exceptions(NULL), ThorClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__GetThorQueueAvailabilityResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Index
#define SOAP_TYPE__ns4__Index (184)
/* ns4:Index */
class SOAP_CMAC _ns4__Index
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique id SOAP_TYPE__ns4__Index */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Index() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__Index() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCIndexResponse
#define SOAP_TYPE__ns4__SMCIndexResponse (185)
/* ns4:SMCIndexResponse */
class SOAP_CMAC _ns4__SMCIndexResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique id SOAP_TYPE__ns4__SMCIndexResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCIndexResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCIndexResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__LockQuery
#define SOAP_TYPE__ns4__LockQuery (186)
/* ns4:LockQuery */
class SOAP_CMAC _ns4__LockQuery
{
public:
	std::wstring *EPIP;	/* optional element of type xsd:string */
	std::wstring *XPath;	/* optional element of type xsd:string */
	unsigned int *DurationMSLow;	/* optional element of type xsd:unsignedInt */
	unsigned int *DurationMSHigh;	/* optional element of type xsd:unsignedInt */
	std::wstring *TimeLockedLow;	/* optional element of type xsd:string */
	std::wstring *TimeLockedHigh;	/* optional element of type xsd:string */
	enum ns4__LockModes *Mode;	/* optional element of type ns4:LockModes */
	bool AllFileLocks;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 186; } /* = unique id SOAP_TYPE__ns4__LockQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__LockQuery() : EPIP(NULL), XPath(NULL), DurationMSLow(NULL), DurationMSHigh(NULL), TimeLockedLow(NULL), TimeLockedHigh(NULL), Mode(NULL), AllFileLocks((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__LockQuery() { }
};
#endif

#ifndef SOAP_TYPE__ns4__LockQueryResponse
#define SOAP_TYPE__ns4__LockQueryResponse (187)
/* ns4:LockQueryResponse */
class SOAP_CMAC _ns4__LockQueryResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	ns4__ArrayOfLock *Locks;	/* optional element of type ns4:ArrayOfLock */
	int *NumLocks;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 187; } /* = unique id SOAP_TYPE__ns4__LockQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__LockQueryResponse() : Exceptions(NULL), Locks(NULL), NumLocks(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__LockQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobBack
#define SOAP_TYPE__ns4__MoveJobBack (188)
/* ns4:MoveJobBack */
class SOAP_CMAC _ns4__MoveJobBack
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 188; } /* = unique id SOAP_TYPE__ns4__MoveJobBack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobBack() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobBack() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCJobResponse
#define SOAP_TYPE__ns4__SMCJobResponse (189)
/* ns4:SMCJobResponse */
class SOAP_CMAC _ns4__SMCJobResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 189; } /* = unique id SOAP_TYPE__ns4__SMCJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCJobResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobDown
#define SOAP_TYPE__ns4__MoveJobDown (190)
/* ns4:MoveJobDown */
class SOAP_CMAC _ns4__MoveJobDown
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 190; } /* = unique id SOAP_TYPE__ns4__MoveJobDown */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobDown() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobDown() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobFront
#define SOAP_TYPE__ns4__MoveJobFront (191)
/* ns4:MoveJobFront */
class SOAP_CMAC _ns4__MoveJobFront
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 191; } /* = unique id SOAP_TYPE__ns4__MoveJobFront */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobFront() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobFront() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobUp
#define SOAP_TYPE__ns4__MoveJobUp (192)
/* ns4:MoveJobUp */
class SOAP_CMAC _ns4__MoveJobUp
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 192; } /* = unique id SOAP_TYPE__ns4__MoveJobUp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobUp() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobUp() { }
};
#endif

#ifndef SOAP_TYPE__ns4__NotInCommunityEdition
#define SOAP_TYPE__ns4__NotInCommunityEdition (193)
/* ns4:NotInCommunityEdition */
class SOAP_CMAC _ns4__NotInCommunityEdition
{
public:
	std::wstring *EEPortal;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 193; } /* = unique id SOAP_TYPE__ns4__NotInCommunityEdition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__NotInCommunityEdition() : EEPortal(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__NotInCommunityEdition() { }
};
#endif

#ifndef SOAP_TYPE__ns4__NotInCommunityEditionResponse
#define SOAP_TYPE__ns4__NotInCommunityEditionResponse (194)
/* ns4:NotInCommunityEditionResponse */
class SOAP_CMAC _ns4__NotInCommunityEditionResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 194; } /* = unique id SOAP_TYPE__ns4__NotInCommunityEditionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__NotInCommunityEditionResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__NotInCommunityEditionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__PauseQueue
#define SOAP_TYPE__ns4__PauseQueue (195)
/* ns4:PauseQueue */
class SOAP_CMAC _ns4__PauseQueue
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	std::wstring *ServerType;	/* optional element of type xsd:string */
	std::wstring *NetworkAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE__ns4__PauseQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__PauseQueue() : Cluster(NULL), QueueName(NULL), Comment(NULL), ServerType(NULL), NetworkAddress(NULL), Port(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__PauseQueue() { }
};
#endif

#ifndef SOAP_TYPE__ns4__RemoveJob
#define SOAP_TYPE__ns4__RemoveJob (196)
/* ns4:RemoveJob */
class SOAP_CMAC _ns4__RemoveJob
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 196; } /* = unique id SOAP_TYPE__ns4__RemoveJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__RemoveJob() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__RemoveJob() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ResumeQueue
#define SOAP_TYPE__ns4__ResumeQueue (197)
/* ns4:ResumeQueue */
class SOAP_CMAC _ns4__ResumeQueue
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	std::wstring *ServerType;	/* optional element of type xsd:string */
	std::wstring *NetworkAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 197; } /* = unique id SOAP_TYPE__ns4__ResumeQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ResumeQueue() : Cluster(NULL), QueueName(NULL), Comment(NULL), ServerType(NULL), NetworkAddress(NULL), Port(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__ResumeQueue() { }
};
#endif

#ifndef SOAP_TYPE__ns4__RoxieControlCmd
#define SOAP_TYPE__ns4__RoxieControlCmd (198)
/* ns4:RoxieControlCmd */
class SOAP_CMAC _ns4__RoxieControlCmd
{
public:
	std::wstring *ProcessCluster;	/* optional element of type xsd:string */
	std::wstring *Command;	/* optional element of type xsd:string */
	int *Wait;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 198; } /* = unique id SOAP_TYPE__ns4__RoxieControlCmd */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__RoxieControlCmd() : ProcessCluster(NULL), Command(NULL), Wait(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__RoxieControlCmd() { }
};
#endif

#ifndef SOAP_TYPE__ns4__RoxieControlCmdResponse_Endpoints
#define SOAP_TYPE__ns4__RoxieControlCmdResponse_Endpoints (643)
/* ns4:RoxieControlCmdResponse-Endpoints */
class SOAP_CMAC _ns4__RoxieControlCmdResponse_Endpoints
{
public:
	std::vector<ns4__RoxieControlEndpointInfo * >Endpoint;	/* optional element of type ns4:RoxieControlEndpointInfo */
public:
	virtual int soap_type() const { return 643; } /* = unique id SOAP_TYPE__ns4__RoxieControlCmdResponse_Endpoints */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__RoxieControlCmdResponse_Endpoints()  { this->soap_default(NULL); }
	virtual ~_ns4__RoxieControlCmdResponse_Endpoints() { }
};
#endif

#ifndef SOAP_TYPE__ns4__RoxieControlCmdResponse
#define SOAP_TYPE__ns4__RoxieControlCmdResponse (199)
/* ns4:RoxieControlCmdResponse */
class SOAP_CMAC _ns4__RoxieControlCmdResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	_ns4__RoxieControlCmdResponse_Endpoints *Endpoints;	/* optional element of type ns4:RoxieControlCmdResponse-Endpoints */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE__ns4__RoxieControlCmdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__RoxieControlCmdResponse() : Exceptions(NULL), Endpoints(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__RoxieControlCmdResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SetBanner
#define SOAP_TYPE__ns4__SetBanner (200)
/* ns4:SetBanner */
class SOAP_CMAC _ns4__SetBanner
{
public:
	std::wstring *ChatURL;	/* optional element of type xsd:string */
	std::wstring *BannerContent;	/* optional element of type xsd:string */
	std::wstring *BannerColor;	/* optional element of type xsd:string */
	std::wstring *BannerSize;	/* optional element of type xsd:string */
	std::wstring *BannerScroll;	/* optional element of type xsd:string */
	int *BannerAction;	/* optional element of type xsd:int */
	bool *EnableChatURL;	/* optional element of type xsd:boolean */
	bool FromSubmitBtn;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 200; } /* = unique id SOAP_TYPE__ns4__SetBanner */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetBanner() : ChatURL(NULL), BannerContent(NULL), BannerColor(NULL), BannerSize(NULL), BannerScroll(NULL), BannerAction(NULL), EnableChatURL(NULL), FromSubmitBtn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SetBanner() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SetBannerResponse
#define SOAP_TYPE__ns4__SetBannerResponse (201)
/* ns4:SetBannerResponse */
class SOAP_CMAC _ns4__SetBannerResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 201; } /* = unique id SOAP_TYPE__ns4__SetBannerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetBannerResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SetBannerResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SetJobPriority
#define SOAP_TYPE__ns4__SetJobPriority (202)
/* ns4:SetJobPriority */
class SOAP_CMAC _ns4__SetJobPriority
{
public:
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Priority;	/* optional element of type xsd:string */
	ns4__ArrayOfSMCJob *SMCJobs;	/* optional element of type ns4:ArrayOfSMCJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 202; } /* = unique id SOAP_TYPE__ns4__SetJobPriority */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetJobPriority() : QueueName(NULL), Wuid(NULL), Priority(NULL), SMCJobs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SetJobPriority() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCPriorityResponse
#define SOAP_TYPE__ns4__SMCPriorityResponse (203)
/* ns4:SMCPriorityResponse */
class SOAP_CMAC _ns4__SMCPriorityResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 203; } /* = unique id SOAP_TYPE__ns4__SMCPriorityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCPriorityResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCPriorityResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__StopQueue
#define SOAP_TYPE__ns4__StopQueue (204)
/* ns4:StopQueue */
class SOAP_CMAC _ns4__StopQueue
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	std::wstring *ServerType;	/* optional element of type xsd:string */
	std::wstring *NetworkAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 204; } /* = unique id SOAP_TYPE__ns4__StopQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__StopQueue() : Cluster(NULL), QueueName(NULL), Comment(NULL), ServerType(NULL), NetworkAddress(NULL), Port(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__StopQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns5__EspException
#define SOAP_TYPE_ns5__EspException (205)
/* ns5:EspException */
class SOAP_CMAC ns5__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 205; } /* = unique id SOAP_TYPE_ns5__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfEspException
#define SOAP_TYPE_ns5__ArrayOfEspException (206)
/* ns5:ArrayOfEspException */
class SOAP_CMAC ns5__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns5__EspException * >Exception;	/* optional element of type ns5:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 206; } /* = unique id SOAP_TYPE_ns5__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpTargetCluster
#define SOAP_TYPE_ns5__TpTargetCluster (207)
/* ns5:TpTargetCluster */
class SOAP_CMAC ns5__TpTargetCluster
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	class ns5__ArrayOfTpCluster *TpClusters;	/* optional element of type ns5:ArrayOfTpCluster */
	class ns5__ArrayOfTpEclServer *TpEclCCServers;	/* optional element of type ns5:ArrayOfTpEclServer */
	ns5__ArrayOfTpEclServer *TpEclServers;	/* optional element of type ns5:ArrayOfTpEclServer */
	class ns5__ArrayOfTpEclAgent *TpEclAgents;	/* optional element of type ns5:ArrayOfTpEclAgent */
	class ns5__ArrayOfTpEclScheduler *TpEclSchedulers;	/* optional element of type ns5:ArrayOfTpEclScheduler */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 207; } /* = unique id SOAP_TYPE_ns5__TpTargetCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpTargetCluster() : Name(NULL), Prefix(NULL), Type(NULL), TpClusters(NULL), TpEclCCServers(NULL), TpEclServers(NULL), TpEclAgents(NULL), TpEclSchedulers(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpTargetCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpCluster
#define SOAP_TYPE_ns5__TpCluster (208)
/* ns5:TpCluster */
class SOAP_CMAC ns5__TpCluster
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Desc;	/* optional element of type xsd:string */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *DataModel;	/* optional element of type xsd:string */
	int *OS;	/* optional element of type xsd:int */
	bool *HasThorSpareProcess;	/* optional element of type xsd:boolean */
	class ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 208; } /* = unique id SOAP_TYPE_ns5__TpCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpCluster() : Type(NULL), Name(NULL), QueueName(NULL), Build(NULL), Directory(NULL), LogDirectory(NULL), Desc(NULL), Prefix(NULL), Path(NULL), DataModel(NULL), OS(NULL), HasThorSpareProcess(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpMachine
#define SOAP_TYPE_ns5__TpMachine (209)
/* ns5:TpMachine */
class SOAP_CMAC ns5__TpMachine
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Netaddress;	/* optional element of type xsd:string */
	std::wstring *ConfigNetaddress;	/* optional element of type xsd:string */
	std::wstring *Domain;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Available;	/* optional element of type xsd:string */
	int *OS;	/* optional element of type xsd:int */
	std::wstring *Path;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	int *ProcessNumber;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 209; } /* = unique id SOAP_TYPE_ns5__TpMachine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpMachine() : Name(NULL), Netaddress(NULL), ConfigNetaddress(NULL), Domain(NULL), Directory(NULL), Type(NULL), Available(NULL), OS(NULL), Path(NULL), Port(NULL), ProcessNumber(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpMachine() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpMachine
#define SOAP_TYPE_ns5__ArrayOfTpMachine (210)
/* ns5:ArrayOfTpMachine */
class SOAP_CMAC ns5__ArrayOfTpMachine
{
public:
	std::vector<ns5__TpMachine * >TpMachine;	/* optional element of type ns5:TpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 210; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpMachine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpMachine() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpMachine() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEclServer
#define SOAP_TYPE_ns5__TpEclServer (211)
/* ns5:TpEclServer */
class SOAP_CMAC ns5__TpEclServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 211; } /* = unique id SOAP_TYPE_ns5__TpEclServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEclServer() : Name(NULL), Description(NULL), Build(NULL), LogDirectory(NULL), Type(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEclServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEclAgent
#define SOAP_TYPE_ns5__TpEclAgent (212)
/* ns5:TpEclAgent */
class SOAP_CMAC ns5__TpEclAgent
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *DaliServer;	/* optional element of type xsd:string */
	std::wstring *LogDir;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 212; } /* = unique id SOAP_TYPE_ns5__TpEclAgent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEclAgent() : Name(NULL), Description(NULL), Build(NULL), Type(NULL), Path(NULL), DaliServer(NULL), LogDir(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEclAgent() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEclScheduler
#define SOAP_TYPE_ns5__TpEclScheduler (213)
/* ns5:TpEclScheduler */
class SOAP_CMAC ns5__TpEclScheduler
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 213; } /* = unique id SOAP_TYPE_ns5__TpEclScheduler */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEclScheduler() : Name(NULL), Description(NULL), Build(NULL), LogDirectory(NULL), Type(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEclScheduler() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpCluster
#define SOAP_TYPE_ns5__ArrayOfTpCluster (214)
/* ns5:ArrayOfTpCluster */
class SOAP_CMAC ns5__ArrayOfTpCluster
{
public:
	std::vector<ns5__TpCluster * >TpCluster;	/* optional element of type ns5:TpCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 214; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEclAgent
#define SOAP_TYPE_ns5__ArrayOfTpEclAgent (215)
/* ns5:ArrayOfTpEclAgent */
class SOAP_CMAC ns5__ArrayOfTpEclAgent
{
public:
	std::vector<ns5__TpEclAgent * >TpEclAgent;	/* optional element of type ns5:TpEclAgent */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 215; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEclAgent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEclAgent() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEclAgent() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEclScheduler
#define SOAP_TYPE_ns5__ArrayOfTpEclScheduler (216)
/* ns5:ArrayOfTpEclScheduler */
class SOAP_CMAC ns5__ArrayOfTpEclScheduler
{
public:
	std::vector<ns5__TpEclScheduler * >TpEclScheduler;	/* optional element of type ns5:TpEclScheduler */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 216; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEclScheduler */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEclScheduler() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEclScheduler() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEclServer
#define SOAP_TYPE_ns5__ArrayOfTpEclServer (217)
/* ns5:ArrayOfTpEclServer */
class SOAP_CMAC ns5__ArrayOfTpEclServer
{
public:
	std::vector<ns5__TpEclServer * >TpEclServer;	/* optional element of type ns5:TpEclServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 217; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEclServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEclServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEclServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpServices
#define SOAP_TYPE_ns5__TpServices (218)
/* ns5:TpServices */
class SOAP_CMAC ns5__TpServices
{
public:
	class ns5__ArrayOfTpDali *TpDalis;	/* optional element of type ns5:ArrayOfTpDali */
	class ns5__ArrayOfTpDfuServer *TpDfuServers;	/* optional element of type ns5:ArrayOfTpDfuServer */
	class ns5__ArrayOfTpDkcSlave *TpDkcSlaves;	/* optional element of type ns5:ArrayOfTpDkcSlave */
	class ns5__ArrayOfTpDropZone *TpDropZones;	/* optional element of type ns5:ArrayOfTpDropZone */
	ns5__ArrayOfTpEclAgent *TpEclAgents;	/* optional element of type ns5:ArrayOfTpEclAgent */
	ns5__ArrayOfTpEclServer *TpEclServers;	/* optional element of type ns5:ArrayOfTpEclServer */
	ns5__ArrayOfTpEclServer *TpEclCCServers;	/* optional element of type ns5:ArrayOfTpEclServer */
	ns5__ArrayOfTpEclScheduler *TpEclSchedulers;	/* optional element of type ns5:ArrayOfTpEclScheduler */
	class ns5__ArrayOfTpEspServer *TpEspServers;	/* optional element of type ns5:ArrayOfTpEspServer */
	class ns5__ArrayOfTpFTSlave *TpFTSlaves;	/* optional element of type ns5:ArrayOfTpFTSlave */
	class ns5__ArrayOfTpGenesisServer *TpGenesisServers;	/* optional element of type ns5:ArrayOfTpGenesisServer */
	class ns5__ArrayOfTpLdapServer *TpLdapServers;	/* optional element of type ns5:ArrayOfTpLdapServer */
	class ns5__ArrayOfTpMySqlServer *TpMySqlServers;	/* optional element of type ns5:ArrayOfTpMySqlServer */
	class ns5__ArrayOfTpSashaServer *TpSashaServers;	/* optional element of type ns5:ArrayOfTpSashaServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 218; } /* = unique id SOAP_TYPE_ns5__TpServices */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpServices() : TpDalis(NULL), TpDfuServers(NULL), TpDkcSlaves(NULL), TpDropZones(NULL), TpEclAgents(NULL), TpEclServers(NULL), TpEclCCServers(NULL), TpEclSchedulers(NULL), TpEspServers(NULL), TpFTSlaves(NULL), TpGenesisServers(NULL), TpLdapServers(NULL), TpMySqlServers(NULL), TpSashaServers(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpServices() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDali
#define SOAP_TYPE_ns5__TpDali (219)
/* ns5:TpDali */
class SOAP_CMAC ns5__TpDali
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *BackupComputer;	/* optional element of type xsd:string */
	std::wstring *BackupDirectory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 219; } /* = unique id SOAP_TYPE_ns5__TpDali */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDali() : Name(NULL), Description(NULL), Build(NULL), BackupComputer(NULL), BackupDirectory(NULL), Type(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDali() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDfuServer
#define SOAP_TYPE_ns5__TpDfuServer (220)
/* ns5:TpDfuServer */
class SOAP_CMAC ns5__TpDfuServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 220; } /* = unique id SOAP_TYPE_ns5__TpDfuServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDfuServer() : Name(NULL), Description(NULL), Build(NULL), Queue(NULL), Type(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDfuServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDkcSlave
#define SOAP_TYPE_ns5__TpDkcSlave (221)
/* ns5:TpDkcSlave */
class SOAP_CMAC ns5__TpDkcSlave
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 221; } /* = unique id SOAP_TYPE_ns5__TpDkcSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDkcSlave() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDkcSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDropZone
#define SOAP_TYPE_ns5__TpDropZone (222)
/* ns5:TpDropZone */
class SOAP_CMAC ns5__TpDropZone
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	bool *ECLWatchVisible;	/* optional element of type xsd:boolean */
	std::wstring *UMask;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE_ns5__TpDropZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDropZone() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), ECLWatchVisible(NULL), UMask(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDropZone() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEspServer
#define SOAP_TYPE_ns5__TpEspServer (223)
/* ns5:TpEspServer */
class SOAP_CMAC ns5__TpEspServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	class ns5__ArrayOfTpBinding *TpBindings;	/* optional element of type ns5:ArrayOfTpBinding */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 223; } /* = unique id SOAP_TYPE_ns5__TpEspServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEspServer() : Name(NULL), Description(NULL), Build(NULL), Type(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), TpBindings(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEspServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpBinding
#define SOAP_TYPE_ns5__TpBinding (224)
/* ns5:TpBinding */
class SOAP_CMAC ns5__TpBinding
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Service;	/* optional element of type xsd:string */
	std::wstring *ServiceType;	/* optional element of type xsd:string */
	std::wstring *BindingType;	/* optional element of type xsd:string */
	std::wstring *ServiceBuildSet;	/* optional element of type xsd:string */
	std::wstring *Port;	/* optional element of type xsd:string */
	std::wstring *Protocol;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 224; } /* = unique id SOAP_TYPE_ns5__TpBinding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpBinding() : Name(NULL), Service(NULL), ServiceType(NULL), BindingType(NULL), ServiceBuildSet(NULL), Port(NULL), Protocol(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpBinding() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpBinding
#define SOAP_TYPE_ns5__ArrayOfTpBinding (225)
/* ns5:ArrayOfTpBinding */
class SOAP_CMAC ns5__ArrayOfTpBinding
{
public:
	std::vector<ns5__TpBinding * >TpBinding;	/* optional element of type ns5:TpBinding */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 225; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpBinding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpBinding() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpBinding() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpFTSlave
#define SOAP_TYPE_ns5__TpFTSlave (226)
/* ns5:TpFTSlave */
class SOAP_CMAC ns5__TpFTSlave
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 226; } /* = unique id SOAP_TYPE_ns5__TpFTSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpFTSlave() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpFTSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpGenesisServer
#define SOAP_TYPE_ns5__TpGenesisServer (227)
/* ns5:TpGenesisServer */
class SOAP_CMAC ns5__TpGenesisServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 227; } /* = unique id SOAP_TYPE_ns5__TpGenesisServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpGenesisServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpGenesisServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpLdapServer
#define SOAP_TYPE_ns5__TpLdapServer (228)
/* ns5:TpLdapServer */
class SOAP_CMAC ns5__TpLdapServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 228; } /* = unique id SOAP_TYPE_ns5__TpLdapServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpLdapServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpLdapServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpMySqlServer
#define SOAP_TYPE_ns5__TpMySqlServer (229)
/* ns5:TpMySqlServer */
class SOAP_CMAC ns5__TpMySqlServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 229; } /* = unique id SOAP_TYPE_ns5__TpMySqlServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpMySqlServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpMySqlServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpSashaServer
#define SOAP_TYPE_ns5__TpSashaServer (230)
/* ns5:TpSashaServer */
class SOAP_CMAC ns5__TpSashaServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 230; } /* = unique id SOAP_TYPE_ns5__TpSashaServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpSashaServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpSashaServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDali
#define SOAP_TYPE_ns5__ArrayOfTpDali (231)
/* ns5:ArrayOfTpDali */
class SOAP_CMAC ns5__ArrayOfTpDali
{
public:
	std::vector<ns5__TpDali * >TpDali;	/* optional element of type ns5:TpDali */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 231; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDali */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDali() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDali() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDfuServer
#define SOAP_TYPE_ns5__ArrayOfTpDfuServer (232)
/* ns5:ArrayOfTpDfuServer */
class SOAP_CMAC ns5__ArrayOfTpDfuServer
{
public:
	std::vector<ns5__TpDfuServer * >TpDfuServer;	/* optional element of type ns5:TpDfuServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 232; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDfuServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDfuServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDfuServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDkcSlave
#define SOAP_TYPE_ns5__ArrayOfTpDkcSlave (233)
/* ns5:ArrayOfTpDkcSlave */
class SOAP_CMAC ns5__ArrayOfTpDkcSlave
{
public:
	std::vector<ns5__TpDkcSlave * >TpDkcSlave;	/* optional element of type ns5:TpDkcSlave */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 233; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDkcSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDkcSlave() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDkcSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDropZone
#define SOAP_TYPE_ns5__ArrayOfTpDropZone (234)
/* ns5:ArrayOfTpDropZone */
class SOAP_CMAC ns5__ArrayOfTpDropZone
{
public:
	std::vector<ns5__TpDropZone * >TpDropZone;	/* optional element of type ns5:TpDropZone */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 234; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDropZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDropZone() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDropZone() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEspServer
#define SOAP_TYPE_ns5__ArrayOfTpEspServer (235)
/* ns5:ArrayOfTpEspServer */
class SOAP_CMAC ns5__ArrayOfTpEspServer
{
public:
	std::vector<ns5__TpEspServer * >TpEspServer;	/* optional element of type ns5:TpEspServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 235; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEspServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEspServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEspServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpFTSlave
#define SOAP_TYPE_ns5__ArrayOfTpFTSlave (236)
/* ns5:ArrayOfTpFTSlave */
class SOAP_CMAC ns5__ArrayOfTpFTSlave
{
public:
	std::vector<ns5__TpFTSlave * >TpFTSlave;	/* optional element of type ns5:TpFTSlave */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 236; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpFTSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpFTSlave() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpFTSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpGenesisServer
#define SOAP_TYPE_ns5__ArrayOfTpGenesisServer (237)
/* ns5:ArrayOfTpGenesisServer */
class SOAP_CMAC ns5__ArrayOfTpGenesisServer
{
public:
	std::vector<ns5__TpGenesisServer * >TpGenesisServer;	/* optional element of type ns5:TpGenesisServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 237; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpGenesisServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpGenesisServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpGenesisServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpLdapServer
#define SOAP_TYPE_ns5__ArrayOfTpLdapServer (238)
/* ns5:ArrayOfTpLdapServer */
class SOAP_CMAC ns5__ArrayOfTpLdapServer
{
public:
	std::vector<ns5__TpLdapServer * >TpLdapServer;	/* optional element of type ns5:TpLdapServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 238; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpLdapServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpLdapServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpLdapServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpMySqlServer
#define SOAP_TYPE_ns5__ArrayOfTpMySqlServer (239)
/* ns5:ArrayOfTpMySqlServer */
class SOAP_CMAC ns5__ArrayOfTpMySqlServer
{
public:
	std::vector<ns5__TpMySqlServer * >TpMySqlServer;	/* optional element of type ns5:TpMySqlServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 239; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpMySqlServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpMySqlServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpMySqlServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpSashaServer
#define SOAP_TYPE_ns5__ArrayOfTpSashaServer (240)
/* ns5:ArrayOfTpSashaServer */
class SOAP_CMAC ns5__ArrayOfTpSashaServer
{
public:
	std::vector<ns5__TpSashaServer * >TpSashaServer;	/* optional element of type ns5:TpSashaServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 240; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpSashaServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpSashaServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpSashaServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpQueryType
#define SOAP_TYPE_ns5__TpQueryType (241)
/* ns5:TpQueryType */
class SOAP_CMAC ns5__TpQueryType
{
public:
	std::wstring *TPCLUSTER;	/* optional element of type xsd:string */
	std::wstring *TPNODE;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 241; } /* = unique id SOAP_TYPE_ns5__TpQueryType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpQueryType() : TPCLUSTER(NULL), TPNODE(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpQueryType() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpLogicalCluster
#define SOAP_TYPE_ns5__TpLogicalCluster (242)
/* ns5:TpLogicalCluster */
class SOAP_CMAC ns5__TpLogicalCluster
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *LanguageVersion;	/* optional element of type xsd:string */
	std::wstring *Process;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 242; } /* = unique id SOAP_TYPE_ns5__TpLogicalCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpLogicalCluster() : Name(NULL), Queue(NULL), LanguageVersion(NULL), Process(NULL), Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpLogicalCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpGroup
#define SOAP_TYPE_ns5__TpGroup (243)
/* ns5:TpGroup */
class SOAP_CMAC ns5__TpGroup
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Kind;	/* optional element of type xsd:string */
	bool *ReplicateOutputs;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 243; } /* = unique id SOAP_TYPE_ns5__TpGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpGroup() : Name(NULL), Kind(NULL), ReplicateOutputs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpGroup() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpQueue
#define SOAP_TYPE_ns5__TpQueue (244)
/* ns5:TpQueue */
class SOAP_CMAC ns5__TpQueue
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *WorkUnit;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 244; } /* = unique id SOAP_TYPE_ns5__TpQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpQueue() : Name(NULL), WorkUnit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpQueue
#define SOAP_TYPE_ns5__ArrayOfTpQueue (245)
/* ns5:ArrayOfTpQueue */
class SOAP_CMAC ns5__ArrayOfTpQueue
{
public:
	std::vector<ns5__TpQueue * >TpQueue;	/* optional element of type ns5:TpQueue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 245; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpQueue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEspServicePlugin
#define SOAP_TYPE_ns5__TpEspServicePlugin (246)
/* ns5:TpEspServicePlugin */
class SOAP_CMAC ns5__TpEspServicePlugin
{
public:
	std::wstring *ShortName;	/* optional element of type xsd:string */
	std::wstring *LongName;	/* optional element of type xsd:string */
	std::wstring *FolderName;	/* optional element of type xsd:string */
	std::wstring *WidgetName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 246; } /* = unique id SOAP_TYPE_ns5__TpEspServicePlugin */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEspServicePlugin() : ShortName(NULL), LongName(NULL), FolderName(NULL), WidgetName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEspServicePlugin() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpGroup
#define SOAP_TYPE_ns5__ArrayOfTpGroup (247)
/* ns5:ArrayOfTpGroup */
class SOAP_CMAC ns5__ArrayOfTpGroup
{
public:
	std::vector<ns5__TpGroup * >TpGroup;	/* optional element of type ns5:TpGroup */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 247; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpGroup() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpGroup() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpClusterNameType
#define SOAP_TYPE_ns5__TpClusterNameType (248)
/* ns5:TpClusterNameType */
class SOAP_CMAC ns5__TpClusterNameType
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	bool *IsDefault;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 248; } /* = unique id SOAP_TYPE_ns5__TpClusterNameType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpClusterNameType() : Name(NULL), Type(NULL), IsDefault(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpClusterNameType() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpClusterNameType
#define SOAP_TYPE_ns5__ArrayOfTpClusterNameType (249)
/* ns5:ArrayOfTpClusterNameType */
class SOAP_CMAC ns5__ArrayOfTpClusterNameType
{
public:
	std::vector<ns5__TpClusterNameType * >TpClusterNameType;	/* optional element of type ns5:TpClusterNameType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 249; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpClusterNameType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpClusterNameType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpClusterNameType() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpLogicalCluster
#define SOAP_TYPE_ns5__ArrayOfTpLogicalCluster (250)
/* ns5:ArrayOfTpLogicalCluster */
class SOAP_CMAC ns5__ArrayOfTpLogicalCluster
{
public:
	std::vector<ns5__TpLogicalCluster * >TpLogicalCluster;	/* optional element of type ns5:TpLogicalCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 250; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpLogicalCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpLogicalCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpLogicalCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpTargetCluster
#define SOAP_TYPE_ns5__ArrayOfTpTargetCluster (251)
/* ns5:ArrayOfTpTargetCluster */
class SOAP_CMAC ns5__ArrayOfTpTargetCluster
{
public:
	std::vector<ns5__TpTargetCluster * >TpTargetCluster;	/* optional element of type ns5:TpTargetCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 251; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpTargetCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpTargetCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpTargetCluster() { }
};
#endif

#ifndef SOAP_TYPE__ns5__SystemLogRequest
#define SOAP_TYPE__ns5__SystemLogRequest (252)
/* ns5:SystemLogRequest */
class SOAP_CMAC _ns5__SystemLogRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Zip;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE__ns5__SystemLogRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__SystemLogRequest() : Name(NULL), Type(NULL), Zip(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__SystemLogRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__SystemLogResponse
#define SOAP_TYPE__ns5__SystemLogResponse (253)
/* ns5:SystemLogResponse */
class SOAP_CMAC _ns5__SystemLogResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 253; } /* = unique id SOAP_TYPE__ns5__SystemLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__SystemLogResponse() : Exceptions(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__SystemLogResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterInfoRequest
#define SOAP_TYPE__ns5__TpClusterInfoRequest (254)
/* ns5:TpClusterInfoRequest */
class SOAP_CMAC _ns5__TpClusterInfoRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 254; } /* = unique id SOAP_TYPE__ns5__TpClusterInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterInfoRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterInfoResponse
#define SOAP_TYPE__ns5__TpClusterInfoResponse (255)
/* ns5:TpClusterInfoResponse */
class SOAP_CMAC _ns5__TpClusterInfoResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *WorkUnit;	/* optional element of type xsd:string */
	ns5__ArrayOfTpQueue *TpQueues;	/* optional element of type ns5:ArrayOfTpQueue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 255; } /* = unique id SOAP_TYPE__ns5__TpClusterInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterInfoResponse() : Exceptions(NULL), Name(NULL), WorkUnit(NULL), TpQueues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterQueryRequest
#define SOAP_TYPE__ns5__TpClusterQueryRequest (256)
/* ns5:TpClusterQueryRequest */
class SOAP_CMAC _ns5__TpClusterQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 256; } /* = unique id SOAP_TYPE__ns5__TpClusterQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterQueryRequest() : Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterQueryResponse
#define SOAP_TYPE__ns5__TpClusterQueryResponse (257)
/* ns5:TpClusterQueryResponse */
class SOAP_CMAC _ns5__TpClusterQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *EnableSNMP;	/* optional element of type xsd:boolean */
	std::wstring *AcceptLanguage;	/* optional element of type xsd:string */
	ns5__ArrayOfTpCluster *TpClusters;	/* optional element of type ns5:ArrayOfTpCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 257; } /* = unique id SOAP_TYPE__ns5__TpClusterQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterQueryResponse() : Exceptions(NULL), EnableSNMP(NULL), AcceptLanguage(NULL), TpClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpDropZoneQueryRequest
#define SOAP_TYPE__ns5__TpDropZoneQueryRequest (258)
/* ns5:TpDropZoneQueryRequest */
class SOAP_CMAC _ns5__TpDropZoneQueryRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	bool *ECLWatchVisibleOnly;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 258; } /* = unique id SOAP_TYPE__ns5__TpDropZoneQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpDropZoneQueryRequest() : Name(NULL), ECLWatchVisibleOnly(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpDropZoneQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpDropZoneQueryResponse
#define SOAP_TYPE__ns5__TpDropZoneQueryResponse (259)
/* ns5:TpDropZoneQueryResponse */
class SOAP_CMAC _ns5__TpDropZoneQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	ns5__ArrayOfTpDropZone *TpDropZones;	/* optional element of type ns5:ArrayOfTpDropZone */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 259; } /* = unique id SOAP_TYPE__ns5__TpDropZoneQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpDropZoneQueryResponse() : Exceptions(NULL), TpDropZones(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpDropZoneQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGetComponentFileRequest
#define SOAP_TYPE__ns5__TpGetComponentFileRequest (260)
/* ns5:TpGetComponentFileRequest */
class SOAP_CMAC _ns5__TpGetComponentFileRequest
{
public:
	std::wstring *CompType;	/* optional element of type xsd:string */
	std::wstring *CompName;	/* optional element of type xsd:string */
	std::wstring *NetAddress;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *FileType;	/* optional element of type xsd:string */
	int *OsType;	/* optional element of type xsd:int */
	std::wstring *PlainText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 260; } /* = unique id SOAP_TYPE__ns5__TpGetComponentFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGetComponentFileRequest() : CompType(NULL), CompName(NULL), NetAddress(NULL), Directory(NULL), FileType(NULL), OsType(NULL), PlainText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGetComponentFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGetComponentFileResponse
#define SOAP_TYPE__ns5__TpGetComponentFileResponse (261)
/* ns5:TpGetComponentFileResponse */
class SOAP_CMAC _ns5__TpGetComponentFileResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	xsd__base64Binary *FileContents;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 261; } /* = unique id SOAP_TYPE__ns5__TpGetComponentFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGetComponentFileResponse() : Exceptions(NULL), FileContents(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGetComponentFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGetServicePluginsRequest
#define SOAP_TYPE__ns5__TpGetServicePluginsRequest (262)
/* ns5:TpGetServicePluginsRequest */
class SOAP_CMAC _ns5__TpGetServicePluginsRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 262; } /* = unique id SOAP_TYPE__ns5__TpGetServicePluginsRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGetServicePluginsRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGetServicePluginsRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGetServicePluginsResponse_Plugins
#define SOAP_TYPE__ns5__TpGetServicePluginsResponse_Plugins (710)
/* ns5:TpGetServicePluginsResponse-Plugins */
class SOAP_CMAC _ns5__TpGetServicePluginsResponse_Plugins
{
public:
	std::vector<ns5__TpEspServicePlugin * >Plugin;	/* optional element of type ns5:TpEspServicePlugin */
public:
	virtual int soap_type() const { return 710; } /* = unique id SOAP_TYPE__ns5__TpGetServicePluginsResponse_Plugins */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGetServicePluginsResponse_Plugins()  { this->soap_default(NULL); }
	virtual ~_ns5__TpGetServicePluginsResponse_Plugins() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGetServicePluginsResponse
#define SOAP_TYPE__ns5__TpGetServicePluginsResponse (263)
/* ns5:TpGetServicePluginsResponse */
class SOAP_CMAC _ns5__TpGetServicePluginsResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	_ns5__TpGetServicePluginsResponse_Plugins *Plugins;	/* optional element of type ns5:TpGetServicePluginsResponse-Plugins */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 263; } /* = unique id SOAP_TYPE__ns5__TpGetServicePluginsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGetServicePluginsResponse() : Exceptions(NULL), Plugins(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGetServicePluginsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGroupQueryRequest
#define SOAP_TYPE__ns5__TpGroupQueryRequest (264)
/* ns5:TpGroupQueryRequest */
class SOAP_CMAC _ns5__TpGroupQueryRequest
{
public:
	std::wstring *Kind;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 264; } /* = unique id SOAP_TYPE__ns5__TpGroupQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGroupQueryRequest() : Kind(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGroupQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGroupQueryResponse
#define SOAP_TYPE__ns5__TpGroupQueryResponse (265)
/* ns5:TpGroupQueryResponse */
class SOAP_CMAC _ns5__TpGroupQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	ns5__ArrayOfTpGroup *TpGroups;	/* optional element of type ns5:ArrayOfTpGroup */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 265; } /* = unique id SOAP_TYPE__ns5__TpGroupQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGroupQueryResponse() : Exceptions(NULL), TpGroups(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGroupQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpListTargetClustersRequest
#define SOAP_TYPE__ns5__TpListTargetClustersRequest (266)
/* ns5:TpListTargetClustersRequest */
class SOAP_CMAC _ns5__TpListTargetClustersRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 266; } /* = unique id SOAP_TYPE__ns5__TpListTargetClustersRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpListTargetClustersRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpListTargetClustersRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpListTargetClustersResponse
#define SOAP_TYPE__ns5__TpListTargetClustersResponse (267)
/* ns5:TpListTargetClustersResponse */
class SOAP_CMAC _ns5__TpListTargetClustersResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	ns5__ArrayOfTpClusterNameType *TargetClusters;	/* optional element of type ns5:ArrayOfTpClusterNameType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 267; } /* = unique id SOAP_TYPE__ns5__TpListTargetClustersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpListTargetClustersResponse() : Exceptions(NULL), TargetClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpListTargetClustersResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogFileRequest
#define SOAP_TYPE__ns5__TpLogFileRequest (268)
/* ns5:TpLogFileRequest */
class SOAP_CMAC _ns5__TpLogFileRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *LastHours;	/* optional element of type xsd:int */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	int *FirstRows;	/* optional element of type xsd:int */
	int *LastRows;	/* optional element of type xsd:int */
	int *FilterType;	/* optional element of type xsd:int */
	bool Reversely;	/* optional element of type xsd:boolean */
	bool Zip;	/* optional element of type xsd:boolean */
	int *PageNumber;	/* optional element of type xsd:int */
	bool LoadData;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 268; } /* = unique id SOAP_TYPE__ns5__TpLogFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogFileRequest() : Name(NULL), Type(NULL), LastHours(NULL), StartDate(NULL), EndDate(NULL), FirstRows(NULL), LastRows(NULL), FilterType(NULL), Reversely((bool)0), Zip((bool)0), PageNumber(NULL), LoadData((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogFileResponse
#define SOAP_TYPE__ns5__TpLogFileResponse (269)
/* ns5:TpLogFileResponse */
class SOAP_CMAC _ns5__TpLogFileResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	int *LastHours;	/* optional element of type xsd:int */
	int *FirstRows;	/* optional element of type xsd:int */
	int *LastRows;	/* optional element of type xsd:int */
	bool *Reversely;	/* optional element of type xsd:boolean */
	bool *Zip;	/* optional element of type xsd:boolean */
	int *FilterType;	/* optional element of type xsd:int */
	std::wstring *LogData;	/* optional element of type xsd:string */
	bool HasDate;	/* optional element of type xsd:boolean */
	LONG64 *FileSize;	/* optional element of type xsd:long */
	LONG64 *PageFrom;	/* optional element of type xsd:long */
	LONG64 *PageTo;	/* optional element of type xsd:long */
	int *PageNumber;	/* optional element of type xsd:int */
	int PrevPage;	/* optional element of type xsd:int */
	int NextPage;	/* optional element of type xsd:int */
	int *TotalPages;	/* optional element of type xsd:int */
	std::wstring *AcceptLanguage;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 269; } /* = unique id SOAP_TYPE__ns5__TpLogFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogFileResponse() : Exceptions(NULL), Name(NULL), Type(NULL), StartDate(NULL), EndDate(NULL), LastHours(NULL), FirstRows(NULL), LastRows(NULL), Reversely(NULL), Zip(NULL), FilterType(NULL), LogData(NULL), HasDate((bool)0), FileSize(NULL), PageFrom(NULL), PageTo(NULL), PageNumber(NULL), PrevPage(0), NextPage(0), TotalPages(NULL), AcceptLanguage(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogicalClusterQueryRequest
#define SOAP_TYPE__ns5__TpLogicalClusterQueryRequest (270)
/* ns5:TpLogicalClusterQueryRequest */
class SOAP_CMAC _ns5__TpLogicalClusterQueryRequest
{
public:
	std::wstring *EclServerQueue;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 270; } /* = unique id SOAP_TYPE__ns5__TpLogicalClusterQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogicalClusterQueryRequest() : EclServerQueue(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogicalClusterQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogicalClusterQueryResponse
#define SOAP_TYPE__ns5__TpLogicalClusterQueryResponse (271)
/* ns5:TpLogicalClusterQueryResponse */
class SOAP_CMAC _ns5__TpLogicalClusterQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	ns5__ArrayOfTpLogicalCluster *TpLogicalClusters;	/* optional element of type ns5:ArrayOfTpLogicalCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 271; } /* = unique id SOAP_TYPE__ns5__TpLogicalClusterQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogicalClusterQueryResponse() : Exceptions(NULL), TpLogicalClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogicalClusterQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpMachineInfoRequest
#define SOAP_TYPE__ns5__TpMachineInfoRequest (272)
/* ns5:TpMachineInfoRequest */
class SOAP_CMAC _ns5__TpMachineInfoRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *NetAddress;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 272; } /* = unique id SOAP_TYPE__ns5__TpMachineInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpMachineInfoRequest() : Name(NULL), NetAddress(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpMachineInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpMachineInfoResponse
#define SOAP_TYPE__ns5__TpMachineInfoResponse (273)
/* ns5:TpMachineInfoResponse */
class SOAP_CMAC _ns5__TpMachineInfoResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	ns5__TpMachine *MachineInfo;	/* optional element of type ns5:TpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 273; } /* = unique id SOAP_TYPE__ns5__TpMachineInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpMachineInfoResponse() : Exceptions(NULL), MachineInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpMachineInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpMachineQueryRequest
#define SOAP_TYPE__ns5__TpMachineQueryRequest (274)
/* ns5:TpMachineQueryRequest */
class SOAP_CMAC _ns5__TpMachineQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *OldIP;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 274; } /* = unique id SOAP_TYPE__ns5__TpMachineQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpMachineQueryRequest() : Type(NULL), Cluster(NULL), OldIP(NULL), Path(NULL), Directory(NULL), LogDirectory(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpMachineQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpMachineQueryResponse
#define SOAP_TYPE__ns5__TpMachineQueryResponse (275)
/* ns5:TpMachineQueryResponse */
class SOAP_CMAC _ns5__TpMachineQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *EnablePreflightInfo;	/* optional element of type xsd:boolean */
	bool *HasThorSpareProcess;	/* optional element of type xsd:boolean */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *OldIP;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	int *MemThreshold;	/* optional element of type xsd:int */
	int *DiskThreshold;	/* optional element of type xsd:int */
	int *CpuThreshold;	/* optional element of type xsd:int */
	std::wstring *MemThresholdType;	/* optional element of type xsd:string */
	std::wstring *DiskThresholdType;	/* optional element of type xsd:string */
	std::wstring *PreflightProcessFilter;	/* optional element of type xsd:string */
	bool *EnableSNMP;	/* optional element of type xsd:boolean */
	std::wstring *AcceptLanguage;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 275; } /* = unique id SOAP_TYPE__ns5__TpMachineQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpMachineQueryResponse() : Exceptions(NULL), EnablePreflightInfo(NULL), HasThorSpareProcess(NULL), Type(NULL), Cluster(NULL), OldIP(NULL), LogDirectory(NULL), Path(NULL), MemThreshold(NULL), DiskThreshold(NULL), CpuThreshold(NULL), MemThresholdType(NULL), DiskThresholdType(NULL), PreflightProcessFilter(NULL), EnableSNMP(NULL), AcceptLanguage(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpMachineQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpServiceQueryRequest
#define SOAP_TYPE__ns5__TpServiceQueryRequest (276)
/* ns5:TpServiceQueryRequest */
class SOAP_CMAC _ns5__TpServiceQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 276; } /* = unique id SOAP_TYPE__ns5__TpServiceQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpServiceQueryRequest() : Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpServiceQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpServiceQueryResponse
#define SOAP_TYPE__ns5__TpServiceQueryResponse (277)
/* ns5:TpServiceQueryResponse */
class SOAP_CMAC _ns5__TpServiceQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	int *MemThreshold;	/* optional element of type xsd:int */
	int *DiskThreshold;	/* optional element of type xsd:int */
	int *CpuThreshold;	/* optional element of type xsd:int */
	bool *EncapsulatedSystem;	/* optional element of type xsd:boolean */
	bool *EnableSNMP;	/* optional element of type xsd:boolean */
	std::wstring *PreflightProcessFilter;	/* optional element of type xsd:string */
	std::wstring *AcceptLanguage;	/* optional element of type xsd:string */
	std::wstring *MemThresholdType;	/* optional element of type xsd:string */
	std::wstring *DiskThresholdType;	/* optional element of type xsd:string */
	ns5__TpServices *ServiceList;	/* optional element of type ns5:TpServices */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 277; } /* = unique id SOAP_TYPE__ns5__TpServiceQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpServiceQueryResponse() : Exceptions(NULL), MemThreshold(NULL), DiskThreshold(NULL), CpuThreshold(NULL), EncapsulatedSystem(NULL), EnableSNMP(NULL), PreflightProcessFilter(NULL), AcceptLanguage(NULL), MemThresholdType(NULL), DiskThresholdType(NULL), ServiceList(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpServiceQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSetMachineStatusRequest
#define SOAP_TYPE__ns5__TpSetMachineStatusRequest (278)
/* ns5:TpSetMachineStatusRequest */
class SOAP_CMAC _ns5__TpSetMachineStatusRequest
{
public:
	std::wstring *MachinePath;	/* optional element of type xsd:string */
	std::wstring *StatusValue;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 278; } /* = unique id SOAP_TYPE__ns5__TpSetMachineStatusRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSetMachineStatusRequest() : MachinePath(NULL), StatusValue(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSetMachineStatusRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSetMachineStatusResponse
#define SOAP_TYPE__ns5__TpSetMachineStatusResponse (279)
/* ns5:TpSetMachineStatusResponse */
class SOAP_CMAC _ns5__TpSetMachineStatusResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *TpSetMachineStatusResult;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 279; } /* = unique id SOAP_TYPE__ns5__TpSetMachineStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSetMachineStatusResponse() : Exceptions(NULL), TpSetMachineStatusResult(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSetMachineStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSwapNodeRequest
#define SOAP_TYPE__ns5__TpSwapNodeRequest (280)
/* ns5:TpSwapNodeRequest */
class SOAP_CMAC _ns5__TpSwapNodeRequest
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *OldIP;	/* optional element of type xsd:string */
	std::wstring *NewIP;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 280; } /* = unique id SOAP_TYPE__ns5__TpSwapNodeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSwapNodeRequest() : Cluster(NULL), OldIP(NULL), NewIP(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSwapNodeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSwapNodeResponse
#define SOAP_TYPE__ns5__TpSwapNodeResponse (281)
/* ns5:TpSwapNodeResponse */
class SOAP_CMAC _ns5__TpSwapNodeResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *TpSwapNodeResult;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 281; } /* = unique id SOAP_TYPE__ns5__TpSwapNodeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSwapNodeResponse() : Exceptions(NULL), TpSwapNodeResult(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSwapNodeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpTargetClusterQueryRequest
#define SOAP_TYPE__ns5__TpTargetClusterQueryRequest (282)
/* ns5:TpTargetClusterQueryRequest */
class SOAP_CMAC _ns5__TpTargetClusterQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	bool ShowDetails;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 282; } /* = unique id SOAP_TYPE__ns5__TpTargetClusterQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpTargetClusterQueryRequest() : Type(NULL), Name(NULL), ShowDetails((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpTargetClusterQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpTargetClusterQueryResponse
#define SOAP_TYPE__ns5__TpTargetClusterQueryResponse (283)
/* ns5:TpTargetClusterQueryResponse */
class SOAP_CMAC _ns5__TpTargetClusterQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool ShowDetails;	/* optional element of type xsd:boolean */
	int *MemThreshold;	/* optional element of type xsd:int */
	int *DiskThreshold;	/* optional element of type xsd:int */
	int *CpuThreshold;	/* optional element of type xsd:int */
	std::wstring *MemThresholdType;	/* optional element of type xsd:string */
	std::wstring *DiskThresholdType;	/* optional element of type xsd:string */
	std::wstring *PreflightProcessFilter;	/* optional element of type xsd:string */
	std::wstring *AcceptLanguage;	/* optional element of type xsd:string */
	ns5__ArrayOfTpTargetCluster *TpTargetClusters;	/* optional element of type ns5:ArrayOfTpTargetCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 283; } /* = unique id SOAP_TYPE__ns5__TpTargetClusterQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpTargetClusterQueryResponse() : Exceptions(NULL), ShowDetails((bool)0), MemThreshold(NULL), DiskThreshold(NULL), CpuThreshold(NULL), MemThresholdType(NULL), DiskThresholdType(NULL), PreflightProcessFilter(NULL), AcceptLanguage(NULL), TpTargetClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpTargetClusterQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpThorStatusRequest
#define SOAP_TYPE__ns5__TpThorStatusRequest (284)
/* ns5:TpThorStatusRequest */
class SOAP_CMAC _ns5__TpThorStatusRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 284; } /* = unique id SOAP_TYPE__ns5__TpThorStatusRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpThorStatusRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpThorStatusRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpThorStatusResponse
#define SOAP_TYPE__ns5__TpThorStatusResponse (285)
/* ns5:TpThorStatusResponse */
class SOAP_CMAC _ns5__TpThorStatusResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Group;	/* optional element of type xsd:string */
	std::wstring *ThorMasterIPAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	std::wstring *StartTime;	/* optional element of type xsd:string */
	std::wstring *LogFile;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Graph;	/* optional element of type xsd:string */
	int *SubGraph;	/* optional element of type xsd:int */
	int *SubGraphDuration;	/* optional element of type xsd:int */
	int *AutoRefresh;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 285; } /* = unique id SOAP_TYPE__ns5__TpThorStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpThorStatusResponse() : Exceptions(NULL), Name(NULL), Queue(NULL), Group(NULL), ThorMasterIPAddress(NULL), Port(NULL), StartTime(NULL), LogFile(NULL), Wuid(NULL), Graph(NULL), SubGraph(NULL), SubGraphDuration(NULL), AutoRefresh(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpThorStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpXMLFileRequest
#define SOAP_TYPE__ns5__TpXMLFileRequest (286)
/* ns5:TpXMLFileRequest */
class SOAP_CMAC _ns5__TpXMLFileRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 286; } /* = unique id SOAP_TYPE__ns5__TpXMLFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpXMLFileRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpXMLFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpXMLFileResponse
#define SOAP_TYPE__ns5__TpXMLFileResponse (287)
/* ns5:TpXMLFileResponse */
class SOAP_CMAC _ns5__TpXMLFileResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 287; } /* = unique id SOAP_TYPE__ns5__TpXMLFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpXMLFileResponse() : Exceptions(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpXMLFileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns6__EspException
#define SOAP_TYPE_ns6__EspException (288)
/* ns6:EspException */
class SOAP_CMAC ns6__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 288; } /* = unique id SOAP_TYPE_ns6__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfEspException
#define SOAP_TYPE_ns6__ArrayOfEspException (289)
/* ns6:ArrayOfEspException */
class SOAP_CMAC ns6__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns6__EspException * >Exception;	/* optional element of type ns6:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 289; } /* = unique id SOAP_TYPE_ns6__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__EspStringArray
#define SOAP_TYPE_ns6__EspStringArray (290)
/* ns6:EspStringArray */
class SOAP_CMAC ns6__EspStringArray
{
public:
	std::vector<std::wstring * >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 290; } /* = unique id SOAP_TYPE_ns6__EspStringArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__EspStringArray() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__EspStringArray() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUActionResult
#define SOAP_TYPE_ns6__WUActionResult (291)
/* ns6:WUActionResult */
class SOAP_CMAC ns6__WUActionResult
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Action;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 291; } /* = unique id SOAP_TYPE_ns6__WUActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUActionResult() : Wuid(NULL), Action(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfWUActionResult
#define SOAP_TYPE_ns6__ArrayOfWUActionResult (292)
/* ns6:ArrayOfWUActionResult */
class SOAP_CMAC ns6__ArrayOfWUActionResult
{
public:
	std::vector<ns6__WUActionResult * >WUActionResult;	/* optional element of type ns6:WUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 292; } /* = unique id SOAP_TYPE_ns6__ArrayOfWUActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfWUActionResult() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfWUActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DeploymentFeatures
#define SOAP_TYPE_ns6__DeploymentFeatures (293)
/* ns6:DeploymentFeatures */
class SOAP_CMAC ns6__DeploymentFeatures
{
public:
	bool *UseCompression;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 293; } /* = unique id SOAP_TYPE_ns6__DeploymentFeatures */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DeploymentFeatures() : UseCompression(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__DeploymentFeatures() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLException
#define SOAP_TYPE_ns6__ECLException (294)
/* ns6:ECLException */
class SOAP_CMAC ns6__ECLException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Severity;	/* optional element of type xsd:string */
	int *Code;	/* optional element of type xsd:int */
	std::wstring *Message;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	int *LineNo;	/* optional element of type xsd:int */
	int *Column;	/* optional element of type xsd:int */
	int *Activity;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 294; } /* = unique id SOAP_TYPE_ns6__ECLException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLException() : Source(NULL), Severity(NULL), Code(NULL), Message(NULL), FileName(NULL), LineNo(NULL), Column(NULL), Activity(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUECLAttribute
#define SOAP_TYPE_ns6__WUECLAttribute (295)
/* ns6:WUECLAttribute */
class SOAP_CMAC ns6__WUECLAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	bool *IsLocked;	/* optional element of type xsd:boolean */
	bool *IsCheckedOut;	/* optional element of type xsd:boolean */
	bool *IsSandbox;	/* optional element of type xsd:boolean */
	bool *IsOrphaned;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 295; } /* = unique id SOAP_TYPE_ns6__WUECLAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUECLAttribute() : ModuleName(NULL), AttributeName(NULL), IsLocked(NULL), IsCheckedOut(NULL), IsSandbox(NULL), IsOrphaned(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUECLAttribute() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLException
#define SOAP_TYPE_ns6__ArrayOfECLException (296)
/* ns6:ArrayOfECLException */
class SOAP_CMAC ns6__ArrayOfECLException
{
public:
	std::vector<ns6__ECLException * >ECLException;	/* optional element of type ns6:ECLException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 296; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLException() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUCopyLogicalClusterFileSections
#define SOAP_TYPE_ns6__WUCopyLogicalClusterFileSections (297)
/* ns6:WUCopyLogicalClusterFileSections */
class SOAP_CMAC ns6__WUCopyLogicalClusterFileSections
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	class ns6__ArrayOfWULogicalFileCopyInfo *OnCluster;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	ns6__ArrayOfWULogicalFileCopyInfo *NotOnCluster;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	ns6__ArrayOfWULogicalFileCopyInfo *Foreign;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	ns6__ArrayOfWULogicalFileCopyInfo *NotFound;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 297; } /* = unique id SOAP_TYPE_ns6__WUCopyLogicalClusterFileSections */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUCopyLogicalClusterFileSections() : ClusterName(NULL), OnCluster(NULL), NotOnCluster(NULL), Foreign(NULL), NotFound(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUCopyLogicalClusterFileSections() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WULogicalFileCopyInfo
#define SOAP_TYPE_ns6__WULogicalFileCopyInfo (298)
/* ns6:WULogicalFileCopyInfo */
class SOAP_CMAC ns6__WULogicalFileCopyInfo
{
public:
	bool *IsIndex;	/* optional element of type xsd:boolean */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *DfuCopyWuid;	/* optional element of type xsd:string */
	std::wstring *DfuCopyError;	/* optional element of type xsd:string */
	ns6__EspStringArray *Clusters;	/* optional element of type ns6:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 298; } /* = unique id SOAP_TYPE_ns6__WULogicalFileCopyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WULogicalFileCopyInfo() : IsIndex(NULL), LogicalName(NULL), DfuCopyWuid(NULL), DfuCopyError(NULL), Clusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WULogicalFileCopyInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfWULogicalFileCopyInfo
#define SOAP_TYPE_ns6__ArrayOfWULogicalFileCopyInfo (299)
/* ns6:ArrayOfWULogicalFileCopyInfo */
class SOAP_CMAC ns6__ArrayOfWULogicalFileCopyInfo
{
public:
	std::vector<ns6__WULogicalFileCopyInfo * >WULogicalFileCopyInfo;	/* optional element of type ns6:WULogicalFileCopyInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 299; } /* = unique id SOAP_TYPE_ns6__ArrayOfWULogicalFileCopyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfWULogicalFileCopyInfo() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfWULogicalFileCopyInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__LogicalFileError
#define SOAP_TYPE_ns6__LogicalFileError (300)
/* ns6:LogicalFileError */
class SOAP_CMAC ns6__LogicalFileError
{
public:
	std::wstring *Error;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 300; } /* = unique id SOAP_TYPE_ns6__LogicalFileError */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__LogicalFileError() : Error(NULL), LogicalName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__LogicalFileError() { }
};
#endif

#ifndef SOAP_TYPE__ns6__ECLWorkunit_AllowedClusters
#define SOAP_TYPE__ns6__ECLWorkunit_AllowedClusters (742)
/* ns6:ECLWorkunit-AllowedClusters */
class SOAP_CMAC _ns6__ECLWorkunit_AllowedClusters
{
public:
	std::vector<std::wstring * >AllowedCluster;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 742; } /* = unique id SOAP_TYPE__ns6__ECLWorkunit_AllowedClusters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__ECLWorkunit_AllowedClusters()  { this->soap_default(NULL); }
	virtual ~_ns6__ECLWorkunit_AllowedClusters() { }
};
#endif

#ifndef SOAP_TYPE__ns6__ECLWorkunit_ResourceURLs
#define SOAP_TYPE__ns6__ECLWorkunit_ResourceURLs (745)
/* ns6:ECLWorkunit-ResourceURLs */
class SOAP_CMAC _ns6__ECLWorkunit_ResourceURLs
{
public:
	std::vector<std::wstring * >URL;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 745; } /* = unique id SOAP_TYPE__ns6__ECLWorkunit_ResourceURLs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__ECLWorkunit_ResourceURLs()  { this->soap_default(NULL); }
	virtual ~_ns6__ECLWorkunit_ResourceURLs() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLWorkunit
#define SOAP_TYPE_ns6__ECLWorkunit (301)
/* ns6:ECLWorkunit */
class SOAP_CMAC ns6__ECLWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *RoxieCluster;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	int *StateID;	/* optional element of type xsd:int */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StateEx;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	bool *Protected;	/* optional element of type xsd:boolean */
	bool *Active;	/* optional element of type xsd:boolean */
	int *Action;	/* optional element of type xsd:int */
	std::wstring *ActionEx;	/* optional element of type xsd:string */
	time_t *DateTimeScheduled;	/* optional element of type xsd:dateTime */
	int *PriorityClass;	/* optional element of type xsd:int */
	int *PriorityLevel;	/* optional element of type xsd:int */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	int *ResultLimit;	/* optional element of type xsd:int */
	bool *Archived;	/* optional element of type xsd:boolean */
	bool IsPausing;	/* optional element of type xsd:boolean */
	bool ThorLCR;	/* optional element of type xsd:boolean */
	int *EventSchedule;	/* optional element of type xsd:int */
	bool *HaveSubGraphTimings;	/* optional element of type xsd:boolean */
	std::wstring *TotalClusterTime;	/* optional element of type xsd:string */
	std::wstring *AbortBy;	/* optional element of type xsd:string */
	std::wstring *AbortTime;	/* optional element of type xsd:string */
	class ns6__ECLQuery *Query;	/* optional element of type ns6:ECLQuery */
	class ns6__ArrayOfECLHelpFile *Helpers;	/* optional element of type ns6:ArrayOfECLHelpFile */
	ns6__ArrayOfECLException *Exceptions;	/* optional element of type ns6:ArrayOfECLException */
	class ns6__ArrayOfECLGraph *Graphs;	/* optional element of type ns6:ArrayOfECLGraph */
	class ns6__ArrayOfECLSourceFile *SourceFiles;	/* optional element of type ns6:ArrayOfECLSourceFile */
	class ns6__ArrayOfECLResult *Results;	/* optional element of type ns6:ArrayOfECLResult */
	ns6__ArrayOfECLResult *Variables;	/* optional element of type ns6:ArrayOfECLResult */
	class ns6__ArrayOfECLTimer *Timers;	/* optional element of type ns6:ArrayOfECLTimer */
	class ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	class ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	class ns6__ArrayOfECLWorkflow *Workflows;	/* optional element of type ns6:ArrayOfECLWorkflow */
	class ns6__ArrayOfECLTimingData *TimingData;	/* optional element of type ns6:ArrayOfECLTimingData */
	_ns6__ECLWorkunit_AllowedClusters *AllowedClusters;	/* optional element of type ns6:ECLWorkunit-AllowedClusters */
	int *ErrorCount;	/* optional element of type xsd:int */
	int *WarningCount;	/* optional element of type xsd:int */
	int *InfoCount;	/* optional element of type xsd:int */
	int *AlertCount;	/* optional element of type xsd:int */
	int *GraphCount;	/* optional element of type xsd:int */
	int *SourceFileCount;	/* optional element of type xsd:int */
	int *ResultCount;	/* optional element of type xsd:int */
	int *VariableCount;	/* optional element of type xsd:int */
	int *TimerCount;	/* optional element of type xsd:int */
	bool *HasDebugValue;	/* optional element of type xsd:boolean */
	int *ApplicationValueCount;	/* optional element of type xsd:int */
	std::wstring *XmlParams;	/* optional element of type xsd:string */
	int *AccessFlag;	/* optional element of type xsd:int */
	int *ClusterFlag;	/* optional element of type xsd:int */
	std::wstring *HelpersDesc;	/* optional element of type xsd:string */
	std::wstring *GraphsDesc;	/* optional element of type xsd:string */
	std::wstring *SourceFilesDesc;	/* optional element of type xsd:string */
	std::wstring *ResultsDesc;	/* optional element of type xsd:string */
	std::wstring *VariablesDesc;	/* optional element of type xsd:string */
	std::wstring *TimersDesc;	/* optional element of type xsd:string */
	std::wstring *DebugValuesDesc;	/* optional element of type xsd:string */
	std::wstring *ApplicationValuesDesc;	/* optional element of type xsd:string */
	std::wstring *WorkflowsDesc;	/* optional element of type xsd:string */
	bool *HasArchiveQuery;	/* optional element of type xsd:boolean */
	class ns6__ArrayOfThorLogInfo *ThorLogList;	/* optional element of type ns6:ArrayOfThorLogInfo */
	_ns6__ECLWorkunit_ResourceURLs *ResourceURLs;	/* optional element of type ns6:ECLWorkunit-ResourceURLs */
	int *ResultViewCount;	/* optional element of type xsd:int */
	int *ResourceURLCount;	/* optional element of type xsd:int */
	int *DebugValueCount;	/* optional element of type xsd:int */
	int *WorkflowCount;	/* optional element of type xsd:int */
	int *HelpersCount;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 301; } /* = unique id SOAP_TYPE_ns6__ECLWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLWorkunit() : Wuid(NULL), Owner(NULL), Cluster(NULL), RoxieCluster(NULL), Jobname(NULL), Queue(NULL), StateID(NULL), State(NULL), StateEx(NULL), Description(NULL), Protected(NULL), Active(NULL), Action(NULL), ActionEx(NULL), DateTimeScheduled(NULL), PriorityClass(NULL), PriorityLevel(NULL), Scope(NULL), Snapshot(NULL), ResultLimit(NULL), Archived(NULL), IsPausing((bool)0), ThorLCR((bool)0), EventSchedule(NULL), HaveSubGraphTimings(NULL), TotalClusterTime(NULL), AbortBy(NULL), AbortTime(NULL), Query(NULL), Helpers(NULL), Exceptions(NULL), Graphs(NULL), SourceFiles(NULL), Results(NULL), Variables(NULL), Timers(NULL), DebugValues(NULL), ApplicationValues(NULL), Workflows(NULL), TimingData(NULL), AllowedClusters(NULL), ErrorCount(NULL), WarningCount(NULL), InfoCount(NULL), AlertCount(NULL), GraphCount(NULL), SourceFileCount(NULL), ResultCount(NULL), VariableCount(NULL), TimerCount(NULL), HasDebugValue(NULL), ApplicationValueCount(NULL), XmlParams(NULL), AccessFlag(NULL), ClusterFlag(NULL), HelpersDesc(NULL), GraphsDesc(NULL), SourceFilesDesc(NULL), ResultsDesc(NULL), VariablesDesc(NULL), TimersDesc(NULL), DebugValuesDesc(NULL), ApplicationValuesDesc(NULL), WorkflowsDesc(NULL), HasArchiveQuery(NULL), ThorLogList(NULL), ResourceURLs(NULL), ResultViewCount(NULL), ResourceURLCount(NULL), DebugValueCount(NULL), WorkflowCount(NULL), HelpersCount(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLQuery
#define SOAP_TYPE_ns6__ECLQuery (302)
/* ns6:ECLQuery */
class SOAP_CMAC ns6__ECLQuery
{
public:
	std::wstring *Text;	/* optional element of type xsd:string */
	std::wstring *Cpp;	/* optional element of type xsd:string */
	std::wstring *ResTxt;	/* optional element of type xsd:string */
	std::wstring *Dll;	/* optional element of type xsd:string */
	std::wstring *ThorLog;	/* optional element of type xsd:string */
	std::wstring *QueryMainDefinition;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 302; } /* = unique id SOAP_TYPE_ns6__ECLQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLQuery() : Text(NULL), Cpp(NULL), ResTxt(NULL), Dll(NULL), ThorLog(NULL), QueryMainDefinition(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLQuery() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLHelpFile
#define SOAP_TYPE_ns6__ECLHelpFile (303)
/* ns6:ECLHelpFile */
class SOAP_CMAC ns6__ECLHelpFile
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *IPAddress;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	LONG64 *FileSize;	/* optional element of type xsd:long */
	unsigned int *PID;	/* optional element of type xsd:unsignedInt */
	unsigned int *minActivityId;	/* optional element of type xsd:unsignedInt */
	unsigned int *maxActivityId;	/* optional element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 303; } /* = unique id SOAP_TYPE_ns6__ECLHelpFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLHelpFile() : Name(NULL), Type(NULL), IPAddress(NULL), Description(NULL), FileSize(NULL), PID(NULL), minActivityId(NULL), maxActivityId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLHelpFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLGraph
#define SOAP_TYPE_ns6__ECLGraph (304)
/* ns6:ECLGraph */
class SOAP_CMAC ns6__ECLGraph
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Label;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	bool *Running;	/* optional element of type xsd:boolean */
	bool *Complete;	/* optional element of type xsd:boolean */
	bool *Failed;	/* optional element of type xsd:boolean */
	LONG64 *RunningId;	/* optional element of type xsd:long */
	std::wstring *WhenStarted;	/* optional element of type xsd:string */
	std::wstring *WhenFinished;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 304; } /* = unique id SOAP_TYPE_ns6__ECLGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLGraph() : Name(NULL), Label(NULL), Type(NULL), Running(NULL), Complete(NULL), Failed(NULL), RunningId(NULL), WhenStarted(NULL), WhenFinished(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLGraph() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLSourceFile
#define SOAP_TYPE_ns6__ECLSourceFile (305)
/* ns6:ECLSourceFile */
class SOAP_CMAC ns6__ECLSourceFile
{
public:
	std::wstring *FileCluster;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	bool *IsSuperFile;	/* optional element of type xsd:boolean */
	int *Subs;	/* optional element of type xsd:int */
	int *Count;	/* optional element of type xsd:int */
	ns6__ArrayOfECLSourceFile *ECLSourceFiles;	/* optional element of type ns6:ArrayOfECLSourceFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 305; } /* = unique id SOAP_TYPE_ns6__ECLSourceFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLSourceFile() : FileCluster(NULL), Name(NULL), IsSuperFile(NULL), Subs(NULL), Count(NULL), ECLSourceFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLSourceFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLSourceFile
#define SOAP_TYPE_ns6__ArrayOfECLSourceFile (306)
/* ns6:ArrayOfECLSourceFile */
class SOAP_CMAC ns6__ArrayOfECLSourceFile
{
public:
	std::vector<ns6__ECLSourceFile * >ECLSourceFile;	/* optional element of type ns6:ECLSourceFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 306; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLSourceFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLSourceFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLSourceFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLResult
#define SOAP_TYPE_ns6__ECLResult (307)
/* ns6:ECLResult */
class SOAP_CMAC ns6__ECLResult
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *Value;	/* optional element of type xsd:string */
	std::wstring *Link;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	bool *IsSupplied;	/* optional element of type xsd:boolean */
	bool ShowFileContent;	/* optional element of type xsd:boolean */
	LONG64 *Total;	/* optional element of type xsd:long */
	class ns6__ArrayOfECLSchemaItem *ECLSchemas;	/* optional element of type ns6:ArrayOfECLSchemaItem */
	std::wstring *XmlSchema;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 307; } /* = unique id SOAP_TYPE_ns6__ECLResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLResult() : Name(NULL), Sequence(NULL), Value(NULL), Link(NULL), FileName(NULL), IsSupplied(NULL), ShowFileContent((bool)0), Total(NULL), ECLSchemas(NULL), XmlSchema(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLSchemaItem
#define SOAP_TYPE_ns6__ECLSchemaItem (308)
/* ns6:ECLSchemaItem */
class SOAP_CMAC ns6__ECLSchemaItem
{
public:
	std::wstring *ColumnName;	/* optional element of type xsd:string */
	std::wstring *ColumnType;	/* optional element of type xsd:string */
	int *ColumnTypeCode;	/* optional element of type xsd:int */
	bool isConditional;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 308; } /* = unique id SOAP_TYPE_ns6__ECLSchemaItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLSchemaItem() : ColumnName(NULL), ColumnType(NULL), ColumnTypeCode(NULL), isConditional((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLSchemaItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLSchemaItem
#define SOAP_TYPE_ns6__ArrayOfECLSchemaItem (309)
/* ns6:ArrayOfECLSchemaItem */
class SOAP_CMAC ns6__ArrayOfECLSchemaItem
{
public:
	std::vector<ns6__ECLSchemaItem * >ECLSchemaItem;	/* optional element of type ns6:ECLSchemaItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 309; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLSchemaItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLSchemaItem() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLSchemaItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLTimer
#define SOAP_TYPE_ns6__ECLTimer (310)
/* ns6:ECLTimer */
class SOAP_CMAC ns6__ECLTimer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	int *count;	/* optional element of type xsd:int */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	int *SubGraphId;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 310; } /* = unique id SOAP_TYPE_ns6__ECLTimer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLTimer() : Name(NULL), Value(NULL), count(NULL), GraphName(NULL), SubGraphId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLTimer() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DebugValue
#define SOAP_TYPE_ns6__DebugValue (311)
/* ns6:DebugValue */
class SOAP_CMAC ns6__DebugValue
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 311; } /* = unique id SOAP_TYPE_ns6__DebugValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DebugValue() : Name(NULL), Value(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__DebugValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ApplicationValue
#define SOAP_TYPE_ns6__ApplicationValue (312)
/* ns6:ApplicationValue */
class SOAP_CMAC ns6__ApplicationValue
{
public:
	std::wstring *Application;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 312; } /* = unique id SOAP_TYPE_ns6__ApplicationValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ApplicationValue() : Application(NULL), Name(NULL), Value(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ApplicationValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLWorkflow
#define SOAP_TYPE_ns6__ECLWorkflow (313)
/* ns6:ECLWorkflow */
class SOAP_CMAC ns6__ECLWorkflow
{
public:
	std::wstring *WFID;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *EventText;	/* optional element of type xsd:string */
	int Count;	/* optional element of type xsd:int */
	int CountRemaining;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 313; } /* = unique id SOAP_TYPE_ns6__ECLWorkflow */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLWorkflow() : WFID(NULL), EventName(NULL), EventText(NULL), Count(0), CountRemaining(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLWorkflow() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLTimingData
#define SOAP_TYPE_ns6__ECLTimingData (314)
/* ns6:ECLTimingData */
class SOAP_CMAC ns6__ECLTimingData
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	int *GraphNum;	/* optional element of type xsd:int */
	int *SubGraphNum;	/* optional element of type xsd:int */
	int *GID;	/* optional element of type xsd:int */
	int *Min;	/* optional element of type xsd:int */
	int *MS;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 314; } /* = unique id SOAP_TYPE_ns6__ECLTimingData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLTimingData() : Name(NULL), GraphNum(NULL), SubGraphNum(NULL), GID(NULL), Min(NULL), MS(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLTimingData() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ThorLogInfo
#define SOAP_TYPE_ns6__ThorLogInfo (315)
/* ns6:ThorLogInfo */
class SOAP_CMAC ns6__ThorLogInfo
{
public:
	std::wstring *ProcessName;	/* optional element of type xsd:string */
	std::wstring *ClusterGroup;	/* optional element of type xsd:string */
	std::wstring *LogDate;	/* optional element of type xsd:string */
	int *NumberSlaves;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 315; } /* = unique id SOAP_TYPE_ns6__ThorLogInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ThorLogInfo() : ProcessName(NULL), ClusterGroup(NULL), LogDate(NULL), NumberSlaves(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ThorLogInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfApplicationValue
#define SOAP_TYPE_ns6__ArrayOfApplicationValue (316)
/* ns6:ArrayOfApplicationValue */
class SOAP_CMAC ns6__ArrayOfApplicationValue
{
public:
	std::vector<ns6__ApplicationValue * >ApplicationValue;	/* optional element of type ns6:ApplicationValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 316; } /* = unique id SOAP_TYPE_ns6__ArrayOfApplicationValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfApplicationValue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfApplicationValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfDebugValue
#define SOAP_TYPE_ns6__ArrayOfDebugValue (317)
/* ns6:ArrayOfDebugValue */
class SOAP_CMAC ns6__ArrayOfDebugValue
{
public:
	std::vector<ns6__DebugValue * >DebugValue;	/* optional element of type ns6:DebugValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 317; } /* = unique id SOAP_TYPE_ns6__ArrayOfDebugValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfDebugValue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfDebugValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLGraph
#define SOAP_TYPE_ns6__ArrayOfECLGraph (318)
/* ns6:ArrayOfECLGraph */
class SOAP_CMAC ns6__ArrayOfECLGraph
{
public:
	std::vector<ns6__ECLGraph * >ECLGraph;	/* optional element of type ns6:ECLGraph */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 318; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLGraph() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLGraph() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLHelpFile
#define SOAP_TYPE_ns6__ArrayOfECLHelpFile (319)
/* ns6:ArrayOfECLHelpFile */
class SOAP_CMAC ns6__ArrayOfECLHelpFile
{
public:
	std::vector<ns6__ECLHelpFile * >ECLHelpFile;	/* optional element of type ns6:ECLHelpFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 319; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLHelpFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLHelpFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLHelpFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLResult
#define SOAP_TYPE_ns6__ArrayOfECLResult (320)
/* ns6:ArrayOfECLResult */
class SOAP_CMAC ns6__ArrayOfECLResult
{
public:
	std::vector<ns6__ECLResult * >ECLResult;	/* optional element of type ns6:ECLResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 320; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLResult() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLTimer
#define SOAP_TYPE_ns6__ArrayOfECLTimer (321)
/* ns6:ArrayOfECLTimer */
class SOAP_CMAC ns6__ArrayOfECLTimer
{
public:
	std::vector<ns6__ECLTimer * >ECLTimer;	/* optional element of type ns6:ECLTimer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 321; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLTimer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLTimer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLTimer() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLTimingData
#define SOAP_TYPE_ns6__ArrayOfECLTimingData (322)
/* ns6:ArrayOfECLTimingData */
class SOAP_CMAC ns6__ArrayOfECLTimingData
{
public:
	std::vector<ns6__ECLTimingData * >ECLTimingData;	/* optional element of type ns6:ECLTimingData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 322; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLTimingData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLTimingData() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLTimingData() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLWorkflow
#define SOAP_TYPE_ns6__ArrayOfECLWorkflow (323)
/* ns6:ArrayOfECLWorkflow */
class SOAP_CMAC ns6__ArrayOfECLWorkflow
{
public:
	std::vector<ns6__ECLWorkflow * >ECLWorkflow;	/* optional element of type ns6:ECLWorkflow */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 323; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLWorkflow */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLWorkflow() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLWorkflow() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfThorLogInfo
#define SOAP_TYPE_ns6__ArrayOfThorLogInfo (324)
/* ns6:ArrayOfThorLogInfo */
class SOAP_CMAC ns6__ArrayOfThorLogInfo
{
public:
	std::vector<ns6__ThorLogInfo * >ThorLogInfo;	/* optional element of type ns6:ThorLogInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 324; } /* = unique id SOAP_TYPE_ns6__ArrayOfThorLogInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfThorLogInfo() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfThorLogInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__NamedValue
#define SOAP_TYPE_ns6__NamedValue (325)
/* ns6:NamedValue */
class SOAP_CMAC ns6__NamedValue
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 325; } /* = unique id SOAP_TYPE_ns6__NamedValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__NamedValue() : Name(NULL), Value(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__NamedValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfNamedValue
#define SOAP_TYPE_ns6__ArrayOfNamedValue (326)
/* ns6:ArrayOfNamedValue */
class SOAP_CMAC ns6__ArrayOfNamedValue
{
public:
	std::vector<ns6__NamedValue * >NamedValue;	/* optional element of type ns6:NamedValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 326; } /* = unique id SOAP_TYPE_ns6__ArrayOfNamedValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfNamedValue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfNamedValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLGraphEx
#define SOAP_TYPE_ns6__ECLGraphEx (327)
/* ns6:ECLGraphEx */
class SOAP_CMAC ns6__ECLGraphEx
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Label;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Graph;	/* optional element of type xsd:string */
	bool *Running;	/* optional element of type xsd:boolean */
	LONG64 *RunningId;	/* optional element of type xsd:long */
	bool *Complete;	/* optional element of type xsd:boolean */
	bool *Failed;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 327; } /* = unique id SOAP_TYPE_ns6__ECLGraphEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLGraphEx() : Name(NULL), Label(NULL), Type(NULL), Graph(NULL), Running(NULL), RunningId(NULL), Complete(NULL), Failed(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLGraphEx() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLGraphEx
#define SOAP_TYPE_ns6__ArrayOfECLGraphEx (328)
/* ns6:ArrayOfECLGraphEx */
class SOAP_CMAC ns6__ArrayOfECLGraphEx
{
public:
	std::vector<ns6__ECLGraphEx * >ECLGraphEx;	/* optional element of type ns6:ECLGraphEx */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 328; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLGraphEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLGraphEx() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLGraphEx() { }
};
#endif

#ifndef SOAP_TYPE_ns6__NameAndType
#define SOAP_TYPE_ns6__NameAndType (329)
/* ns6:NameAndType */
class SOAP_CMAC ns6__NameAndType
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 329; } /* = unique id SOAP_TYPE_ns6__NameAndType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__NameAndType() : Name(NULL), Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__NameAndType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ClusterEndpoint
#define SOAP_TYPE_ns6__ClusterEndpoint (330)
/* ns6:ClusterEndpoint */
class SOAP_CMAC ns6__ClusterEndpoint
{
public:
	std::wstring *URL;	/* optional element of type xsd:string */
	std::wstring *Status;	/* optional element of type xsd:string */
	int *NumQueryFileToCopy;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 330; } /* = unique id SOAP_TYPE_ns6__ClusterEndpoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ClusterEndpoint() : URL(NULL), Status(NULL), NumQueryFileToCopy(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ClusterEndpoint() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUStatisticItem
#define SOAP_TYPE_ns6__WUStatisticItem (331)
/* ns6:WUStatisticItem */
class SOAP_CMAC ns6__WUStatisticItem
{
public:
	std::wstring *Creator;	/* optional element of type xsd:string */
	std::wstring *CreatorType;	/* optional element of type xsd:string */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *ScopeType;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *TimeStamp;	/* optional element of type xsd:string */
	std::wstring *Measure;	/* optional element of type xsd:string */
	std::wstring *Kind;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	LONG64 *RawValue;	/* optional element of type xsd:long */
	LONG64 *Count;	/* optional element of type xsd:long */
	LONG64 *Max;	/* optional element of type xsd:long */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 331; } /* = unique id SOAP_TYPE_ns6__WUStatisticItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUStatisticItem() : Creator(NULL), CreatorType(NULL), Scope(NULL), ScopeType(NULL), Description(NULL), TimeStamp(NULL), Measure(NULL), Kind(NULL), Value(NULL), RawValue(NULL), Count(NULL), Max(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUStatisticItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfWUStatisticItem
#define SOAP_TYPE_ns6__ArrayOfWUStatisticItem (332)
/* ns6:ArrayOfWUStatisticItem */
class SOAP_CMAC ns6__ArrayOfWUStatisticItem
{
public:
	std::vector<ns6__WUStatisticItem * >WUStatisticItem;	/* optional element of type ns6:WUStatisticItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 332; } /* = unique id SOAP_TYPE_ns6__ArrayOfWUStatisticItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfWUStatisticItem() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfWUStatisticItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLJob
#define SOAP_TYPE_ns6__ECLJob (333)
/* ns6:ECLJob */
class SOAP_CMAC ns6__ECLJob
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Graph;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartedDate;	/* optional element of type xsd:string */
	std::wstring *FinishedDate;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *GraphNum;	/* optional element of type xsd:string */
	std::wstring *SubGraphNum;	/* optional element of type xsd:string */
	std::wstring *NumOfRuns;	/* optional element of type xsd:string */
	int *Duration;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 333; } /* = unique id SOAP_TYPE_ns6__ECLJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLJob() : Wuid(NULL), Graph(NULL), State(NULL), StartedDate(NULL), FinishedDate(NULL), Cluster(NULL), GraphNum(NULL), SubGraphNum(NULL), NumOfRuns(NULL), Duration(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLJob() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLJob
#define SOAP_TYPE_ns6__ArrayOfECLJob (334)
/* ns6:ArrayOfECLJob */
class SOAP_CMAC ns6__ArrayOfECLJob
{
public:
	std::vector<ns6__ECLJob * >ECLJob;	/* optional element of type ns6:ECLJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 334; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLJob() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLJob() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLWorkunitLW
#define SOAP_TYPE_ns6__ECLWorkunitLW (335)
/* ns6:ECLWorkunitLW */
class SOAP_CMAC ns6__ECLWorkunitLW
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	std::wstring *WuScope;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	int *State;	/* optional element of type xsd:int */
	std::wstring *StateDesc;	/* optional element of type xsd:string */
	int *Action;	/* optional element of type xsd:int */
	std::wstring *ActionDesc;	/* optional element of type xsd:string */
	int *Priority;	/* optional element of type xsd:int */
	std::wstring *PriorityDesc;	/* optional element of type xsd:string */
	int *PriorityLevel;	/* optional element of type xsd:int */
	bool *IsProtected;	/* optional element of type xsd:boolean */
	time_t *DateTimeScheduled;	/* optional element of type xsd:dateTime */
	unsigned int *TotalClusterTime;	/* optional element of type xsd:unsignedInt */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 335; } /* = unique id SOAP_TYPE_ns6__ECLWorkunitLW */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLWorkunitLW() : Wuid(NULL), Owner(NULL), JobName(NULL), WuScope(NULL), ClusterName(NULL), State(NULL), StateDesc(NULL), Action(NULL), ActionDesc(NULL), Priority(NULL), PriorityDesc(NULL), PriorityLevel(NULL), IsProtected(NULL), DateTimeScheduled(NULL), TotalClusterTime(NULL), ApplicationValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLWorkunitLW() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLWorkunitLW
#define SOAP_TYPE_ns6__ArrayOfECLWorkunitLW (336)
/* ns6:ArrayOfECLWorkunitLW */
class SOAP_CMAC ns6__ArrayOfECLWorkunitLW
{
public:
	std::vector<ns6__ECLWorkunitLW * >ECLWorkunitLW;	/* optional element of type ns6:ECLWorkunitLW */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 336; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLWorkunitLW */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLWorkunitLW() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLWorkunitLW() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUArchiveModule_ArchiveModules
#define SOAP_TYPE__ns6__WUArchiveModule_ArchiveModules (780)
/* ns6:WUArchiveModule-ArchiveModules */
class SOAP_CMAC _ns6__WUArchiveModule_ArchiveModules
{
public:
	std::vector<class ns6__WUArchiveModule * >ArchiveModule;	/* optional element of type ns6:WUArchiveModule */
public:
	virtual int soap_type() const { return 780; } /* = unique id SOAP_TYPE__ns6__WUArchiveModule_ArchiveModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUArchiveModule_ArchiveModules()  { this->soap_default(NULL); }
	virtual ~_ns6__WUArchiveModule_ArchiveModules() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUArchiveModule_Files
#define SOAP_TYPE__ns6__WUArchiveModule_Files (784)
/* ns6:WUArchiveModule-Files */
class SOAP_CMAC _ns6__WUArchiveModule_Files
{
public:
	std::vector<class ns6__WUArchiveFile * >File;	/* optional element of type ns6:WUArchiveFile */
public:
	virtual int soap_type() const { return 784; } /* = unique id SOAP_TYPE__ns6__WUArchiveModule_Files */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUArchiveModule_Files()  { this->soap_default(NULL); }
	virtual ~_ns6__WUArchiveModule_Files() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUArchiveModule
#define SOAP_TYPE_ns6__WUArchiveModule (337)
/* ns6:WUArchiveModule */
class SOAP_CMAC ns6__WUArchiveModule
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *FullName;	/* optional element of type xsd:string */
	unsigned int *Flags;	/* optional element of type xsd:unsignedInt */
	std::wstring *Key;	/* optional element of type xsd:string */
	std::wstring *Plugin;	/* optional element of type xsd:string */
	std::wstring *SourcePath;	/* optional element of type xsd:string */
	std::wstring *Version;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	_ns6__WUArchiveModule_ArchiveModules *ArchiveModules;	/* optional element of type ns6:WUArchiveModule-ArchiveModules */
	_ns6__WUArchiveModule_Files *Files;	/* optional element of type ns6:WUArchiveModule-Files */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 337; } /* = unique id SOAP_TYPE_ns6__WUArchiveModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUArchiveModule() : Name(NULL), FullName(NULL), Flags(NULL), Key(NULL), Plugin(NULL), SourcePath(NULL), Version(NULL), Path(NULL), ArchiveModules(NULL), Files(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUArchiveModule() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUArchiveFile
#define SOAP_TYPE_ns6__WUArchiveFile (338)
/* ns6:WUArchiveFile */
class SOAP_CMAC ns6__WUArchiveFile
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Key;	/* optional element of type xsd:string */
	std::wstring *SourcePath;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 338; } /* = unique id SOAP_TYPE_ns6__WUArchiveFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUArchiveFile() : Name(NULL), Key(NULL), SourcePath(NULL), Path(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUArchiveFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__LogicalFileUpload
#define SOAP_TYPE_ns6__LogicalFileUpload (339)
/* ns6:LogicalFileUpload */
class SOAP_CMAC ns6__LogicalFileUpload
{
public:
	int *Type;	/* optional element of type xsd:int */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Destination;	/* optional element of type xsd:string */
	std::wstring *EventTag;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 339; } /* = unique id SOAP_TYPE_ns6__LogicalFileUpload */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__LogicalFileUpload() : Type(NULL), Source(NULL), Destination(NULL), EventTag(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__LogicalFileUpload() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfLogicalFileUpload
#define SOAP_TYPE_ns6__ArrayOfLogicalFileUpload (340)
/* ns6:ArrayOfLogicalFileUpload */
class SOAP_CMAC ns6__ArrayOfLogicalFileUpload
{
public:
	std::vector<ns6__LogicalFileUpload * >LogicalFileUpload;	/* optional element of type ns6:LogicalFileUpload */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 340; } /* = unique id SOAP_TYPE_ns6__ArrayOfLogicalFileUpload */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfLogicalFileUpload() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfLogicalFileUpload() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQuery
#define SOAP_TYPE_ns6__QuerySetQuery (341)
/* ns6:QuerySetQuery */
class SOAP_CMAC ns6__QuerySetQuery
{
public:
	std::wstring *Id;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Dll;	/* optional element of type xsd:string */
	bool *Suspended;	/* optional element of type xsd:boolean */
	class ns6__ArrayOfClusterQueryState *Clusters;	/* optional element of type ns6:ArrayOfClusterQueryState */
	std::wstring *memoryLimit;	/* optional element of type xsd:string */
	unsigned int *timeLimit;	/* optional element of type xsd:unsignedInt */
	unsigned int *warnTimeLimit;	/* optional element of type xsd:unsignedInt */
	std::wstring *priority;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	std::wstring *QuerySetId;	/* optional element of type xsd:string */
	bool *IsLibrary;	/* optional element of type xsd:boolean */
	bool *Activated;	/* optional element of type xsd:boolean */
	std::wstring *PublishedBy;	/* optional element of type xsd:string */
	std::wstring *snapshot;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 341; } /* = unique id SOAP_TYPE_ns6__QuerySetQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQuery() : Id(NULL), Name(NULL), Wuid(NULL), Dll(NULL), Suspended(NULL), Clusters(NULL), memoryLimit(NULL), timeLimit(NULL), warnTimeLimit(NULL), priority(NULL), Comment(NULL), QuerySetId(NULL), IsLibrary(NULL), Activated(NULL), PublishedBy(NULL), snapshot(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQuery() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ClusterQueryState
#define SOAP_TYPE_ns6__ClusterQueryState (342)
/* ns6:ClusterQueryState */
class SOAP_CMAC ns6__ClusterQueryState
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *Errors;	/* optional element of type xsd:string */
	bool *MixedNodeStates;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 342; } /* = unique id SOAP_TYPE_ns6__ClusterQueryState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ClusterQueryState() : Cluster(NULL), State(NULL), Errors(NULL), MixedNodeStates(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ClusterQueryState() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfClusterQueryState
#define SOAP_TYPE_ns6__ArrayOfClusterQueryState (343)
/* ns6:ArrayOfClusterQueryState */
class SOAP_CMAC ns6__ArrayOfClusterQueryState
{
public:
	std::vector<ns6__ClusterQueryState * >ClusterQueryState;	/* optional element of type ns6:ClusterQueryState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 343; } /* = unique id SOAP_TYPE_ns6__ArrayOfClusterQueryState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfClusterQueryState() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfClusterQueryState() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfQuerySetQuery
#define SOAP_TYPE_ns6__ArrayOfQuerySetQuery (344)
/* ns6:ArrayOfQuerySetQuery */
class SOAP_CMAC ns6__ArrayOfQuerySetQuery
{
public:
	std::vector<ns6__QuerySetQuery * >QuerySetQuery;	/* optional element of type ns6:QuerySetQuery */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 344; } /* = unique id SOAP_TYPE_ns6__ArrayOfQuerySetQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfQuerySetQuery() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfQuerySetQuery() { }
};
#endif

#ifndef SOAP_TYPE_ns6__TargetQueriesUsingFile
#define SOAP_TYPE_ns6__TargetQueriesUsingFile (345)
/* ns6:TargetQueriesUsingFile */
class SOAP_CMAC ns6__TargetQueriesUsingFile
{
public:
	std::wstring *Target;	/* optional element of type xsd:string */
	std::wstring *PackageMap;	/* optional element of type xsd:string */
	class ns6__ArrayOfQueryUsingFile *Queries;	/* optional element of type ns6:ArrayOfQueryUsingFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 345; } /* = unique id SOAP_TYPE_ns6__TargetQueriesUsingFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__TargetQueriesUsingFile() : Target(NULL), PackageMap(NULL), Queries(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__TargetQueriesUsingFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QueryUsingFile
#define SOAP_TYPE_ns6__QueryUsingFile (346)
/* ns6:QueryUsingFile */
class SOAP_CMAC ns6__QueryUsingFile
{
public:
	std::wstring *Id;	/* optional element of type xsd:string */
	std::wstring *Package;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 346; } /* = unique id SOAP_TYPE_ns6__QueryUsingFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QueryUsingFile() : Id(NULL), Package(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QueryUsingFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfQueryUsingFile
#define SOAP_TYPE_ns6__ArrayOfQueryUsingFile (347)
/* ns6:ArrayOfQueryUsingFile */
class SOAP_CMAC ns6__ArrayOfQueryUsingFile
{
public:
	std::vector<ns6__QueryUsingFile * >QueryUsingFile;	/* optional element of type ns6:QueryUsingFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 347; } /* = unique id SOAP_TYPE_ns6__ArrayOfQueryUsingFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfQueryUsingFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfQueryUsingFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfTargetQueriesUsingFile
#define SOAP_TYPE_ns6__ArrayOfTargetQueriesUsingFile (348)
/* ns6:ArrayOfTargetQueriesUsingFile */
class SOAP_CMAC ns6__ArrayOfTargetQueriesUsingFile
{
public:
	std::vector<ns6__TargetQueriesUsingFile * >TargetQueriesUsingFile;	/* optional element of type ns6:TargetQueriesUsingFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 348; } /* = unique id SOAP_TYPE_ns6__ArrayOfTargetQueriesUsingFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfTargetQueriesUsingFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfTargetQueriesUsingFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUQuerySetDetail
#define SOAP_TYPE_ns6__WUQuerySetDetail (349)
/* ns6:WUQuerySetDetail */
class SOAP_CMAC ns6__WUQuerySetDetail
{
public:
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	ns6__ArrayOfQuerySetQuery *Queries;	/* optional element of type ns6:ArrayOfQuerySetQuery */
	class ns6__ArrayOfQuerySetAlias *Aliases;	/* optional element of type ns6:ArrayOfQuerySetAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 349; } /* = unique id SOAP_TYPE_ns6__WUQuerySetDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUQuerySetDetail() : QuerySetName(NULL), Queries(NULL), Aliases(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUQuerySetDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAlias
#define SOAP_TYPE_ns6__QuerySetAlias (350)
/* ns6:QuerySetAlias */
class SOAP_CMAC ns6__QuerySetAlias
{
public:
	std::wstring *Id;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 350; } /* = unique id SOAP_TYPE_ns6__QuerySetAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetAlias() : Id(NULL), Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetAlias() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfQuerySetAlias
#define SOAP_TYPE_ns6__ArrayOfQuerySetAlias (351)
/* ns6:ArrayOfQuerySetAlias */
class SOAP_CMAC ns6__ArrayOfQuerySetAlias
{
public:
	std::vector<ns6__QuerySetAlias * >QuerySetAlias;	/* optional element of type ns6:QuerySetAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 351; } /* = unique id SOAP_TYPE_ns6__ArrayOfQuerySetAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfQuerySetAlias() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfQuerySetAlias() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfWUQuerySetDetail
#define SOAP_TYPE_ns6__ArrayOfWUQuerySetDetail (352)
/* ns6:ArrayOfWUQuerySetDetail */
class SOAP_CMAC ns6__ArrayOfWUQuerySetDetail
{
public:
	std::vector<ns6__WUQuerySetDetail * >WUQuerySetDetail;	/* optional element of type ns6:WUQuerySetDetail */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 352; } /* = unique id SOAP_TYPE_ns6__ArrayOfWUQuerySetDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfWUQuerySetDetail() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfWUQuerySetDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLWorkunit
#define SOAP_TYPE_ns6__ArrayOfECLWorkunit (353)
/* ns6:ArrayOfECLWorkunit */
class SOAP_CMAC ns6__ArrayOfECLWorkunit
{
public:
	std::vector<ns6__ECLWorkunit * >ECLWorkunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 353; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLWorkunit() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUQueryConfigResult
#define SOAP_TYPE_ns6__WUQueryConfigResult (354)
/* ns6:WUQueryConfigResult */
class SOAP_CMAC ns6__WUQueryConfigResult
{
public:
	std::wstring *QueryId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 354; } /* = unique id SOAP_TYPE_ns6__WUQueryConfigResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUQueryConfigResult() : QueryId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUQueryConfigResult() { }
};
#endif

#ifndef SOAP_TYPE__ns6__QuerySuperFile_SubFiles
#define SOAP_TYPE__ns6__QuerySuperFile_SubFiles (808)
/* ns6:QuerySuperFile-SubFiles */
class SOAP_CMAC _ns6__QuerySuperFile_SubFiles
{
public:
	std::vector<std::wstring * >File;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 808; } /* = unique id SOAP_TYPE__ns6__QuerySuperFile_SubFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__QuerySuperFile_SubFiles()  { this->soap_default(NULL); }
	virtual ~_ns6__QuerySuperFile_SubFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__QuerySuperFile_SuperFiles
#define SOAP_TYPE__ns6__QuerySuperFile_SuperFiles (810)
/* ns6:QuerySuperFile-SuperFiles */
class SOAP_CMAC _ns6__QuerySuperFile_SuperFiles
{
public:
	std::vector<class ns6__QuerySuperFile * >SuperFile;	/* optional element of type ns6:QuerySuperFile */
public:
	virtual int soap_type() const { return 810; } /* = unique id SOAP_TYPE__ns6__QuerySuperFile_SuperFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__QuerySuperFile_SuperFiles()  { this->soap_default(NULL); }
	virtual ~_ns6__QuerySuperFile_SuperFiles() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySuperFile
#define SOAP_TYPE_ns6__QuerySuperFile (355)
/* ns6:QuerySuperFile */
class SOAP_CMAC ns6__QuerySuperFile
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	_ns6__QuerySuperFile_SubFiles *SubFiles;	/* optional element of type ns6:QuerySuperFile-SubFiles */
	_ns6__QuerySuperFile_SuperFiles *SuperFiles;	/* optional element of type ns6:QuerySuperFile-SuperFiles */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 355; } /* = unique id SOAP_TYPE_ns6__QuerySuperFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySuperFile() : Name(NULL), SubFiles(NULL), SuperFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySuperFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__FileUsedByQuery
#define SOAP_TYPE_ns6__FileUsedByQuery (356)
/* ns6:FileUsedByQuery */
class SOAP_CMAC ns6__FileUsedByQuery
{
public:
	std::wstring *FileName;	/* optional element of type xsd:string */
	LONG64 *FileSize;	/* optional element of type xsd:long */
	unsigned int *NumberOfParts;	/* optional element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 356; } /* = unique id SOAP_TYPE_ns6__FileUsedByQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__FileUsedByQuery() : FileName(NULL), FileSize(NULL), NumberOfParts(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__FileUsedByQuery() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAliasActionItem
#define SOAP_TYPE_ns6__QuerySetAliasActionItem (357)
/* ns6:QuerySetAliasActionItem */
class SOAP_CMAC ns6__QuerySetAliasActionItem
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 357; } /* = unique id SOAP_TYPE_ns6__QuerySetAliasActionItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetAliasActionItem() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetAliasActionItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAliasActionResult
#define SOAP_TYPE_ns6__QuerySetAliasActionResult (358)
/* ns6:QuerySetAliasActionResult */
class SOAP_CMAC ns6__QuerySetAliasActionResult
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	bool *Success;	/* optional element of type xsd:boolean */
	int *Code;	/* optional element of type xsd:int */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 358; } /* = unique id SOAP_TYPE_ns6__QuerySetAliasActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetAliasActionResult() : Name(NULL), Success(NULL), Code(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetAliasActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryActionItem
#define SOAP_TYPE_ns6__QuerySetQueryActionItem (359)
/* ns6:QuerySetQueryActionItem */
class SOAP_CMAC ns6__QuerySetQueryActionItem
{
public:
	std::wstring *QueryId;	/* optional element of type xsd:string */
	class ns6__QuerySetQueryClientState *ClientState;	/* optional element of type ns6:QuerySetQueryClientState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 359; } /* = unique id SOAP_TYPE_ns6__QuerySetQueryActionItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQueryActionItem() : QueryId(NULL), ClientState(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQueryActionItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryClientState
#define SOAP_TYPE_ns6__QuerySetQueryClientState (360)
/* ns6:QuerySetQueryClientState */
class SOAP_CMAC ns6__QuerySetQueryClientState
{
public:
	std::wstring *Suspended;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 360; } /* = unique id SOAP_TYPE_ns6__QuerySetQueryClientState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQueryClientState() : Suspended(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQueryClientState() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryActionResult
#define SOAP_TYPE_ns6__QuerySetQueryActionResult (361)
/* ns6:QuerySetQueryActionResult */
class SOAP_CMAC ns6__QuerySetQueryActionResult
{
public:
	std::wstring *QueryId;	/* optional element of type xsd:string */
	bool *Suspended;	/* optional element of type xsd:boolean */
	bool *Success;	/* optional element of type xsd:boolean */
	int *Code;	/* optional element of type xsd:int */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 361; } /* = unique id SOAP_TYPE_ns6__QuerySetQueryActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQueryActionResult() : QueryId(NULL), Suspended(NULL), Success(NULL), Code(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQueryActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySet
#define SOAP_TYPE_ns6__QuerySet (362)
/* ns6:QuerySet */
class SOAP_CMAC ns6__QuerySet
{
public:
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 362; } /* = unique id SOAP_TYPE_ns6__QuerySet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySet() : QuerySetName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySet() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfQuerySet
#define SOAP_TYPE_ns6__ArrayOfQuerySet (363)
/* ns6:ArrayOfQuerySet */
class SOAP_CMAC ns6__ArrayOfQuerySet
{
public:
	std::vector<ns6__QuerySet * >QuerySet;	/* optional element of type ns6:QuerySet */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 363; } /* = unique id SOAP_TYPE_ns6__ArrayOfQuerySet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfQuerySet() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfQuerySet() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ResubmittedWU
#define SOAP_TYPE_ns6__ResubmittedWU (364)
/* ns6:ResubmittedWU */
class SOAP_CMAC ns6__ResubmittedWU
{
public:
	std::wstring *WUID;	/* optional element of type xsd:string */
	std::wstring *ParentWUID;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 364; } /* = unique id SOAP_TYPE_ns6__ResubmittedWU */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ResubmittedWU() : WUID(NULL), ParentWUID(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ResubmittedWU() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ServerInfo
#define SOAP_TYPE_ns6__ServerInfo (365)
/* ns6:ServerInfo */
class SOAP_CMAC ns6__ServerInfo
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *NetAddress;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 365; } /* = unique id SOAP_TYPE_ns6__ServerInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ServerInfo() : Name(NULL), NetAddress(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ServerInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ScheduledWU
#define SOAP_TYPE_ns6__ScheduledWU (366)
/* ns6:ScheduledWU */
class SOAP_CMAC ns6__ScheduledWU
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *EventText;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	int *StateID;	/* optional element of type xsd:int */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 366; } /* = unique id SOAP_TYPE_ns6__ScheduledWU */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ScheduledWU() : Wuid(NULL), Cluster(NULL), EventName(NULL), EventText(NULL), JobName(NULL), StateID(NULL), State(NULL), Owner(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ScheduledWU() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfScheduledWU
#define SOAP_TYPE_ns6__ArrayOfScheduledWU (367)
/* ns6:ArrayOfScheduledWU */
class SOAP_CMAC ns6__ArrayOfScheduledWU
{
public:
	std::vector<ns6__ScheduledWU * >ScheduledWU;	/* optional element of type ns6:ScheduledWU */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 367; } /* = unique id SOAP_TYPE_ns6__ArrayOfScheduledWU */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfScheduledWU() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfScheduledWU() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfServerInfo
#define SOAP_TYPE_ns6__ArrayOfServerInfo (368)
/* ns6:ArrayOfServerInfo */
class SOAP_CMAC ns6__ArrayOfServerInfo
{
public:
	std::vector<ns6__ServerInfo * >ServerInfo;	/* optional element of type ns6:ServerInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 368; } /* = unique id SOAP_TYPE_ns6__ArrayOfServerInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfServerInfo() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfServerInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__GVCAjaxGraph
#define SOAP_TYPE__ns6__GVCAjaxGraph (369)
/* ns6:GVCAjaxGraph */
class SOAP_CMAC _ns6__GVCAjaxGraph
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	int *SubGraphId;	/* optional element of type xsd:int */
	bool *SubGraphOnly;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 369; } /* = unique id SOAP_TYPE__ns6__GVCAjaxGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__GVCAjaxGraph() : Name(NULL), GraphName(NULL), SubGraphId(NULL), SubGraphOnly(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__GVCAjaxGraph() { }
};
#endif

#ifndef SOAP_TYPE__ns6__GVCAjaxGraphResponse
#define SOAP_TYPE__ns6__GVCAjaxGraphResponse (370)
/* ns6:GVCAjaxGraphResponse */
class SOAP_CMAC _ns6__GVCAjaxGraphResponse
{
public:
	std::wstring *Name;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	std::wstring *GraphType;	/* optional element of type xsd:string */
	int *SubGraphId;	/* optional element of type xsd:int */
	bool *SubGraphOnly;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 370; } /* = unique id SOAP_TYPE__ns6__GVCAjaxGraphResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__GVCAjaxGraphResponse() : Name(NULL), GraphName(NULL), GraphType(NULL), SubGraphId(NULL), SubGraphOnly(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__GVCAjaxGraphResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAbort
#define SOAP_TYPE__ns6__WUAbort (371)
/* ns6:WUAbort */
class SOAP_CMAC _ns6__WUAbort
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 371; } /* = unique id SOAP_TYPE__ns6__WUAbort */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAbort() : Wuids(NULL), BlockTillFinishTimer(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAbort() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAbortResponse
#define SOAP_TYPE__ns6__WUAbortResponse (372)
/* ns6:WUAbortResponse */
class SOAP_CMAC _ns6__WUAbortResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 372; } /* = unique id SOAP_TYPE__ns6__WUAbortResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAbortResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAbortResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAction
#define SOAP_TYPE__ns6__WUAction (373)
/* ns6:WUAction */
class SOAP_CMAC _ns6__WUAction
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	enum ns6__ECLWUActions *WUActionType;	/* optional element of type ns6:ECLWUActions */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *Test;	/* optional element of type xsd:string */
	std::wstring *CurrentPage;	/* optional element of type xsd:string */
	std::wstring *PageSize;	/* optional element of type xsd:string */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	std::wstring *EventServer;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *PageFrom;	/* optional element of type xsd:string */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 373; } /* = unique id SOAP_TYPE__ns6__WUAction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAction() : Wuids(NULL), WUActionType(NULL), Cluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), ECL(NULL), Jobname(NULL), Test(NULL), CurrentPage(NULL), PageSize(NULL), Sortby(NULL), Descending((bool)0), EventServer(NULL), EventName(NULL), PageFrom(NULL), BlockTillFinishTimer(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAction() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUActionResponse
#define SOAP_TYPE__ns6__WUActionResponse (374)
/* ns6:WUActionResponse */
class SOAP_CMAC _ns6__WUActionResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 374; } /* = unique id SOAP_TYPE__ns6__WUActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUActionResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAddLocalFileToWorkunit
#define SOAP_TYPE__ns6__WUAddLocalFileToWorkunit (375)
/* ns6:WUAddLocalFileToWorkunit */
class SOAP_CMAC _ns6__WUAddLocalFileToWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Val;	/* optional element of type xsd:string */
	std::wstring *DefVal;	/* optional element of type xsd:string */
	int *Type;	/* optional element of type xsd:int */
	int *Length;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 375; } /* = unique id SOAP_TYPE__ns6__WUAddLocalFileToWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAddLocalFileToWorkunit() : Wuid(NULL), Name(NULL), Val(NULL), DefVal(NULL), Type(NULL), Length(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAddLocalFileToWorkunit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAddLocalFileToWorkunitResponse
#define SOAP_TYPE__ns6__WUAddLocalFileToWorkunitResponse (376)
/* ns6:WUAddLocalFileToWorkunitResponse */
class SOAP_CMAC _ns6__WUAddLocalFileToWorkunitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 376; } /* = unique id SOAP_TYPE__ns6__WUAddLocalFileToWorkunitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAddLocalFileToWorkunitResponse() : Exceptions(NULL), Wuid(NULL), Name(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAddLocalFileToWorkunitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCDebug
#define SOAP_TYPE__ns6__WUCDebug (377)
/* ns6:WUCDebug */
class SOAP_CMAC _ns6__WUCDebug
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Command;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 377; } /* = unique id SOAP_TYPE__ns6__WUCDebug */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCDebug() : Wuid(NULL), Command(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCDebug() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDebugResponse
#define SOAP_TYPE__ns6__WUDebugResponse (378)
/* ns6:WUDebugResponse */
class SOAP_CMAC _ns6__WUDebugResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 378; } /* = unique id SOAP_TYPE__ns6__WUDebugResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDebugResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDebugResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCheckFeatures
#define SOAP_TYPE__ns6__WUCheckFeatures (379)
/* ns6:WUCheckFeatures */
class SOAP_CMAC _ns6__WUCheckFeatures
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 379; } /* = unique id SOAP_TYPE__ns6__WUCheckFeatures */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCheckFeatures() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCheckFeatures() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCheckFeaturesResponse
#define SOAP_TYPE__ns6__WUCheckFeaturesResponse (380)
/* ns6:WUCheckFeaturesResponse */
class SOAP_CMAC _ns6__WUCheckFeaturesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	int *BuildVersionMajor;	/* optional element of type xsd:int */
	int *BuildVersionMinor;	/* optional element of type xsd:int */
	int *BuildVersionPoint;	/* optional element of type xsd:int */
	unsigned int *maxRequestEntityLength;	/* optional element of type xsd:unsignedInt */
	ns6__DeploymentFeatures *Deployment;	/* optional element of type ns6:DeploymentFeatures */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 380; } /* = unique id SOAP_TYPE__ns6__WUCheckFeaturesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCheckFeaturesResponse() : Exceptions(NULL), BuildVersionMajor(NULL), BuildVersionMinor(NULL), BuildVersionPoint(NULL), maxRequestEntityLength(NULL), Deployment(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCheckFeaturesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueLOG
#define SOAP_TYPE__ns6__WUClusterJobQueueLOG (381)
/* ns6:WUClusterJobQueueLOG */
class SOAP_CMAC _ns6__WUClusterJobQueueLOG
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 381; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueLOG */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueLOG() : Cluster(NULL), StartDate(NULL), EndDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueLOG() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueLOGResponse
#define SOAP_TYPE__ns6__WUClusterJobQueueLOGResponse (382)
/* ns6:WUClusterJobQueueLOGResponse */
class SOAP_CMAC _ns6__WUClusterJobQueueLOGResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 382; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueLOGResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueLOGResponse() : Exceptions(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueLOGResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueXLS
#define SOAP_TYPE__ns6__WUClusterJobQueueXLS (383)
/* ns6:WUClusterJobQueueXLS */
class SOAP_CMAC _ns6__WUClusterJobQueueXLS
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ShowType;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 383; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueXLS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueXLS() : Cluster(NULL), StartDate(NULL), EndDate(NULL), ShowType(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueXLS() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueXLSResponse
#define SOAP_TYPE__ns6__WUClusterJobQueueXLSResponse (384)
/* ns6:WUClusterJobQueueXLSResponse */
class SOAP_CMAC _ns6__WUClusterJobQueueXLSResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 384; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueXLSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueXLSResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueXLSResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobSummaryXLS
#define SOAP_TYPE__ns6__WUClusterJobSummaryXLS (385)
/* ns6:WUClusterJobSummaryXLS */
class SOAP_CMAC _ns6__WUClusterJobSummaryXLS
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	bool *ShowAll;	/* optional element of type xsd:boolean */
	std::wstring *BusinessStartTime;	/* optional element of type xsd:string */
	std::wstring *BusinessEndTime;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 385; } /* = unique id SOAP_TYPE__ns6__WUClusterJobSummaryXLS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobSummaryXLS() : Cluster(NULL), StartDate(NULL), EndDate(NULL), ShowAll(NULL), BusinessStartTime(NULL), BusinessEndTime(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobSummaryXLS() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobSummaryXLSResponse
#define SOAP_TYPE__ns6__WUClusterJobSummaryXLSResponse (386)
/* ns6:WUClusterJobSummaryXLSResponse */
class SOAP_CMAC _ns6__WUClusterJobSummaryXLSResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 386; } /* = unique id SOAP_TYPE__ns6__WUClusterJobSummaryXLSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobSummaryXLSResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobSummaryXLSResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobXLS
#define SOAP_TYPE__ns6__WUClusterJobXLS (387)
/* ns6:WUClusterJobXLS */
class SOAP_CMAC _ns6__WUClusterJobXLS
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	bool *ShowAll;	/* optional element of type xsd:boolean */
	std::wstring *BusinessStartTime;	/* optional element of type xsd:string */
	std::wstring *BusinessEndTime;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 387; } /* = unique id SOAP_TYPE__ns6__WUClusterJobXLS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobXLS() : Cluster(NULL), StartDate(NULL), EndDate(NULL), ShowAll(NULL), BusinessStartTime(NULL), BusinessEndTime(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobXLS() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobXLSResponse
#define SOAP_TYPE__ns6__WUClusterJobXLSResponse (388)
/* ns6:WUClusterJobXLSResponse */
class SOAP_CMAC _ns6__WUClusterJobXLSResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 388; } /* = unique id SOAP_TYPE__ns6__WUClusterJobXLSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobXLSResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobXLSResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCompileECL
#define SOAP_TYPE__ns6__WUCompileECL (389)
/* ns6:WUCompileECL */
class SOAP_CMAC _ns6__WUCompileECL
{
public:
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	bool IncludeDependencies;	/* optional element of type xsd:boolean */
	bool *IncludeComplexity;	/* optional element of type xsd:boolean */
	int TimeToWait;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 389; } /* = unique id SOAP_TYPE__ns6__WUCompileECL */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCompileECL() : ECL(NULL), ModuleName(NULL), AttributeName(NULL), Queue(NULL), Cluster(NULL), Snapshot(NULL), IncludeDependencies((bool)0), IncludeComplexity(NULL), TimeToWait(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCompileECL() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCompileECLResponse_Dependencies
#define SOAP_TYPE__ns6__WUCompileECLResponse_Dependencies (825)
/* ns6:WUCompileECLResponse-Dependencies */
class SOAP_CMAC _ns6__WUCompileECLResponse_Dependencies
{
public:
	std::vector<ns6__WUECLAttribute * >ECLAttribute;	/* optional element of type ns6:WUECLAttribute */
public:
	virtual int soap_type() const { return 825; } /* = unique id SOAP_TYPE__ns6__WUCompileECLResponse_Dependencies */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCompileECLResponse_Dependencies()  { this->soap_default(NULL); }
	virtual ~_ns6__WUCompileECLResponse_Dependencies() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCompileECLResponse
#define SOAP_TYPE__ns6__WUCompileECLResponse (390)
/* ns6:WUCompileECLResponse */
class SOAP_CMAC _ns6__WUCompileECLResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Complexity;	/* optional element of type xsd:string */
	ns6__ArrayOfECLException *Errors;	/* optional element of type ns6:ArrayOfECLException */
	_ns6__WUCompileECLResponse_Dependencies *Dependencies;	/* optional element of type ns6:WUCompileECLResponse-Dependencies */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 390; } /* = unique id SOAP_TYPE__ns6__WUCompileECLResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCompileECLResponse() : Exceptions(NULL), Complexity(NULL), Errors(NULL), Dependencies(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCompileECLResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyLogicalFiles
#define SOAP_TYPE__ns6__WUCopyLogicalFiles (391)
/* ns6:WUCopyLogicalFiles */
class SOAP_CMAC _ns6__WUCopyLogicalFiles
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	bool *CopyLocal;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 391; } /* = unique id SOAP_TYPE__ns6__WUCopyLogicalFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyLogicalFiles() : Wuid(NULL), Cluster(NULL), CopyLocal(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyLogicalFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyLogicalFilesResponse_ClusterFiles
#define SOAP_TYPE__ns6__WUCopyLogicalFilesResponse_ClusterFiles (829)
/* ns6:WUCopyLogicalFilesResponse-ClusterFiles */
class SOAP_CMAC _ns6__WUCopyLogicalFilesResponse_ClusterFiles
{
public:
	std::vector<ns6__WUCopyLogicalClusterFileSections * >Cluster;	/* optional element of type ns6:WUCopyLogicalClusterFileSections */
public:
	virtual int soap_type() const { return 829; } /* = unique id SOAP_TYPE__ns6__WUCopyLogicalFilesResponse_ClusterFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyLogicalFilesResponse_ClusterFiles()  { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyLogicalFilesResponse_ClusterFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyLogicalFilesResponse
#define SOAP_TYPE__ns6__WUCopyLogicalFilesResponse (392)
/* ns6:WUCopyLogicalFilesResponse */
class SOAP_CMAC _ns6__WUCopyLogicalFilesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	_ns6__WUCopyLogicalFilesResponse_ClusterFiles *ClusterFiles;	/* optional element of type ns6:WUCopyLogicalFilesResponse-ClusterFiles */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 392; } /* = unique id SOAP_TYPE__ns6__WUCopyLogicalFilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyLogicalFilesResponse() : Exceptions(NULL), Wuid(NULL), ClusterFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyLogicalFilesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyQuerySet
#define SOAP_TYPE__ns6__WUCopyQuerySet (393)
/* ns6:WUCopyQuerySet */
class SOAP_CMAC _ns6__WUCopyQuerySet
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Target;	/* optional element of type xsd:string */
	bool ActiveOnly;	/* optional element of type xsd:boolean */
	bool CloneActiveState;	/* optional element of type xsd:boolean */
	bool AllowForeignFiles;	/* optional element of type xsd:boolean */
	std::wstring *DfsServer;	/* optional element of type xsd:string */
	bool CopyFiles;	/* optional element of type xsd:boolean */
	bool OverwriteDfs;	/* optional element of type xsd:boolean */
	std::wstring *SourceProcess;	/* optional element of type xsd:string */
	bool UpdateSuperFiles;	/* optional element of type xsd:boolean */
	bool UpdateCloneFrom;	/* optional element of type xsd:boolean */
	bool AppendCluster;	/* optional element of type xsd:boolean */
	bool IncludeFileErrors;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 393; } /* = unique id SOAP_TYPE__ns6__WUCopyQuerySet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyQuerySet() : Source(NULL), Target(NULL), ActiveOnly((bool)0), CloneActiveState((bool)0), AllowForeignFiles((bool)0), DfsServer(NULL), CopyFiles((bool)0), OverwriteDfs((bool)0), SourceProcess(NULL), UpdateSuperFiles((bool)0), UpdateCloneFrom((bool)0), AppendCluster((bool)0), IncludeFileErrors((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyQuerySet() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyQuerySetResponse_CopiedQueries
#define SOAP_TYPE__ns6__WUCopyQuerySetResponse_CopiedQueries (833)
/* ns6:WUCopyQuerySetResponse-CopiedQueries */
class SOAP_CMAC _ns6__WUCopyQuerySetResponse_CopiedQueries
{
public:
	std::vector<std::wstring * >QueryId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 833; } /* = unique id SOAP_TYPE__ns6__WUCopyQuerySetResponse_CopiedQueries */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyQuerySetResponse_CopiedQueries()  { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyQuerySetResponse_CopiedQueries() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyQuerySetResponse_ExistingQueries
#define SOAP_TYPE__ns6__WUCopyQuerySetResponse_ExistingQueries (835)
/* ns6:WUCopyQuerySetResponse-ExistingQueries */
class SOAP_CMAC _ns6__WUCopyQuerySetResponse_ExistingQueries
{
public:
	std::vector<std::wstring * >QueryId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 835; } /* = unique id SOAP_TYPE__ns6__WUCopyQuerySetResponse_ExistingQueries */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyQuerySetResponse_ExistingQueries()  { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyQuerySetResponse_ExistingQueries() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyQuerySetResponse_FileErrors
#define SOAP_TYPE__ns6__WUCopyQuerySetResponse_FileErrors (837)
/* ns6:WUCopyQuerySetResponse-FileErrors */
class SOAP_CMAC _ns6__WUCopyQuerySetResponse_FileErrors
{
public:
	std::vector<ns6__LogicalFileError * >File;	/* optional element of type ns6:LogicalFileError */
public:
	virtual int soap_type() const { return 837; } /* = unique id SOAP_TYPE__ns6__WUCopyQuerySetResponse_FileErrors */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyQuerySetResponse_FileErrors()  { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyQuerySetResponse_FileErrors() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyQuerySetResponse
#define SOAP_TYPE__ns6__WUCopyQuerySetResponse (394)
/* ns6:WUCopyQuerySetResponse */
class SOAP_CMAC _ns6__WUCopyQuerySetResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	_ns6__WUCopyQuerySetResponse_CopiedQueries *CopiedQueries;	/* optional element of type ns6:WUCopyQuerySetResponse-CopiedQueries */
	_ns6__WUCopyQuerySetResponse_ExistingQueries *ExistingQueries;	/* optional element of type ns6:WUCopyQuerySetResponse-ExistingQueries */
	_ns6__WUCopyQuerySetResponse_FileErrors *FileErrors;	/* optional element of type ns6:WUCopyQuerySetResponse-FileErrors */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 394; } /* = unique id SOAP_TYPE__ns6__WUCopyQuerySetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyQuerySetResponse() : Exceptions(NULL), CopiedQueries(NULL), ExistingQueries(NULL), FileErrors(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyQuerySetResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreate
#define SOAP_TYPE__ns6__WUCreate (395)
/* ns6:WUCreate */
class SOAP_CMAC _ns6__WUCreate
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 395; } /* = unique id SOAP_TYPE__ns6__WUCreate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreate() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreate() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreateResponse
#define SOAP_TYPE__ns6__WUCreateResponse (396)
/* ns6:WUCreateResponse */
class SOAP_CMAC _ns6__WUCreateResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 396; } /* = unique id SOAP_TYPE__ns6__WUCreateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreateResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreateAndUpdate
#define SOAP_TYPE__ns6__WUCreateAndUpdate (397)
/* ns6:WUCreateAndUpdate */
class SOAP_CMAC _ns6__WUCreateAndUpdate
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *State;	/* optional element of type xsd:int */
	int *StateOrig;	/* optional element of type xsd:int */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *JobnameOrig;	/* optional element of type xsd:string */
	std::wstring *QueryText;	/* optional element of type xsd:string */
	int *Action;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *DescriptionOrig;	/* optional element of type xsd:string */
	bool *AddDrilldownFields;	/* optional element of type xsd:boolean */
	int *ResultLimit;	/* optional element of type xsd:int */
	bool *Protected;	/* optional element of type xsd:boolean */
	bool *ProtectedOrig;	/* optional element of type xsd:boolean */
	int *PriorityClass;	/* optional element of type xsd:int */
	int *PriorityLevel;	/* optional element of type xsd:int */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *ScopeOrig;	/* optional element of type xsd:string */
	std::wstring *ClusterSelection;	/* optional element of type xsd:string */
	std::wstring *ClusterOrig;	/* optional element of type xsd:string */
	std::wstring *XmlParams;	/* optional element of type xsd:string */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	std::wstring *QueryMainDefinition;	/* optional element of type xsd:string */
	ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 397; } /* = unique id SOAP_TYPE__ns6__WUCreateAndUpdate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreateAndUpdate() : Wuid(NULL), State(NULL), StateOrig(NULL), Jobname(NULL), JobnameOrig(NULL), QueryText(NULL), Action(NULL), Description(NULL), DescriptionOrig(NULL), AddDrilldownFields(NULL), ResultLimit(NULL), Protected(NULL), ProtectedOrig(NULL), PriorityClass(NULL), PriorityLevel(NULL), Scope(NULL), ScopeOrig(NULL), ClusterSelection(NULL), ClusterOrig(NULL), XmlParams(NULL), ThorSlaveIP(NULL), QueryMainDefinition(NULL), DebugValues(NULL), ApplicationValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreateAndUpdate() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUUpdateResponse
#define SOAP_TYPE__ns6__WUUpdateResponse (398)
/* ns6:WUUpdateResponse */
class SOAP_CMAC _ns6__WUUpdateResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 398; } /* = unique id SOAP_TYPE__ns6__WUUpdateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUUpdateResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUUpdateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreateZAPInfo
#define SOAP_TYPE__ns6__WUCreateZAPInfo (399)
/* ns6:WUCreateZAPInfo */
class SOAP_CMAC _ns6__WUCreateZAPInfo
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *ESPIPAddress;	/* optional element of type xsd:string */
	std::wstring *ThorIPAddress;	/* optional element of type xsd:string */
	std::wstring *BuildVersion;	/* optional element of type xsd:string */
	std::wstring *ProblemDescription;	/* optional element of type xsd:string */
	std::wstring *WhatChanged;	/* optional element of type xsd:string */
	std::wstring *WhereSlow;	/* optional element of type xsd:string */
	std::wstring *Password;	/* optional element of type xsd:string */
	std::wstring *ZAPFileName;	/* optional element of type xsd:string */
	bool IncludeThorSlaveLog;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 399; } /* = unique id SOAP_TYPE__ns6__WUCreateZAPInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreateZAPInfo() : Wuid(NULL), ESPIPAddress(NULL), ThorIPAddress(NULL), BuildVersion(NULL), ProblemDescription(NULL), WhatChanged(NULL), WhereSlow(NULL), Password(NULL), ZAPFileName(NULL), IncludeThorSlaveLog((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreateZAPInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreateZAPInfoResponse
#define SOAP_TYPE__ns6__WUCreateZAPInfoResponse (400)
/* ns6:WUCreateZAPInfoResponse */
class SOAP_CMAC _ns6__WUCreateZAPInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 400; } /* = unique id SOAP_TYPE__ns6__WUCreateZAPInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreateZAPInfoResponse() : Exceptions(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreateZAPInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDelete
#define SOAP_TYPE__ns6__WUDelete (401)
/* ns6:WUDelete */
class SOAP_CMAC _ns6__WUDelete
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 401; } /* = unique id SOAP_TYPE__ns6__WUDelete */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDelete() : Wuids(NULL), BlockTillFinishTimer(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDelete() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDeleteResponse
#define SOAP_TYPE__ns6__WUDeleteResponse (402)
/* ns6:WUDeleteResponse */
class SOAP_CMAC _ns6__WUDeleteResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 402; } /* = unique id SOAP_TYPE__ns6__WUDeleteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDeleteResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDeleteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDeployWorkunit
#define SOAP_TYPE__ns6__WUDeployWorkunit (403)
/* ns6:WUDeployWorkunit */
class SOAP_CMAC _ns6__WUDeployWorkunit
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	std::wstring *ObjType;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	xsd__base64Binary *Object;	/* optional element of type xsd:base64Binary */
	int *ResultLimit;	/* optional element of type xsd:int */
	std::wstring *QueryMainDefinition;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	ns6__ArrayOfNamedValue *DebugValues;	/* optional element of type ns6:ArrayOfNamedValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 403; } /* = unique id SOAP_TYPE__ns6__WUDeployWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDeployWorkunit() : Cluster(NULL), Name(NULL), Wait(0), ObjType(NULL), FileName(NULL), Object(NULL), ResultLimit(NULL), QueryMainDefinition(NULL), Snapshot(NULL), DebugValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDeployWorkunit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDeployWorkunitResponse
#define SOAP_TYPE__ns6__WUDeployWorkunitResponse (404)
/* ns6:WUDeployWorkunitResponse */
class SOAP_CMAC _ns6__WUDeployWorkunitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 404; } /* = unique id SOAP_TYPE__ns6__WUDeployWorkunitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDeployWorkunitResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDeployWorkunitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUExport
#define SOAP_TYPE__ns6__WUExport (405)
/* ns6:WUExport */
class SOAP_CMAC _ns6__WUExport
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 405; } /* = unique id SOAP_TYPE__ns6__WUExport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUExport() : Cluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), Jobname(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUExport() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUExportResponse
#define SOAP_TYPE__ns6__WUExportResponse (406)
/* ns6:WUExportResponse */
class SOAP_CMAC _ns6__WUExportResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *ExportData;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 406; } /* = unique id SOAP_TYPE__ns6__WUExportResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUExportResponse() : Exceptions(NULL), ExportData(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUExportResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUFile
#define SOAP_TYPE__ns6__WUFile (407)
/* ns6:WUFile */
class SOAP_CMAC _ns6__WUFile
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Option;	/* optional element of type xsd:int */
	std::wstring *SlaveIP;	/* optional element of type xsd:string */
	std::wstring *IPAddress;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *Query;	/* optional element of type xsd:string */
	std::wstring *Process;	/* optional element of type xsd:string */
	std::wstring *ClusterGroup;	/* optional element of type xsd:string */
	std::wstring *LogDate;	/* optional element of type xsd:string */
	int SlaveNumber;	/* optional element of type xsd:int */
	LONG64 *SizeLimit;	/* optional element of type xsd:long */
	std::wstring *PlainText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 407; } /* = unique id SOAP_TYPE__ns6__WUFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUFile() : Name(NULL), Wuid(NULL), Type(NULL), Option(NULL), SlaveIP(NULL), IPAddress(NULL), Description(NULL), QuerySet(NULL), Query(NULL), Process(NULL), ClusterGroup(NULL), LogDate(NULL), SlaveNumber(0), SizeLimit(NULL), PlainText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUFile() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WULogFileResponse
#define SOAP_TYPE__ns6__WULogFileResponse (408)
/* ns6:WULogFileResponse */
class SOAP_CMAC _ns6__WULogFileResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *QueryName;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *DaliServer;	/* optional element of type xsd:string */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 408; } /* = unique id SOAP_TYPE__ns6__WULogFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WULogFileResponse() : Exceptions(NULL), Wuid(NULL), QuerySet(NULL), QueryName(NULL), QueryId(NULL), FileName(NULL), DaliServer(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WULogFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUFullResult
#define SOAP_TYPE__ns6__WUFullResult (409)
/* ns6:WUFullResult */
class SOAP_CMAC _ns6__WUFullResult
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	bool NoRootTag;	/* optional element of type xsd:boolean */
	enum ns6__WUExceptionSeverity ExceptionSeverity;	/* optional element of type ns6:WUExceptionSeverity */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 409; } /* = unique id SOAP_TYPE__ns6__WUFullResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUFullResult() : Wuid(NULL), NoRootTag((bool)0), ExceptionSeverity((enum ns6__WUExceptionSeverity)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUFullResult() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUFullResultResponse
#define SOAP_TYPE__ns6__WUFullResultResponse (410)
/* ns6:WUFullResultResponse */
class SOAP_CMAC _ns6__WUFullResultResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Results;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 410; } /* = unique id SOAP_TYPE__ns6__WUFullResultResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUFullResultResponse() : Exceptions(NULL), Wuid(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUFullResultResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGVCGraphInfo
#define SOAP_TYPE__ns6__WUGVCGraphInfo (411)
/* ns6:WUGVCGraphInfo */
class SOAP_CMAC _ns6__WUGVCGraphInfo
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	int *SubgraphId;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 411; } /* = unique id SOAP_TYPE__ns6__WUGVCGraphInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGVCGraphInfo() : Wuid(NULL), Name(NULL), GID(NULL), BatchWU(NULL), SubgraphId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGVCGraphInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGVCGraphInfoResponse
#define SOAP_TYPE__ns6__WUGVCGraphInfoResponse (412)
/* ns6:WUGVCGraphInfoResponse */
class SOAP_CMAC _ns6__WUGVCGraphInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	bool *Running;	/* optional element of type xsd:boolean */
	std::wstring *TheGraph;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 412; } /* = unique id SOAP_TYPE__ns6__WUGVCGraphInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGVCGraphInfoResponse() : Exceptions(NULL), Wuid(NULL), Name(NULL), GID(NULL), Running(NULL), TheGraph(NULL), BatchWU(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGVCGraphInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetArchiveFile
#define SOAP_TYPE__ns6__WUGetArchiveFile (413)
/* ns6:WUGetArchiveFile */
class SOAP_CMAC _ns6__WUGetArchiveFile
{
public:
	std::wstring *WUID;	/* optional element of type xsd:string */
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 413; } /* = unique id SOAP_TYPE__ns6__WUGetArchiveFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetArchiveFile() : WUID(NULL), ModuleName(NULL), FileName(NULL), Path(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetArchiveFile() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetArchiveFileResponse
#define SOAP_TYPE__ns6__WUGetArchiveFileResponse (414)
/* ns6:WUGetArchiveFileResponse */
class SOAP_CMAC _ns6__WUGetArchiveFileResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *File;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 414; } /* = unique id SOAP_TYPE__ns6__WUGetArchiveFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetArchiveFileResponse() : Exceptions(NULL), File(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetArchiveFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetDependancyTrees
#define SOAP_TYPE__ns6__WUGetDependancyTrees (415)
/* ns6:WUGetDependancyTrees */
class SOAP_CMAC _ns6__WUGetDependancyTrees
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	std::wstring *Items;	/* optional element of type xsd:string */
	std::wstring *TimeoutMilliSec;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 415; } /* = unique id SOAP_TYPE__ns6__WUGetDependancyTrees */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetDependancyTrees() : Cluster(NULL), Queue(NULL), Snapshot(NULL), Items(NULL), TimeoutMilliSec(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetDependancyTrees() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetDependancyTreesResponse
#define SOAP_TYPE__ns6__WUGetDependancyTreesResponse (416)
/* ns6:WUGetDependancyTreesResponse */
class SOAP_CMAC _ns6__WUGetDependancyTreesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfECLException *Errors;	/* optional element of type ns6:ArrayOfECLException */
	xsd__base64Binary *DependancyTrees;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 416; } /* = unique id SOAP_TYPE__ns6__WUGetDependancyTreesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetDependancyTreesResponse() : Exceptions(NULL), Errors(NULL), DependancyTrees(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetDependancyTreesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetGraph
#define SOAP_TYPE__ns6__WUGetGraph (417)
/* ns6:WUGetGraph */
class SOAP_CMAC _ns6__WUGetGraph
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	std::wstring *SubGraphId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 417; } /* = unique id SOAP_TYPE__ns6__WUGetGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetGraph() : Wuid(NULL), GraphName(NULL), SubGraphId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetGraph() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetGraphResponse
#define SOAP_TYPE__ns6__WUGetGraphResponse (418)
/* ns6:WUGetGraphResponse */
class SOAP_CMAC _ns6__WUGetGraphResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfECLGraphEx *Graphs;	/* optional element of type ns6:ArrayOfECLGraphEx */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 418; } /* = unique id SOAP_TYPE__ns6__WUGetGraphResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetGraphResponse() : Exceptions(NULL), Graphs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetGraphResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetGraphNameAndTypes
#define SOAP_TYPE__ns6__WUGetGraphNameAndTypes (419)
/* ns6:WUGetGraphNameAndTypes */
class SOAP_CMAC _ns6__WUGetGraphNameAndTypes
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 419; } /* = unique id SOAP_TYPE__ns6__WUGetGraphNameAndTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetGraphNameAndTypes() : Wuid(NULL), Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetGraphNameAndTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetGraphNameAndTypesResponse_GraphNameAndTypes
#define SOAP_TYPE__ns6__WUGetGraphNameAndTypesResponse_GraphNameAndTypes (843)
/* ns6:WUGetGraphNameAndTypesResponse-GraphNameAndTypes */
class SOAP_CMAC _ns6__WUGetGraphNameAndTypesResponse_GraphNameAndTypes
{
public:
	std::vector<ns6__NameAndType * >GraphNameAndType;	/* optional element of type ns6:NameAndType */
public:
	virtual int soap_type() const { return 843; } /* = unique id SOAP_TYPE__ns6__WUGetGraphNameAndTypesResponse_GraphNameAndTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetGraphNameAndTypesResponse_GraphNameAndTypes()  { this->soap_default(NULL); }
	virtual ~_ns6__WUGetGraphNameAndTypesResponse_GraphNameAndTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetGraphNameAndTypesResponse
#define SOAP_TYPE__ns6__WUGetGraphNameAndTypesResponse (420)
/* ns6:WUGetGraphNameAndTypesResponse */
class SOAP_CMAC _ns6__WUGetGraphNameAndTypesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	_ns6__WUGetGraphNameAndTypesResponse_GraphNameAndTypes *GraphNameAndTypes;	/* optional element of type ns6:WUGetGraphNameAndTypesResponse-GraphNameAndTypes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 420; } /* = unique id SOAP_TYPE__ns6__WUGetGraphNameAndTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetGraphNameAndTypesResponse() : Exceptions(NULL), GraphNameAndTypes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetGraphNameAndTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetNumFileToCopy
#define SOAP_TYPE__ns6__WUGetNumFileToCopy (421)
/* ns6:WUGetNumFileToCopy */
class SOAP_CMAC _ns6__WUGetNumFileToCopy
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *PageStartFrom;	/* optional element of type xsd:long */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 421; } /* = unique id SOAP_TYPE__ns6__WUGetNumFileToCopy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetNumFileToCopy() : ClusterName(NULL), PageSize(NULL), PageStartFrom(NULL), Sortby(NULL), Descending((bool)0), CacheHint(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetNumFileToCopy() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetNumFileToCopyResponse_Endpoints
#define SOAP_TYPE__ns6__WUGetNumFileToCopyResponse_Endpoints (847)
/* ns6:WUGetNumFileToCopyResponse-Endpoints */
class SOAP_CMAC _ns6__WUGetNumFileToCopyResponse_Endpoints
{
public:
	std::vector<ns6__ClusterEndpoint * >Endpoint;	/* optional element of type ns6:ClusterEndpoint */
public:
	virtual int soap_type() const { return 847; } /* = unique id SOAP_TYPE__ns6__WUGetNumFileToCopyResponse_Endpoints */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetNumFileToCopyResponse_Endpoints()  { this->soap_default(NULL); }
	virtual ~_ns6__WUGetNumFileToCopyResponse_Endpoints() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetNumFileToCopyResponse
#define SOAP_TYPE__ns6__WUGetNumFileToCopyResponse (422)
/* ns6:WUGetNumFileToCopyResponse */
class SOAP_CMAC _ns6__WUGetNumFileToCopyResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	_ns6__WUGetNumFileToCopyResponse_Endpoints *Endpoints;	/* optional element of type ns6:WUGetNumFileToCopyResponse-Endpoints */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	LONG64 *Total;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 422; } /* = unique id SOAP_TYPE__ns6__WUGetNumFileToCopyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetNumFileToCopyResponse() : Exceptions(NULL), Endpoints(NULL), CacheHint(NULL), Total(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetNumFileToCopyResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetStats
#define SOAP_TYPE__ns6__WUGetStats (423)
/* ns6:WUGetStats */
class SOAP_CMAC _ns6__WUGetStats
{
public:
	std::wstring *WUID;	/* optional element of type xsd:string */
	std::wstring *CreatorType;	/* optional element of type xsd:string */
	std::wstring *Creator;	/* optional element of type xsd:string */
	std::wstring *ScopeType;	/* optional element of type xsd:string */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *Kind;	/* optional element of type xsd:string */
	std::wstring *Measure;	/* optional element of type xsd:string */
	unsigned int *MinScopeDepth;	/* optional element of type xsd:unsignedInt */
	unsigned int *MaxScopeDepth;	/* optional element of type xsd:unsignedInt */
	bool *IncludeGraphs;	/* optional element of type xsd:boolean */
	bool *CreateDescriptions;	/* optional element of type xsd:boolean */
	LONG64 *MinValue;	/* optional element of type xsd:long */
	LONG64 *MaxValue;	/* optional element of type xsd:long */
	std::wstring *Filter;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 423; } /* = unique id SOAP_TYPE__ns6__WUGetStats */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetStats() : WUID(NULL), CreatorType(NULL), Creator(NULL), ScopeType(NULL), Scope(NULL), Kind(NULL), Measure(NULL), MinScopeDepth(NULL), MaxScopeDepth(NULL), IncludeGraphs(NULL), CreateDescriptions(NULL), MinValue(NULL), MaxValue(NULL), Filter(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetStats() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetStatsResponse
#define SOAP_TYPE__ns6__WUGetStatsResponse (424)
/* ns6:WUGetStatsResponse */
class SOAP_CMAC _ns6__WUGetStatsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *WUID;	/* optional element of type xsd:string */
	ns6__ArrayOfWUStatisticItem *Statistics;	/* optional element of type ns6:ArrayOfWUStatisticItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 424; } /* = unique id SOAP_TYPE__ns6__WUGetStatsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetStatsResponse() : Exceptions(NULL), WUID(NULL), Statistics(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetStatsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetZAPInfo
#define SOAP_TYPE__ns6__WUGetZAPInfo (425)
/* ns6:WUGetZAPInfo */
class SOAP_CMAC _ns6__WUGetZAPInfo
{
public:
	std::wstring *WUID;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 425; } /* = unique id SOAP_TYPE__ns6__WUGetZAPInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetZAPInfo() : WUID(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetZAPInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetZAPInfoResponse
#define SOAP_TYPE__ns6__WUGetZAPInfoResponse (426)
/* ns6:WUGetZAPInfoResponse */
class SOAP_CMAC _ns6__WUGetZAPInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *WUID;	/* optional element of type xsd:string */
	std::wstring *ESPIPAddress;	/* optional element of type xsd:string */
	std::wstring *ThorIPAddress;	/* optional element of type xsd:string */
	std::wstring *BuildVersion;	/* optional element of type xsd:string */
	std::wstring *Archive;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 426; } /* = unique id SOAP_TYPE__ns6__WUGetZAPInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetZAPInfoResponse() : Exceptions(NULL), WUID(NULL), ESPIPAddress(NULL), ThorIPAddress(NULL), BuildVersion(NULL), Archive(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetZAPInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphInfo
#define SOAP_TYPE__ns6__WUGraphInfo (427)
/* ns6:WUGraphInfo */
class SOAP_CMAC _ns6__WUGraphInfo
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 427; } /* = unique id SOAP_TYPE__ns6__WUGraphInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphInfo() : Wuid(NULL), Name(NULL), GID(NULL), BatchWU(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphInfoResponse
#define SOAP_TYPE__ns6__WUGraphInfoResponse (428)
/* ns6:WUGraphInfoResponse */
class SOAP_CMAC _ns6__WUGraphInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	bool *Running;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 428; } /* = unique id SOAP_TYPE__ns6__WUGraphInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphInfoResponse() : Exceptions(NULL), Wuid(NULL), Name(NULL), GID(NULL), BatchWU(NULL), Running(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphTiming
#define SOAP_TYPE__ns6__WUGraphTiming (429)
/* ns6:WUGraphTiming */
class SOAP_CMAC _ns6__WUGraphTiming
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 429; } /* = unique id SOAP_TYPE__ns6__WUGraphTiming */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphTiming() : Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphTiming() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphTimingResponse
#define SOAP_TYPE__ns6__WUGraphTimingResponse (430)
/* ns6:WUGraphTimingResponse */
class SOAP_CMAC _ns6__WUGraphTimingResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 430; } /* = unique id SOAP_TYPE__ns6__WUGraphTimingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphTimingResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphTimingResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfo
#define SOAP_TYPE__ns6__WUInfo (431)
/* ns6:WUInfo */
class SOAP_CMAC _ns6__WUInfo
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	bool TruncateEclTo64k;	/* optional element of type xsd:boolean */
	std::wstring *Type;	/* optional element of type xsd:string */
	bool IncludeExceptions;	/* optional element of type xsd:boolean */
	bool IncludeGraphs;	/* optional element of type xsd:boolean */
	bool IncludeSourceFiles;	/* optional element of type xsd:boolean */
	bool IncludeResults;	/* optional element of type xsd:boolean */
	bool IncludeResultsViewNames;	/* optional element of type xsd:boolean */
	bool IncludeVariables;	/* optional element of type xsd:boolean */
	bool IncludeTimers;	/* optional element of type xsd:boolean */
	bool IncludeDebugValues;	/* optional element of type xsd:boolean */
	bool IncludeApplicationValues;	/* optional element of type xsd:boolean */
	bool IncludeWorkflows;	/* optional element of type xsd:boolean */
	bool IncludeXmlSchemas;	/* optional element of type xsd:boolean */
	bool IncludeResourceURLs;	/* optional element of type xsd:boolean */
	bool IncludeECL;	/* optional element of type xsd:boolean */
	bool IncludeHelpers;	/* optional element of type xsd:boolean */
	bool IncludeAllowedClusters;	/* optional element of type xsd:boolean */
	bool SuppressResultSchemas;	/* optional element of type xsd:boolean */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 431; } /* = unique id SOAP_TYPE__ns6__WUInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfo() : Wuid(NULL), TruncateEclTo64k((bool)0), Type(NULL), IncludeExceptions((bool)0), IncludeGraphs((bool)0), IncludeSourceFiles((bool)0), IncludeResults((bool)0), IncludeResultsViewNames((bool)0), IncludeVariables((bool)0), IncludeTimers((bool)0), IncludeDebugValues((bool)0), IncludeApplicationValues((bool)0), IncludeWorkflows((bool)0), IncludeXmlSchemas((bool)0), IncludeResourceURLs((bool)0), IncludeECL((bool)0), IncludeHelpers((bool)0), IncludeAllowedClusters((bool)0), SuppressResultSchemas((bool)0), ThorSlaveIP(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfoResponse_ResultViews
#define SOAP_TYPE__ns6__WUInfoResponse_ResultViews (852)
/* ns6:WUInfoResponse-ResultViews */
class SOAP_CMAC _ns6__WUInfoResponse_ResultViews
{
public:
	std::vector<std::wstring * >View;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 852; } /* = unique id SOAP_TYPE__ns6__WUInfoResponse_ResultViews */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfoResponse_ResultViews()  { this->soap_default(NULL); }
	virtual ~_ns6__WUInfoResponse_ResultViews() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfoResponse
#define SOAP_TYPE__ns6__WUInfoResponse (432)
/* ns6:WUInfoResponse */
class SOAP_CMAC _ns6__WUInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	int *AutoRefresh;	/* optional element of type xsd:int */
	bool *CanCompile;	/* optional element of type xsd:boolean */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	_ns6__WUInfoResponse_ResultViews *ResultViews;	/* optional element of type ns6:WUInfoResponse-ResultViews */
	std::wstring *SecMethod;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 432; } /* = unique id SOAP_TYPE__ns6__WUInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfoResponse() : Exceptions(NULL), Workunit(NULL), AutoRefresh(NULL), CanCompile(NULL), ThorSlaveIP(NULL), ResultViews(NULL), SecMethod(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfoDetails
#define SOAP_TYPE__ns6__WUInfoDetails (433)
/* ns6:WUInfoDetails */
class SOAP_CMAC _ns6__WUInfoDetails
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	bool TruncateEclTo64k;	/* optional element of type xsd:boolean */
	std::wstring *Type;	/* optional element of type xsd:string */
	bool IncludeExceptions;	/* optional element of type xsd:boolean */
	bool IncludeGraphs;	/* optional element of type xsd:boolean */
	bool IncludeSourceFiles;	/* optional element of type xsd:boolean */
	bool IncludeResults;	/* optional element of type xsd:boolean */
	bool IncludeResultsViewNames;	/* optional element of type xsd:boolean */
	bool IncludeVariables;	/* optional element of type xsd:boolean */
	bool IncludeTimers;	/* optional element of type xsd:boolean */
	bool IncludeDebugValues;	/* optional element of type xsd:boolean */
	bool IncludeApplicationValues;	/* optional element of type xsd:boolean */
	bool IncludeWorkflows;	/* optional element of type xsd:boolean */
	bool IncludeXmlSchemas;	/* optional element of type xsd:boolean */
	bool IncludeResourceURLs;	/* optional element of type xsd:boolean */
	bool IncludeECL;	/* optional element of type xsd:boolean */
	bool IncludeHelpers;	/* optional element of type xsd:boolean */
	bool IncludeAllowedClusters;	/* optional element of type xsd:boolean */
	bool SuppressResultSchemas;	/* optional element of type xsd:boolean */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 433; } /* = unique id SOAP_TYPE__ns6__WUInfoDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfoDetails() : Wuid(NULL), TruncateEclTo64k((bool)0), Type(NULL), IncludeExceptions((bool)0), IncludeGraphs((bool)0), IncludeSourceFiles((bool)0), IncludeResults((bool)0), IncludeResultsViewNames((bool)0), IncludeVariables((bool)0), IncludeTimers((bool)0), IncludeDebugValues((bool)0), IncludeApplicationValues((bool)0), IncludeWorkflows((bool)0), IncludeXmlSchemas((bool)0), IncludeResourceURLs((bool)0), IncludeECL((bool)0), IncludeHelpers((bool)0), IncludeAllowedClusters((bool)0), SuppressResultSchemas((bool)0), ThorSlaveIP(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUInfoDetails() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUJobList
#define SOAP_TYPE__ns6__WUJobList (434)
/* ns6:WUJobList */
class SOAP_CMAC _ns6__WUJobList
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Process;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	bool *ShowAll;	/* optional element of type xsd:boolean */
	int *BusinessStartHour;	/* optional element of type xsd:int */
	int *BusinessEndHour;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 434; } /* = unique id SOAP_TYPE__ns6__WUJobList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUJobList() : Cluster(NULL), Process(NULL), StartDate(NULL), EndDate(NULL), ShowAll(NULL), BusinessStartHour(NULL), BusinessEndHour(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUJobList() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUJobListResponse
#define SOAP_TYPE__ns6__WUJobListResponse (435)
/* ns6:WUJobListResponse */
class SOAP_CMAC _ns6__WUJobListResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	ns6__ArrayOfECLJob *Jobs;	/* optional element of type ns6:ArrayOfECLJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 435; } /* = unique id SOAP_TYPE__ns6__WUJobListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUJobListResponse() : Exceptions(NULL), StartDate(NULL), EndDate(NULL), Jobs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUJobListResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WULightWeightQuery
#define SOAP_TYPE__ns6__WULightWeightQuery (436)
/* ns6:WULightWeightQuery */
class SOAP_CMAC _ns6__WULightWeightQuery
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	LONG64 *PageStartFrom;	/* optional element of type xsd:long */
	unsigned int *PageSize;	/* optional element of type xsd:unsignedInt */
	std::wstring *SortBy;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 436; } /* = unique id SOAP_TYPE__ns6__WULightWeightQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WULightWeightQuery() : Wuid(NULL), Type(NULL), Cluster(NULL), Owner(NULL), JobName(NULL), StartDate(NULL), EndDate(NULL), State(NULL), ApplicationValues(NULL), PageStartFrom(NULL), PageSize(NULL), SortBy(NULL), Descending((bool)0), CacheHint(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WULightWeightQuery() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WULightWeightQueryResponse
#define SOAP_TYPE__ns6__WULightWeightQueryResponse (437)
/* ns6:WULightWeightQueryResponse */
class SOAP_CMAC _ns6__WULightWeightQueryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	int *NumWUs;	/* optional element of type xsd:int */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	ns6__ArrayOfECLWorkunitLW *Workunits;	/* optional element of type ns6:ArrayOfECLWorkunitLW */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 437; } /* = unique id SOAP_TYPE__ns6__WULightWeightQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WULightWeightQueryResponse() : Exceptions(NULL), NumWUs(NULL), CacheHint(NULL), Workunits(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WULightWeightQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListArchiveFiles
#define SOAP_TYPE__ns6__WUListArchiveFiles (438)
/* ns6:WUListArchiveFiles */
class SOAP_CMAC _ns6__WUListArchiveFiles
{
public:
	std::wstring *WUID;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 438; } /* = unique id SOAP_TYPE__ns6__WUListArchiveFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListArchiveFiles() : WUID(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListArchiveFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListArchiveFilesResponse_ArchiveModules
#define SOAP_TYPE__ns6__WUListArchiveFilesResponse_ArchiveModules (856)
/* ns6:WUListArchiveFilesResponse-ArchiveModules */
class SOAP_CMAC _ns6__WUListArchiveFilesResponse_ArchiveModules
{
public:
	std::vector<ns6__WUArchiveModule * >ArchiveModule;	/* optional element of type ns6:WUArchiveModule */
public:
	virtual int soap_type() const { return 856; } /* = unique id SOAP_TYPE__ns6__WUListArchiveFilesResponse_ArchiveModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListArchiveFilesResponse_ArchiveModules()  { this->soap_default(NULL); }
	virtual ~_ns6__WUListArchiveFilesResponse_ArchiveModules() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListArchiveFilesResponse_Files
#define SOAP_TYPE__ns6__WUListArchiveFilesResponse_Files (858)
/* ns6:WUListArchiveFilesResponse-Files */
class SOAP_CMAC _ns6__WUListArchiveFilesResponse_Files
{
public:
	std::vector<ns6__WUArchiveFile * >File;	/* optional element of type ns6:WUArchiveFile */
public:
	virtual int soap_type() const { return 858; } /* = unique id SOAP_TYPE__ns6__WUListArchiveFilesResponse_Files */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListArchiveFilesResponse_Files()  { this->soap_default(NULL); }
	virtual ~_ns6__WUListArchiveFilesResponse_Files() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListArchiveFilesResponse
#define SOAP_TYPE__ns6__WUListArchiveFilesResponse (439)
/* ns6:WUListArchiveFilesResponse */
class SOAP_CMAC _ns6__WUListArchiveFilesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	_ns6__WUListArchiveFilesResponse_ArchiveModules *ArchiveModules;	/* optional element of type ns6:WUListArchiveFilesResponse-ArchiveModules */
	_ns6__WUListArchiveFilesResponse_Files *Files;	/* optional element of type ns6:WUListArchiveFilesResponse-Files */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 439; } /* = unique id SOAP_TYPE__ns6__WUListArchiveFilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListArchiveFilesResponse() : Exceptions(NULL), ArchiveModules(NULL), Files(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListArchiveFilesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListLocalFileRequired
#define SOAP_TYPE__ns6__WUListLocalFileRequired (440)
/* ns6:WUListLocalFileRequired */
class SOAP_CMAC _ns6__WUListLocalFileRequired
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 440; } /* = unique id SOAP_TYPE__ns6__WUListLocalFileRequired */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListLocalFileRequired() : Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListLocalFileRequired() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListLocalFileRequiredResponse
#define SOAP_TYPE__ns6__WUListLocalFileRequiredResponse (441)
/* ns6:WUListLocalFileRequiredResponse */
class SOAP_CMAC _ns6__WUListLocalFileRequiredResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfLogicalFileUpload *LocalFileUploads;	/* optional element of type ns6:ArrayOfLogicalFileUpload */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 441; } /* = unique id SOAP_TYPE__ns6__WUListLocalFileRequiredResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListLocalFileRequiredResponse() : Exceptions(NULL), LocalFileUploads(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListLocalFileRequiredResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListQueries
#define SOAP_TYPE__ns6__WUListQueries (442)
/* ns6:WUListQueries */
class SOAP_CMAC _ns6__WUListQueries
{
public:
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *LibraryName;	/* optional element of type xsd:string */
	LONG64 *MemoryLimitLow;	/* optional element of type xsd:long */
	LONG64 *MemoryLimitHigh;	/* optional element of type xsd:long */
	unsigned int *TimeLimitLow;	/* optional element of type xsd:unsignedInt */
	unsigned int *TimeLimitHigh;	/* optional element of type xsd:unsignedInt */
	unsigned int *WarnTimeLimitLow;	/* optional element of type xsd:unsignedInt */
	unsigned int *WarnTimeLimitHigh;	/* optional element of type xsd:unsignedInt */
	unsigned int *PriorityLow;	/* optional element of type xsd:unsignedInt */
	unsigned int *PriorityHigh;	/* optional element of type xsd:unsignedInt */
	bool *Activated;	/* optional element of type xsd:boolean */
	bool *SuspendedByUser;	/* optional element of type xsd:boolean */
	std::wstring *WUID;	/* optional element of type xsd:string */
	std::wstring *QueryID;	/* optional element of type xsd:string */
	std::wstring *QueryName;	/* optional element of type xsd:string */
	std::wstring *PublishedBy;	/* optional element of type xsd:string */
	unsigned int *PageSize;	/* optional element of type xsd:unsignedInt */
	unsigned int *PageStartFrom;	/* optional element of type xsd:unsignedInt */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	std::wstring *FileName;	/* optional element of type xsd:string */
	bool CheckAllNodes;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 442; } /* = unique id SOAP_TYPE__ns6__WUListQueries */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListQueries() : QuerySetName(NULL), ClusterName(NULL), LibraryName(NULL), MemoryLimitLow(NULL), MemoryLimitHigh(NULL), TimeLimitLow(NULL), TimeLimitHigh(NULL), WarnTimeLimitLow(NULL), WarnTimeLimitHigh(NULL), PriorityLow(NULL), PriorityHigh(NULL), Activated(NULL), SuspendedByUser(NULL), WUID(NULL), QueryID(NULL), QueryName(NULL), PublishedBy(NULL), PageSize(NULL), PageStartFrom(NULL), Sortby(NULL), Descending((bool)0), CacheHint(NULL), FileName(NULL), CheckAllNodes((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListQueries() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListQueriesResponse
#define SOAP_TYPE__ns6__WUListQueriesResponse (443)
/* ns6:WUListQueriesResponse */
class SOAP_CMAC _ns6__WUListQueriesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	int *NumberOfQueries;	/* optional element of type xsd:int */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	ns6__ArrayOfQuerySetQuery *QuerysetQueries;	/* optional element of type ns6:ArrayOfQuerySetQuery */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 443; } /* = unique id SOAP_TYPE__ns6__WUListQueriesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListQueriesResponse() : Exceptions(NULL), NumberOfQueries(NULL), CacheHint(NULL), QuerysetQueries(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListQueriesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListQueriesUsingFile
#define SOAP_TYPE__ns6__WUListQueriesUsingFile (444)
/* ns6:WUListQueriesUsingFile */
class SOAP_CMAC _ns6__WUListQueriesUsingFile
{
public:
	std::wstring *Target;	/* optional element of type xsd:string */
	std::wstring *Process;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 444; } /* = unique id SOAP_TYPE__ns6__WUListQueriesUsingFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListQueriesUsingFile() : Target(NULL), Process(NULL), FileName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListQueriesUsingFile() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListQueriesUsingFileResponse
#define SOAP_TYPE__ns6__WUListQueriesUsingFileResponse (445)
/* ns6:WUListQueriesUsingFileResponse */
class SOAP_CMAC _ns6__WUListQueriesUsingFileResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Process;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	ns6__ArrayOfTargetQueriesUsingFile *Targets;	/* optional element of type ns6:ArrayOfTargetQueriesUsingFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 445; } /* = unique id SOAP_TYPE__ns6__WUListQueriesUsingFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListQueriesUsingFileResponse() : Exceptions(NULL), Process(NULL), FileName(NULL), Targets(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListQueriesUsingFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUMultiQuerysetDetails
#define SOAP_TYPE__ns6__WUMultiQuerysetDetails (446)
/* ns6:WUMultiQuerysetDetails */
class SOAP_CMAC _ns6__WUMultiQuerysetDetails
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	std::wstring *Filter;	/* optional element of type xsd:string */
	enum ns6__WUQuerySetFilterType FilterType;	/* optional element of type ns6:WUQuerySetFilterType */
	bool CheckAllNodes;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 446; } /* = unique id SOAP_TYPE__ns6__WUMultiQuerysetDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUMultiQuerysetDetails() : ClusterName(NULL), QuerySetName(NULL), Filter(NULL), FilterType((enum ns6__WUQuerySetFilterType)0), CheckAllNodes((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUMultiQuerysetDetails() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUMultiQuerySetDetailsResponse
#define SOAP_TYPE__ns6__WUMultiQuerySetDetailsResponse (447)
/* ns6:WUMultiQuerySetDetailsResponse */
class SOAP_CMAC _ns6__WUMultiQuerySetDetailsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	ns6__ArrayOfWUQuerySetDetail *Querysets;	/* optional element of type ns6:ArrayOfWUQuerySetDetail */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 447; } /* = unique id SOAP_TYPE__ns6__WUMultiQuerySetDetailsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUMultiQuerySetDetailsResponse() : Exceptions(NULL), ClusterName(NULL), Querysets(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUMultiQuerySetDetailsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProcessGraph
#define SOAP_TYPE__ns6__WUProcessGraph (448)
/* ns6:WUProcessGraph */
class SOAP_CMAC _ns6__WUProcessGraph
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 448; } /* = unique id SOAP_TYPE__ns6__WUProcessGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProcessGraph() : Wuid(NULL), Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProcessGraph() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProcessGraphResponse
#define SOAP_TYPE__ns6__WUProcessGraphResponse (449)
/* ns6:WUProcessGraphResponse */
class SOAP_CMAC _ns6__WUProcessGraphResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *theGraph;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 449; } /* = unique id SOAP_TYPE__ns6__WUProcessGraphResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProcessGraphResponse() : Exceptions(NULL), theGraph(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProcessGraphResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProtect
#define SOAP_TYPE__ns6__WUProtect (450)
/* ns6:WUProtect */
class SOAP_CMAC _ns6__WUProtect
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	bool Protect;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 450; } /* = unique id SOAP_TYPE__ns6__WUProtect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProtect() : Wuids(NULL), Protect((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProtect() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProtectResponse
#define SOAP_TYPE__ns6__WUProtectResponse (451)
/* ns6:WUProtectResponse */
class SOAP_CMAC _ns6__WUProtectResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 451; } /* = unique id SOAP_TYPE__ns6__WUProtectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProtectResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProtectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPublishWorkunit
#define SOAP_TYPE__ns6__WUPublishWorkunit (452)
/* ns6:WUPublishWorkunit */
class SOAP_CMAC _ns6__WUPublishWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	int *Activate;	/* optional element of type xsd:int */
	bool NotifyCluster;	/* optional element of type xsd:boolean */
	int Wait;	/* optional element of type xsd:int */
	bool NoReload;	/* optional element of type xsd:boolean */
	bool UpdateWorkUnitName;	/* optional element of type xsd:boolean */
	std::wstring *memoryLimit;	/* optional element of type xsd:string */
	unsigned int *TimeLimit;	/* optional element of type xsd:unsignedInt */
	unsigned int *WarnTimeLimit;	/* optional element of type xsd:unsignedInt */
	std::wstring *Priority;	/* optional element of type xsd:string */
	std::wstring *RemoteDali;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	bool DontCopyFiles;	/* optional element of type xsd:boolean */
	std::wstring *SourceProcess;	/* optional element of type xsd:string */
	bool AllowForeignFiles;	/* optional element of type xsd:boolean */
	bool UpdateDfs;	/* optional element of type xsd:boolean */
	bool UpdateSuperFiles;	/* optional element of type xsd:boolean */
	bool UpdateCloneFrom;	/* optional element of type xsd:boolean */
	bool AppendCluster;	/* optional element of type xsd:boolean */
	bool IncludeFileErrors;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 452; } /* = unique id SOAP_TYPE__ns6__WUPublishWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPublishWorkunit() : Wuid(NULL), Cluster(NULL), JobName(NULL), Activate(NULL), NotifyCluster((bool)0), Wait(0), NoReload((bool)0), UpdateWorkUnitName((bool)0), memoryLimit(NULL), TimeLimit(NULL), WarnTimeLimit(NULL), Priority(NULL), RemoteDali(NULL), Comment(NULL), DontCopyFiles((bool)0), SourceProcess(NULL), AllowForeignFiles((bool)0), UpdateDfs((bool)0), UpdateSuperFiles((bool)0), UpdateCloneFrom((bool)0), AppendCluster((bool)0), IncludeFileErrors((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPublishWorkunit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPublishWorkunitResponse_ClusterFiles
#define SOAP_TYPE__ns6__WUPublishWorkunitResponse_ClusterFiles (863)
/* ns6:WUPublishWorkunitResponse-ClusterFiles */
class SOAP_CMAC _ns6__WUPublishWorkunitResponse_ClusterFiles
{
public:
	std::vector<ns6__WUCopyLogicalClusterFileSections * >Cluster;	/* optional element of type ns6:WUCopyLogicalClusterFileSections */
public:
	virtual int soap_type() const { return 863; } /* = unique id SOAP_TYPE__ns6__WUPublishWorkunitResponse_ClusterFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPublishWorkunitResponse_ClusterFiles()  { this->soap_default(NULL); }
	virtual ~_ns6__WUPublishWorkunitResponse_ClusterFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPublishWorkunitResponse_FileErrors
#define SOAP_TYPE__ns6__WUPublishWorkunitResponse_FileErrors (865)
/* ns6:WUPublishWorkunitResponse-FileErrors */
class SOAP_CMAC _ns6__WUPublishWorkunitResponse_FileErrors
{
public:
	std::vector<ns6__LogicalFileError * >File;	/* optional element of type ns6:LogicalFileError */
public:
	virtual int soap_type() const { return 865; } /* = unique id SOAP_TYPE__ns6__WUPublishWorkunitResponse_FileErrors */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPublishWorkunitResponse_FileErrors()  { this->soap_default(NULL); }
	virtual ~_ns6__WUPublishWorkunitResponse_FileErrors() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPublishWorkunitResponse
#define SOAP_TYPE__ns6__WUPublishWorkunitResponse (453)
/* ns6:WUPublishWorkunitResponse */
class SOAP_CMAC _ns6__WUPublishWorkunitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *QueryName;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	bool *ReloadFailed;	/* optional element of type xsd:boolean */
	bool *Suspended;	/* optional element of type xsd:boolean */
	std::wstring *ErrorMessage;	/* optional element of type xsd:string */
	_ns6__WUPublishWorkunitResponse_ClusterFiles *ClusterFiles;	/* optional element of type ns6:WUPublishWorkunitResponse-ClusterFiles */
	_ns6__WUPublishWorkunitResponse_FileErrors *FileErrors;	/* optional element of type ns6:WUPublishWorkunitResponse-FileErrors */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 453; } /* = unique id SOAP_TYPE__ns6__WUPublishWorkunitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPublishWorkunitResponse() : Exceptions(NULL), Wuid(NULL), Result(NULL), QuerySet(NULL), QueryName(NULL), QueryId(NULL), ReloadFailed(NULL), Suspended(NULL), ErrorMessage(NULL), ClusterFiles(NULL), FileErrors(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPublishWorkunitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPushEvent
#define SOAP_TYPE__ns6__WUPushEvent (454)
/* ns6:WUPushEvent */
class SOAP_CMAC _ns6__WUPushEvent
{
public:
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *EventText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 454; } /* = unique id SOAP_TYPE__ns6__WUPushEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPushEvent() : EventName(NULL), EventText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPushEvent() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPushEventResponse
#define SOAP_TYPE__ns6__WUPushEventResponse (455)
/* ns6:WUPushEventResponse */
class SOAP_CMAC _ns6__WUPushEventResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 455; } /* = unique id SOAP_TYPE__ns6__WUPushEventResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPushEventResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPushEventResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuery
#define SOAP_TYPE__ns6__WUQuery (456)
/* ns6:WUQuery */
class SOAP_CMAC _ns6__WUQuery
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *RoxieCluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *LogicalFile;	/* optional element of type xsd:string */
	std::wstring *LogicalFileSearchType;	/* optional element of type xsd:string */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	std::wstring *After;	/* optional element of type xsd:string */
	std::wstring *Before;	/* optional element of type xsd:string */
	int *Count;	/* optional element of type xsd:int */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *PageStartFrom;	/* optional element of type xsd:long */
	LONG64 *PageEndAt;	/* optional element of type xsd:long */
	int *LastNDays;	/* optional element of type xsd:int */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 456; } /* = unique id SOAP_TYPE__ns6__WUQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuery() : Wuid(NULL), Type(NULL), Cluster(NULL), RoxieCluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), ECL(NULL), Jobname(NULL), LogicalFile(NULL), LogicalFileSearchType(NULL), ApplicationValues(NULL), After(NULL), Before(NULL), Count(NULL), PageSize(NULL), PageStartFrom(NULL), PageEndAt(NULL), LastNDays(NULL), Sortby(NULL), Descending((bool)0), CacheHint(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuery() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryResponse
#define SOAP_TYPE__ns6__WUQueryResponse (457)
/* ns6:WUQueryResponse */
class SOAP_CMAC _ns6__WUQueryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *RoxieCluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *LogicalFile;	/* optional element of type xsd:string */
	std::wstring *LogicalFileSearchType;	/* optional element of type xsd:string */
	std::wstring *Current;	/* optional element of type xsd:string */
	std::wstring *Next;	/* optional element of type xsd:string */
	int *Count;	/* optional element of type xsd:int */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *PrevPage;	/* optional element of type xsd:long */
	LONG64 *NextPage;	/* optional element of type xsd:long */
	LONG64 LastPage;	/* optional element of type xsd:long */
	int *NumWUs;	/* optional element of type xsd:int */
	bool First;	/* optional element of type xsd:boolean */
	LONG64 PageStartFrom;	/* optional element of type xsd:long */
	LONG64 *PageEndAt;	/* optional element of type xsd:long */
	int *LastNDays;	/* optional element of type xsd:int */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	std::wstring *BasicQuery;	/* optional element of type xsd:string */
	std::wstring *Filters;	/* optional element of type xsd:string */
	LONG64 *CacheHint;	/* optional element of type xsd:long */
	ns6__ArrayOfECLWorkunit *Workunits;	/* optional element of type ns6:ArrayOfECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 457; } /* = unique id SOAP_TYPE__ns6__WUQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryResponse() : Exceptions(NULL), Type(NULL), Cluster(NULL), RoxieCluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), ECL(NULL), Jobname(NULL), LogicalFile(NULL), LogicalFileSearchType(NULL), Current(NULL), Next(NULL), Count(NULL), PageSize(NULL), PrevPage(NULL), NextPage(NULL), LastPage(0), NumWUs(NULL), First((bool)0), PageStartFrom(0), PageEndAt(NULL), LastNDays(NULL), Sortby(NULL), Descending((bool)0), BasicQuery(NULL), Filters(NULL), CacheHint(NULL), Workunits(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryConfig
#define SOAP_TYPE__ns6__WUQueryConfig (458)
/* ns6:WUQueryConfig */
class SOAP_CMAC _ns6__WUQueryConfig
{
public:
	std::wstring *Target;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	bool NoReload;	/* optional element of type xsd:boolean */
	std::wstring *memoryLimit;	/* optional element of type xsd:string */
	unsigned int *TimeLimit;	/* optional element of type xsd:unsignedInt */
	unsigned int *WarnTimeLimit;	/* optional element of type xsd:unsignedInt */
	std::wstring *Priority;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 458; } /* = unique id SOAP_TYPE__ns6__WUQueryConfig */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryConfig() : Target(NULL), QueryId(NULL), Wait(0), NoReload((bool)0), memoryLimit(NULL), TimeLimit(NULL), WarnTimeLimit(NULL), Priority(NULL), Comment(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryConfig() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryConfigResponse_Results
#define SOAP_TYPE__ns6__WUQueryConfigResponse_Results (868)
/* ns6:WUQueryConfigResponse-Results */
class SOAP_CMAC _ns6__WUQueryConfigResponse_Results
{
public:
	std::vector<ns6__WUQueryConfigResult * >Result;	/* optional element of type ns6:WUQueryConfigResult */
public:
	virtual int soap_type() const { return 868; } /* = unique id SOAP_TYPE__ns6__WUQueryConfigResponse_Results */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryConfigResponse_Results()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryConfigResponse_Results() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryConfigResponse
#define SOAP_TYPE__ns6__WUQueryConfigResponse (459)
/* ns6:WUQueryConfigResponse */
class SOAP_CMAC _ns6__WUQueryConfigResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	bool *ReloadFailed;	/* optional element of type xsd:boolean */
	_ns6__WUQueryConfigResponse_Results *Results;	/* optional element of type ns6:WUQueryConfigResponse-Results */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 459; } /* = unique id SOAP_TYPE__ns6__WUQueryConfigResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryConfigResponse() : Exceptions(NULL), ReloadFailed(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryConfigResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryDetails
#define SOAP_TYPE__ns6__WUQueryDetails (460)
/* ns6:WUQueryDetails */
class SOAP_CMAC _ns6__WUQueryDetails
{
public:
	std::wstring *QueryId;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	bool IncludeStateOnClusters;	/* optional element of type xsd:boolean */
	bool IncludeSuperFiles;	/* optional element of type xsd:boolean */
	bool IncludeWsEclAddresses;	/* optional element of type xsd:boolean */
	bool CheckAllNodes;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 460; } /* = unique id SOAP_TYPE__ns6__WUQueryDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryDetails() : QueryId(NULL), QuerySet(NULL), IncludeStateOnClusters((bool)0), IncludeSuperFiles((bool)0), IncludeWsEclAddresses((bool)0), CheckAllNodes((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryDetails() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryDetailsResponse_SuperFiles
#define SOAP_TYPE__ns6__WUQueryDetailsResponse_SuperFiles (872)
/* ns6:WUQueryDetailsResponse-SuperFiles */
class SOAP_CMAC _ns6__WUQueryDetailsResponse_SuperFiles
{
public:
	std::vector<ns6__QuerySuperFile * >SuperFile;	/* optional element of type ns6:QuerySuperFile */
public:
	virtual int soap_type() const { return 872; } /* = unique id SOAP_TYPE__ns6__WUQueryDetailsResponse_SuperFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryDetailsResponse_SuperFiles()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryDetailsResponse_SuperFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryDetailsResponse_WsEclAddresses
#define SOAP_TYPE__ns6__WUQueryDetailsResponse_WsEclAddresses (874)
/* ns6:WUQueryDetailsResponse-WsEclAddresses */
class SOAP_CMAC _ns6__WUQueryDetailsResponse_WsEclAddresses
{
public:
	std::vector<std::wstring * >Address;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 874; } /* = unique id SOAP_TYPE__ns6__WUQueryDetailsResponse_WsEclAddresses */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryDetailsResponse_WsEclAddresses()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryDetailsResponse_WsEclAddresses() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryDetailsResponse
#define SOAP_TYPE__ns6__WUQueryDetailsResponse (461)
/* ns6:WUQueryDetailsResponse */
class SOAP_CMAC _ns6__WUQueryDetailsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *QueryName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Dll;	/* optional element of type xsd:string */
	bool *Suspended;	/* optional element of type xsd:boolean */
	bool *Activated;	/* optional element of type xsd:boolean */
	std::wstring *SuspendedBy;	/* optional element of type xsd:string */
	ns6__ArrayOfClusterQueryState *Clusters;	/* optional element of type ns6:ArrayOfClusterQueryState */
	std::wstring *PublishedBy;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	ns6__EspStringArray *LogicalFiles;	/* optional element of type ns6:EspStringArray */
	_ns6__WUQueryDetailsResponse_SuperFiles *SuperFiles;	/* optional element of type ns6:WUQueryDetailsResponse-SuperFiles */
	bool *IsLibrary;	/* optional element of type xsd:boolean */
	std::wstring *Priority;	/* optional element of type xsd:string */
	std::wstring *WUSnapShot;	/* optional element of type xsd:string */
	std::wstring *CompileTime;	/* optional element of type xsd:string */
	ns6__EspStringArray *LibrariesUsed;	/* optional element of type ns6:EspStringArray */
	int *CountGraphs;	/* optional element of type xsd:int */
	int *ResourceURLCount;	/* optional element of type xsd:int */
	_ns6__WUQueryDetailsResponse_WsEclAddresses *WsEclAddresses;	/* optional element of type ns6:WUQueryDetailsResponse-WsEclAddresses */
	ns6__ArrayOfECLGraph *WUGraphs;	/* optional element of type ns6:ArrayOfECLGraph */
	ns6__ArrayOfECLTimer *WUTimers;	/* optional element of type ns6:ArrayOfECLTimer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 461; } /* = unique id SOAP_TYPE__ns6__WUQueryDetailsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryDetailsResponse() : Exceptions(NULL), QueryId(NULL), QuerySet(NULL), QueryName(NULL), Wuid(NULL), Dll(NULL), Suspended(NULL), Activated(NULL), SuspendedBy(NULL), Clusters(NULL), PublishedBy(NULL), Comment(NULL), LogicalFiles(NULL), SuperFiles(NULL), IsLibrary(NULL), Priority(NULL), WUSnapShot(NULL), CompileTime(NULL), LibrariesUsed(NULL), CountGraphs(NULL), ResourceURLCount(NULL), WsEclAddresses(NULL), WUGraphs(NULL), WUTimers(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryDetailsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryFiles
#define SOAP_TYPE__ns6__WUQueryFiles (462)
/* ns6:WUQueryFiles */
class SOAP_CMAC _ns6__WUQueryFiles
{
public:
	std::wstring *Target;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 462; } /* = unique id SOAP_TYPE__ns6__WUQueryFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryFiles() : Target(NULL), QueryId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryFilesResponse_Files
#define SOAP_TYPE__ns6__WUQueryFilesResponse_Files (876)
/* ns6:WUQueryFilesResponse-Files */
class SOAP_CMAC _ns6__WUQueryFilesResponse_Files
{
public:
	std::vector<ns6__FileUsedByQuery * >File;	/* optional element of type ns6:FileUsedByQuery */
public:
	virtual int soap_type() const { return 876; } /* = unique id SOAP_TYPE__ns6__WUQueryFilesResponse_Files */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryFilesResponse_Files()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryFilesResponse_Files() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryFilesResponse
#define SOAP_TYPE__ns6__WUQueryFilesResponse (463)
/* ns6:WUQueryFilesResponse */
class SOAP_CMAC _ns6__WUQueryFilesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	_ns6__WUQueryFilesResponse_Files *Files;	/* optional element of type ns6:WUQueryFilesResponse-Files */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 463; } /* = unique id SOAP_TYPE__ns6__WUQueryFilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryFilesResponse() : Exceptions(NULL), Files(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryFilesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryGetGraph
#define SOAP_TYPE__ns6__WUQueryGetGraph (464)
/* ns6:WUQueryGetGraph */
class SOAP_CMAC _ns6__WUQueryGetGraph
{
public:
	std::wstring *Target;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	std::wstring *SubGraphId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 464; } /* = unique id SOAP_TYPE__ns6__WUQueryGetGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryGetGraph() : Target(NULL), QueryId(NULL), GraphName(NULL), SubGraphId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryGetGraph() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryGetGraphResponse
#define SOAP_TYPE__ns6__WUQueryGetGraphResponse (465)
/* ns6:WUQueryGetGraphResponse */
class SOAP_CMAC _ns6__WUQueryGetGraphResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfECLGraphEx *Graphs;	/* optional element of type ns6:ArrayOfECLGraphEx */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 465; } /* = unique id SOAP_TYPE__ns6__WUQueryGetGraphResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryGetGraphResponse() : Exceptions(NULL), Graphs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryGetGraphResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetAliasAction_Aliases
#define SOAP_TYPE__ns6__WUQuerysetAliasAction_Aliases (881)
/* ns6:WUQuerysetAliasAction-Aliases */
class SOAP_CMAC _ns6__WUQuerysetAliasAction_Aliases
{
public:
	std::vector<ns6__QuerySetAliasActionItem * >Alias;	/* optional element of type ns6:QuerySetAliasActionItem */
public:
	virtual int soap_type() const { return 881; } /* = unique id SOAP_TYPE__ns6__WUQuerysetAliasAction_Aliases */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetAliasAction_Aliases()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetAliasAction_Aliases() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetAliasAction
#define SOAP_TYPE__ns6__WUQuerysetAliasAction (466)
/* ns6:WUQuerysetAliasAction */
class SOAP_CMAC _ns6__WUQuerysetAliasAction
{
public:
	enum ns6__QuerySetAliasActionTypes *Action;	/* optional element of type ns6:QuerySetAliasActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerysetAliasAction_Aliases *Aliases;	/* optional element of type ns6:WUQuerysetAliasAction-Aliases */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 466; } /* = unique id SOAP_TYPE__ns6__WUQuerysetAliasAction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetAliasAction() : Action(NULL), QuerySetName(NULL), Aliases(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetAliasAction() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetAliasActionResponse_Results
#define SOAP_TYPE__ns6__WUQuerySetAliasActionResponse_Results (885)
/* ns6:WUQuerySetAliasActionResponse-Results */
class SOAP_CMAC _ns6__WUQuerySetAliasActionResponse_Results
{
public:
	std::vector<ns6__QuerySetAliasActionResult * >Result;	/* optional element of type ns6:QuerySetAliasActionResult */
public:
	virtual int soap_type() const { return 885; } /* = unique id SOAP_TYPE__ns6__WUQuerySetAliasActionResponse_Results */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetAliasActionResponse_Results()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetAliasActionResponse_Results() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetAliasActionResponse
#define SOAP_TYPE__ns6__WUQuerySetAliasActionResponse (467)
/* ns6:WUQuerySetAliasActionResponse */
class SOAP_CMAC _ns6__WUQuerySetAliasActionResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	enum ns6__QuerySetAliasActionTypes *Action;	/* optional element of type ns6:QuerySetAliasActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerySetAliasActionResponse_Results *Results;	/* optional element of type ns6:WUQuerySetAliasActionResponse-Results */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 467; } /* = unique id SOAP_TYPE__ns6__WUQuerySetAliasActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetAliasActionResponse() : Exceptions(NULL), Action(NULL), QuerySetName(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetAliasActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetCopyQuery
#define SOAP_TYPE__ns6__WUQuerysetCopyQuery (468)
/* ns6:WUQuerysetCopyQuery */
class SOAP_CMAC _ns6__WUQuerysetCopyQuery
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Target;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *DaliServer;	/* optional element of type xsd:string */
	int *Activate;	/* optional element of type xsd:int */
	bool Overwrite;	/* optional element of type xsd:boolean */
	bool DontCopyFiles;	/* optional element of type xsd:boolean */
	int Wait;	/* optional element of type xsd:int */
	bool NoReload;	/* optional element of type xsd:boolean */
	std::wstring *memoryLimit;	/* optional element of type xsd:string */
	unsigned int *TimeLimit;	/* optional element of type xsd:unsignedInt */
	unsigned int *WarnTimeLimit;	/* optional element of type xsd:unsignedInt */
	std::wstring *priority;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	std::wstring *SourceProcess;	/* optional element of type xsd:string */
	std::wstring *DestName;	/* optional element of type xsd:string */
	bool AllowForeignFiles;	/* optional element of type xsd:boolean */
	bool UpdateSuperFiles;	/* optional element of type xsd:boolean */
	bool UpdateCloneFrom;	/* optional element of type xsd:boolean */
	bool AppendCluster;	/* optional element of type xsd:boolean */
	bool IncludeFileErrors;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 468; } /* = unique id SOAP_TYPE__ns6__WUQuerysetCopyQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetCopyQuery() : Source(NULL), Target(NULL), Cluster(NULL), DaliServer(NULL), Activate(NULL), Overwrite((bool)0), DontCopyFiles((bool)0), Wait(0), NoReload((bool)0), memoryLimit(NULL), TimeLimit(NULL), WarnTimeLimit(NULL), priority(NULL), Comment(NULL), SourceProcess(NULL), DestName(NULL), AllowForeignFiles((bool)0), UpdateSuperFiles((bool)0), UpdateCloneFrom((bool)0), AppendCluster((bool)0), IncludeFileErrors((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetCopyQuery() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse_FileErrors
#define SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse_FileErrors (889)
/* ns6:WUQuerySetCopyQueryResponse-FileErrors */
class SOAP_CMAC _ns6__WUQuerySetCopyQueryResponse_FileErrors
{
public:
	std::vector<ns6__LogicalFileError * >File;	/* optional element of type ns6:LogicalFileError */
public:
	virtual int soap_type() const { return 889; } /* = unique id SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse_FileErrors */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetCopyQueryResponse_FileErrors()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetCopyQueryResponse_FileErrors() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse
#define SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse (469)
/* ns6:WUQuerySetCopyQueryResponse */
class SOAP_CMAC _ns6__WUQuerySetCopyQueryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	_ns6__WUQuerySetCopyQueryResponse_FileErrors *FileErrors;	/* optional element of type ns6:WUQuerySetCopyQueryResponse-FileErrors */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 469; } /* = unique id SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetCopyQueryResponse() : Exceptions(NULL), QueryId(NULL), FileErrors(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetCopyQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetDetails
#define SOAP_TYPE__ns6__WUQuerysetDetails (470)
/* ns6:WUQuerysetDetails */
class SOAP_CMAC _ns6__WUQuerysetDetails
{
public:
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	std::wstring *Filter;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	enum ns6__WUQuerySetFilterType FilterType;	/* optional element of type ns6:WUQuerySetFilterType */
	bool CheckAllNodes;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 470; } /* = unique id SOAP_TYPE__ns6__WUQuerysetDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetDetails() : QuerySetName(NULL), Filter(NULL), ClusterName(NULL), FilterType((enum ns6__WUQuerySetFilterType)0), CheckAllNodes((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetDetails() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetDetailsResponse
#define SOAP_TYPE__ns6__WUQuerySetDetailsResponse (471)
/* ns6:WUQuerySetDetailsResponse */
class SOAP_CMAC _ns6__WUQuerySetDetailsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	ns6__ArrayOfQuerySetQuery *QuerysetQueries;	/* optional element of type ns6:ArrayOfQuerySetQuery */
	ns6__ArrayOfQuerySetAlias *QuerysetAliases;	/* optional element of type ns6:ArrayOfQuerySetAlias */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *Filter;	/* optional element of type xsd:string */
	enum ns6__WUQuerySetFilterType *FilterType;	/* optional element of type ns6:WUQuerySetFilterType */
	ns6__EspStringArray *ClusterNames;	/* optional element of type ns6:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 471; } /* = unique id SOAP_TYPE__ns6__WUQuerySetDetailsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetDetailsResponse() : Exceptions(NULL), QuerySetName(NULL), QuerysetQueries(NULL), QuerysetAliases(NULL), ClusterName(NULL), Filter(NULL), FilterType(NULL), ClusterNames(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetDetailsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetQueryAction_Queries
#define SOAP_TYPE__ns6__WUQuerysetQueryAction_Queries (893)
/* ns6:WUQuerysetQueryAction-Queries */
class SOAP_CMAC _ns6__WUQuerysetQueryAction_Queries
{
public:
	std::vector<ns6__QuerySetQueryActionItem * >Query;	/* optional element of type ns6:QuerySetQueryActionItem */
public:
	virtual int soap_type() const { return 893; } /* = unique id SOAP_TYPE__ns6__WUQuerysetQueryAction_Queries */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetQueryAction_Queries()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetQueryAction_Queries() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetQueryAction
#define SOAP_TYPE__ns6__WUQuerysetQueryAction (472)
/* ns6:WUQuerysetQueryAction */
class SOAP_CMAC _ns6__WUQuerysetQueryAction
{
public:
	enum ns6__QuerySetQueryActionTypes *Action;	/* optional element of type ns6:QuerySetQueryActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerysetQueryAction_Queries *Queries;	/* optional element of type ns6:WUQuerysetQueryAction-Queries */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 472; } /* = unique id SOAP_TYPE__ns6__WUQuerysetQueryAction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetQueryAction() : Action(NULL), QuerySetName(NULL), Queries(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetQueryAction() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetQueryActionResponse_Results
#define SOAP_TYPE__ns6__WUQuerySetQueryActionResponse_Results (897)
/* ns6:WUQuerySetQueryActionResponse-Results */
class SOAP_CMAC _ns6__WUQuerySetQueryActionResponse_Results
{
public:
	std::vector<ns6__QuerySetQueryActionResult * >Result;	/* optional element of type ns6:QuerySetQueryActionResult */
public:
	virtual int soap_type() const { return 897; } /* = unique id SOAP_TYPE__ns6__WUQuerySetQueryActionResponse_Results */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetQueryActionResponse_Results()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetQueryActionResponse_Results() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetQueryActionResponse
#define SOAP_TYPE__ns6__WUQuerySetQueryActionResponse (473)
/* ns6:WUQuerySetQueryActionResponse */
class SOAP_CMAC _ns6__WUQuerySetQueryActionResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	enum ns6__QuerySetQueryActionTypes *Action;	/* optional element of type ns6:QuerySetQueryActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerySetQueryActionResponse_Results *Results;	/* optional element of type ns6:WUQuerySetQueryActionResponse-Results */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 473; } /* = unique id SOAP_TYPE__ns6__WUQuerySetQueryActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetQueryActionResponse() : Exceptions(NULL), Action(NULL), QuerySetName(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetQueryActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysets
#define SOAP_TYPE__ns6__WUQuerysets (474)
/* ns6:WUQuerysets */
class SOAP_CMAC _ns6__WUQuerysets
{
public:
	bool *test;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 474; } /* = unique id SOAP_TYPE__ns6__WUQuerysets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysets() : test(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysets() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetsResponse
#define SOAP_TYPE__ns6__WUQuerysetsResponse (475)
/* ns6:WUQuerysetsResponse */
class SOAP_CMAC _ns6__WUQuerysetsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfQuerySet *Querysets;	/* optional element of type ns6:ArrayOfQuerySet */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 475; } /* = unique id SOAP_TYPE__ns6__WUQuerysetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetsResponse() : Exceptions(NULL), Querysets(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResubmit
#define SOAP_TYPE__ns6__WUResubmit (476)
/* ns6:WUResubmit */
class SOAP_CMAC _ns6__WUResubmit
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	bool *ResetWorkflow;	/* optional element of type xsd:boolean */
	bool *CloneWorkunit;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 476; } /* = unique id SOAP_TYPE__ns6__WUResubmit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResubmit() : Wuids(NULL), BlockTillFinishTimer(NULL), ResetWorkflow(NULL), CloneWorkunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResubmit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResubmitResponse_WUs
#define SOAP_TYPE__ns6__WUResubmitResponse_WUs (902)
/* ns6:WUResubmitResponse-WUs */
class SOAP_CMAC _ns6__WUResubmitResponse_WUs
{
public:
	std::vector<ns6__ResubmittedWU * >WU;	/* optional element of type ns6:ResubmittedWU */
public:
	virtual int soap_type() const { return 902; } /* = unique id SOAP_TYPE__ns6__WUResubmitResponse_WUs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResubmitResponse_WUs()  { this->soap_default(NULL); }
	virtual ~_ns6__WUResubmitResponse_WUs() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResubmitResponse
#define SOAP_TYPE__ns6__WUResubmitResponse (477)
/* ns6:WUResubmitResponse */
class SOAP_CMAC _ns6__WUResubmitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	_ns6__WUResubmitResponse_WUs *WUs;	/* optional element of type ns6:WUResubmitResponse-WUs */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 477; } /* = unique id SOAP_TYPE__ns6__WUResubmitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResubmitResponse() : Exceptions(NULL), WUs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResubmitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResult
#define SOAP_TYPE__ns6__WUResult (478)
/* ns6:WUResult */
class SOAP_CMAC _ns6__WUResult
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *ResultName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	bool SuppressXmlSchema;	/* optional element of type xsd:boolean */
	bool BypassCachedResult;	/* optional element of type xsd:boolean */
	ns6__ArrayOfNamedValue *FilterBy;	/* optional element of type ns6:ArrayOfNamedValue */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 478; } /* = unique id SOAP_TYPE__ns6__WUResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResult() : Wuid(NULL), Sequence(NULL), ResultName(NULL), LogicalName(NULL), Cluster(NULL), SuppressXmlSchema((bool)0), BypassCachedResult((bool)0), FilterBy(NULL), Start(NULL), Count(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResult() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultResponse
#define SOAP_TYPE__ns6__WUResultResponse (479)
/* ns6:WUResultResponse */
class SOAP_CMAC _ns6__WUResultResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Requested;	/* optional element of type xsd:int */
	int *Count;	/* optional element of type xsd:int */
	LONG64 *Total;	/* optional element of type xsd:long */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 479; } /* = unique id SOAP_TYPE__ns6__WUResultResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultResponse() : Exceptions(NULL), Wuid(NULL), Sequence(NULL), LogicalName(NULL), Cluster(NULL), Name(NULL), Start(NULL), Requested(NULL), Count(NULL), Total(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultBin
#define SOAP_TYPE__ns6__WUResultBin (480)
/* ns6:WUResultBin */
class SOAP_CMAC _ns6__WUResultBin
{
public:
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *ResultName;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *Format;	/* optional element of type xsd:string */
	ns6__ArrayOfNamedValue *FilterBy;	/* optional element of type ns6:ArrayOfNamedValue */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 480; } /* = unique id SOAP_TYPE__ns6__WUResultBin */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultBin() : LogicalName(NULL), Wuid(NULL), ResultName(NULL), Sequence(NULL), Format(NULL), FilterBy(NULL), Start(NULL), Count(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultBin() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultBinResponse
#define SOAP_TYPE__ns6__WUResultBinResponse (481)
/* ns6:WUResultBinResponse */
class SOAP_CMAC _ns6__WUResultBinResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *Name;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	int *Requested;	/* optional element of type xsd:int */
	LONG64 *Total;	/* optional element of type xsd:long */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	std::wstring *Format;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 481; } /* = unique id SOAP_TYPE__ns6__WUResultBinResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultBinResponse() : Exceptions(NULL), Wuid(NULL), Sequence(NULL), Name(NULL), Start(NULL), Count(NULL), Requested(NULL), Total(NULL), Result(NULL), Format(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultBinResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultSummary
#define SOAP_TYPE__ns6__WUResultSummary (482)
/* ns6:WUResultSummary */
class SOAP_CMAC _ns6__WUResultSummary
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 482; } /* = unique id SOAP_TYPE__ns6__WUResultSummary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultSummary() : Wuid(NULL), Sequence(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultSummary() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultSummaryResponse
#define SOAP_TYPE__ns6__WUResultSummaryResponse (483)
/* ns6:WUResultSummaryResponse */
class SOAP_CMAC _ns6__WUResultSummaryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	int *Format;	/* optional element of type xsd:int */
	ns6__ECLResult *Result;	/* optional element of type ns6:ECLResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 483; } /* = unique id SOAP_TYPE__ns6__WUResultSummaryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultSummaryResponse() : Exceptions(NULL), Wuid(NULL), Sequence(NULL), Format(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultSummaryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultView
#define SOAP_TYPE__ns6__WUResultView (484)
/* ns6:WUResultView */
class SOAP_CMAC _ns6__WUResultView
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *ViewName;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *ResultName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 484; } /* = unique id SOAP_TYPE__ns6__WUResultView */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultView() : Wuid(NULL), ViewName(NULL), Sequence(NULL), ResultName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultView() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultViewResponse
#define SOAP_TYPE__ns6__WUResultViewResponse (485)
/* ns6:WUResultViewResponse */
class SOAP_CMAC _ns6__WUResultViewResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *ViewName;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 485; } /* = unique id SOAP_TYPE__ns6__WUResultViewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultViewResponse() : Exceptions(NULL), Wuid(NULL), ViewName(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultViewResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WURun
#define SOAP_TYPE__ns6__WURun (486)
/* ns6:WURun */
class SOAP_CMAC _ns6__WURun
{
public:
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *Query;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	bool *CloneWorkunit;	/* optional element of type xsd:boolean */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	std::wstring *Input;	/* optional element of type xsd:string */
	bool NoRootTag;	/* optional element of type xsd:boolean */
	ns6__ArrayOfNamedValue *DebugValues;	/* optional element of type ns6:ArrayOfNamedValue */
	ns6__ArrayOfNamedValue *Variables;	/* optional element of type ns6:ArrayOfNamedValue */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	enum ns6__WUExceptionSeverity ExceptionSeverity;	/* optional element of type ns6:WUExceptionSeverity */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 486; } /* = unique id SOAP_TYPE__ns6__WURun */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WURun() : QuerySet(NULL), Query(NULL), Wuid(NULL), CloneWorkunit(NULL), Cluster(NULL), Wait(0), Input(NULL), NoRootTag((bool)0), DebugValues(NULL), Variables(NULL), ApplicationValues(NULL), ExceptionSeverity((enum ns6__WUExceptionSeverity)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WURun() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WURunResponse
#define SOAP_TYPE__ns6__WURunResponse (487)
/* ns6:WURunResponse */
class SOAP_CMAC _ns6__WURunResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *Results;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 487; } /* = unique id SOAP_TYPE__ns6__WURunResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WURunResponse() : Exceptions(NULL), Wuid(NULL), State(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WURunResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSchedule
#define SOAP_TYPE__ns6__WUSchedule (488)
/* ns6:WUSchedule */
class SOAP_CMAC _ns6__WUSchedule
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	time_t *When;	/* optional element of type xsd:dateTime */
	int *MaxRunTime;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 488; } /* = unique id SOAP_TYPE__ns6__WUSchedule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSchedule() : Wuid(NULL), Cluster(NULL), Queue(NULL), Snapshot(NULL), When(NULL), MaxRunTime(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSchedule() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUScheduleResponse
#define SOAP_TYPE__ns6__WUScheduleResponse (489)
/* ns6:WUScheduleResponse */
class SOAP_CMAC _ns6__WUScheduleResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 489; } /* = unique id SOAP_TYPE__ns6__WUScheduleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUScheduleResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUScheduleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUShowScheduled
#define SOAP_TYPE__ns6__WUShowScheduled (490)
/* ns6:WUShowScheduled */
class SOAP_CMAC _ns6__WUShowScheduled
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *PushEventName;	/* optional element of type xsd:string */
	std::wstring *PushEventText;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 490; } /* = unique id SOAP_TYPE__ns6__WUShowScheduled */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUShowScheduled() : Cluster(NULL), EventName(NULL), PushEventName(NULL), PushEventText(NULL), State(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUShowScheduled() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUShowScheduledResponse
#define SOAP_TYPE__ns6__WUShowScheduledResponse (491)
/* ns6:WUShowScheduledResponse */
class SOAP_CMAC _ns6__WUShowScheduledResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	int *ClusterSelected;	/* optional element of type xsd:int */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *PushEventName;	/* optional element of type xsd:string */
	std::wstring *PushEventText;	/* optional element of type xsd:string */
	std::wstring *Query;	/* optional element of type xsd:string */
	ns6__ArrayOfServerInfo *Clusters;	/* optional element of type ns6:ArrayOfServerInfo */
	ns6__ArrayOfScheduledWU *Workunits;	/* optional element of type ns6:ArrayOfScheduledWU */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 491; } /* = unique id SOAP_TYPE__ns6__WUShowScheduledResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUShowScheduledResponse() : Exceptions(NULL), ClusterSelected(NULL), EventName(NULL), PushEventName(NULL), PushEventText(NULL), Query(NULL), Clusters(NULL), Workunits(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUShowScheduledResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSubmit
#define SOAP_TYPE__ns6__WUSubmit (492)
/* ns6:WUSubmit */
class SOAP_CMAC _ns6__WUSubmit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	int *MaxRunTime;	/* optional element of type xsd:int */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	bool SyntaxCheck;	/* optional element of type xsd:boolean */
	bool NotifyCluster;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 492; } /* = unique id SOAP_TYPE__ns6__WUSubmit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSubmit() : Wuid(NULL), Cluster(NULL), Queue(NULL), Snapshot(NULL), MaxRunTime(NULL), BlockTillFinishTimer(NULL), SyntaxCheck((bool)0), NotifyCluster((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSubmit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSubmitResponse
#define SOAP_TYPE__ns6__WUSubmitResponse (493)
/* ns6:WUSubmitResponse */
class SOAP_CMAC _ns6__WUSubmitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 493; } /* = unique id SOAP_TYPE__ns6__WUSubmitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSubmitResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSubmitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSyntaxCheckECL
#define SOAP_TYPE__ns6__WUSyntaxCheckECL (494)
/* ns6:WUSyntaxCheckECL */
class SOAP_CMAC _ns6__WUSyntaxCheckECL
{
public:
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	int TimeToWait;	/* optional element of type xsd:int */
	ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 494; } /* = unique id SOAP_TYPE__ns6__WUSyntaxCheckECL */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSyntaxCheckECL() : ECL(NULL), ModuleName(NULL), AttributeName(NULL), Queue(NULL), Cluster(NULL), Snapshot(NULL), TimeToWait(0), DebugValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSyntaxCheckECL() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSyntaxCheckResponse
#define SOAP_TYPE__ns6__WUSyntaxCheckResponse (495)
/* ns6:WUSyntaxCheckResponse */
class SOAP_CMAC _ns6__WUSyntaxCheckResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfECLException *Errors;	/* optional element of type ns6:ArrayOfECLException */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 495; } /* = unique id SOAP_TYPE__ns6__WUSyntaxCheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSyntaxCheckResponse() : Exceptions(NULL), Errors(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSyntaxCheckResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUUpdate
#define SOAP_TYPE__ns6__WUUpdate (496)
/* ns6:WUUpdate */
class SOAP_CMAC _ns6__WUUpdate
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *State;	/* optional element of type xsd:int */
	int *StateOrig;	/* optional element of type xsd:int */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *JobnameOrig;	/* optional element of type xsd:string */
	std::wstring *QueryText;	/* optional element of type xsd:string */
	int *Action;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *DescriptionOrig;	/* optional element of type xsd:string */
	bool *AddDrilldownFields;	/* optional element of type xsd:boolean */
	int *ResultLimit;	/* optional element of type xsd:int */
	bool *Protected;	/* optional element of type xsd:boolean */
	bool *ProtectedOrig;	/* optional element of type xsd:boolean */
	int *PriorityClass;	/* optional element of type xsd:int */
	int *PriorityLevel;	/* optional element of type xsd:int */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *ScopeOrig;	/* optional element of type xsd:string */
	std::wstring *ClusterSelection;	/* optional element of type xsd:string */
	std::wstring *ClusterOrig;	/* optional element of type xsd:string */
	std::wstring *XmlParams;	/* optional element of type xsd:string */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	std::wstring *QueryMainDefinition;	/* optional element of type xsd:string */
	ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 496; } /* = unique id SOAP_TYPE__ns6__WUUpdate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUUpdate() : Wuid(NULL), State(NULL), StateOrig(NULL), Jobname(NULL), JobnameOrig(NULL), QueryText(NULL), Action(NULL), Description(NULL), DescriptionOrig(NULL), AddDrilldownFields(NULL), ResultLimit(NULL), Protected(NULL), ProtectedOrig(NULL), PriorityClass(NULL), PriorityLevel(NULL), Scope(NULL), ScopeOrig(NULL), ClusterSelection(NULL), ClusterOrig(NULL), XmlParams(NULL), ThorSlaveIP(NULL), QueryMainDefinition(NULL), DebugValues(NULL), ApplicationValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUUpdate() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUUpdateQueryEntry
#define SOAP_TYPE__ns6__WUUpdateQueryEntry (497)
/* ns6:WUUpdateQueryEntry */
class SOAP_CMAC _ns6__WUUpdateQueryEntry
{
public:
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	std::wstring *Comment;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 497; } /* = unique id SOAP_TYPE__ns6__WUUpdateQueryEntry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUUpdateQueryEntry() : QuerySet(NULL), QueryId(NULL), Comment(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUUpdateQueryEntry() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUUpdateQueryEntryResponse
#define SOAP_TYPE__ns6__WUUpdateQueryEntryResponse (498)
/* ns6:WUUpdateQueryEntryResponse */
class SOAP_CMAC _ns6__WUUpdateQueryEntryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 498; } /* = unique id SOAP_TYPE__ns6__WUUpdateQueryEntryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUUpdateQueryEntryResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUUpdateQueryEntryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUWaitCompiled
#define SOAP_TYPE__ns6__WUWaitCompiled (499)
/* ns6:WUWaitCompiled */
class SOAP_CMAC _ns6__WUWaitCompiled
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	bool ReturnOnWait;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 499; } /* = unique id SOAP_TYPE__ns6__WUWaitCompiled */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUWaitCompiled() : Wuid(NULL), Wait(0), ReturnOnWait((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUWaitCompiled() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUWaitResponse
#define SOAP_TYPE__ns6__WUWaitResponse (500)
/* ns6:WUWaitResponse */
class SOAP_CMAC _ns6__WUWaitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	int *StateID;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 500; } /* = unique id SOAP_TYPE__ns6__WUWaitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUWaitResponse() : Exceptions(NULL), StateID(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUWaitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUWaitComplete
#define SOAP_TYPE__ns6__WUWaitComplete (501)
/* ns6:WUWaitComplete */
class SOAP_CMAC _ns6__WUWaitComplete
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	bool ReturnOnWait;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 501; } /* = unique id SOAP_TYPE__ns6__WUWaitComplete */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUWaitComplete() : Wuid(NULL), Wait(0), ReturnOnWait((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUWaitComplete() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (908)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns1__ArrayOfEspException *ns1__Exceptions;	/* optional element of type ns1:ArrayOfEspException */
	ns2__ArrayOfEspException *ns2__Exceptions;	/* optional element of type ns2:ArrayOfEspException */
	ns3__ArrayOfEspException *ns3__Exceptions;	/* optional element of type ns3:ArrayOfEspException */
	ns4__ArrayOfEspException *ns4__Exceptions;	/* optional element of type ns4:ArrayOfEspException */
	ns5__ArrayOfEspException *ns5__Exceptions;	/* optional element of type ns5:ArrayOfEspException */
	ns6__ArrayOfEspException *ns6__Exceptions;	/* optional element of type ns6:ArrayOfEspException */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns1__MyAccount
#define SOAP_TYPE___ns1__MyAccount (914)
/* Operation wrapper: */
struct __ns1__MyAccount
{
public:
	_ns1__MyAccountRequest *ns1__MyAccountRequest;	/* optional element of type ns1:MyAccountRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__UpdateUser
#define SOAP_TYPE___ns1__UpdateUser (918)
/* Operation wrapper: */
struct __ns1__UpdateUser
{
public:
	_ns1__UpdateUserRequest *ns1__UpdateUserRequest;	/* optional element of type ns1:UpdateUserRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__UpdateUserInput
#define SOAP_TYPE___ns1__UpdateUserInput (922)
/* Operation wrapper: */
struct __ns1__UpdateUserInput
{
public:
	_ns1__UpdateUserInputRequest *ns1__UpdateUserInputRequest;	/* optional element of type ns1:UpdateUserInputRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__VerifyUser
#define SOAP_TYPE___ns1__VerifyUser (926)
/* Operation wrapper: */
struct __ns1__VerifyUser
{
public:
	_ns1__VerifyUserRequest *ns1__VerifyUserRequest;	/* optional element of type ns1:VerifyUserRequest */
};
#endif

#ifndef SOAP_TYPE___ns2__CheckinAttributes
#define SOAP_TYPE___ns2__CheckinAttributes (930)
/* Operation wrapper: */
struct __ns2__CheckinAttributes
{
public:
	_ns2__CheckinAttributes *ns2__CheckinAttributes;	/* optional element of type ns2:CheckinAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__CheckoutAttributes
#define SOAP_TYPE___ns2__CheckoutAttributes (933)
/* Operation wrapper: */
struct __ns2__CheckoutAttributes
{
public:
	_ns2__CheckoutAttributes *ns2__CheckoutAttributes;	/* optional element of type ns2:CheckoutAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__CreateAttribute
#define SOAP_TYPE___ns2__CreateAttribute (937)
/* Operation wrapper: */
struct __ns2__CreateAttribute
{
public:
	_ns2__CreateAttribute *ns2__CreateAttribute;	/* optional element of type ns2:CreateAttribute */
};
#endif

#ifndef SOAP_TYPE___ns2__CreateLabel
#define SOAP_TYPE___ns2__CreateLabel (941)
/* Operation wrapper: */
struct __ns2__CreateLabel
{
public:
	_ns2__CreateLabel *ns2__CreateLabel;	/* optional element of type ns2:CreateLabel */
};
#endif

#ifndef SOAP_TYPE___ns2__CreateModule
#define SOAP_TYPE___ns2__CreateModule (945)
/* Operation wrapper: */
struct __ns2__CreateModule
{
public:
	_ns2__CreateModule *ns2__CreateModule;	/* optional element of type ns2:CreateModule */
};
#endif

#ifndef SOAP_TYPE___ns2__DeleteAttributes
#define SOAP_TYPE___ns2__DeleteAttributes (948)
/* Operation wrapper: */
struct __ns2__DeleteAttributes
{
public:
	_ns2__DeleteAttributes *ns2__DeleteAttributes;	/* optional element of type ns2:DeleteAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__DeleteLabel
#define SOAP_TYPE___ns2__DeleteLabel (952)
/* Operation wrapper: */
struct __ns2__DeleteLabel
{
public:
	_ns2__DeleteLabel *ns2__DeleteLabel;	/* optional element of type ns2:DeleteLabel */
};
#endif

#ifndef SOAP_TYPE___ns2__DeleteModule
#define SOAP_TYPE___ns2__DeleteModule (956)
/* Operation wrapper: */
struct __ns2__DeleteModule
{
public:
	_ns2__DeleteModule *ns2__DeleteModule;	/* optional element of type ns2:DeleteModule */
};
#endif

#ifndef SOAP_TYPE___ns2__FindAttributes
#define SOAP_TYPE___ns2__FindAttributes (960)
/* Operation wrapper: */
struct __ns2__FindAttributes
{
public:
	_ns2__FindAttributes *ns2__FindAttributes;	/* optional element of type ns2:FindAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttribute
#define SOAP_TYPE___ns2__GetAttribute (964)
/* Operation wrapper: */
struct __ns2__GetAttribute
{
public:
	_ns2__GetAttribute *ns2__GetAttribute;	/* optional element of type ns2:GetAttribute */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttributeHistory
#define SOAP_TYPE___ns2__GetAttributeHistory (968)
/* Operation wrapper: */
struct __ns2__GetAttributeHistory
{
public:
	_ns2__GetAttributeHistory *ns2__GetAttributeHistory;	/* optional element of type ns2:GetAttributeHistory */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttributeLabels
#define SOAP_TYPE___ns2__GetAttributeLabels (972)
/* Operation wrapper: */
struct __ns2__GetAttributeLabels
{
public:
	_ns2__GetAttributeLabels *ns2__GetAttributeLabels;	/* optional element of type ns2:GetAttributeLabels */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttributes
#define SOAP_TYPE___ns2__GetAttributes (976)
/* Operation wrapper: */
struct __ns2__GetAttributes
{
public:
	_ns2__GetAttributes *ns2__GetAttributes;	/* optional element of type ns2:GetAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__GetLabels
#define SOAP_TYPE___ns2__GetLabels (980)
/* Operation wrapper: */
struct __ns2__GetLabels
{
public:
	_ns2__GetLabels *ns2__GetLabels;	/* optional element of type ns2:GetLabels */
};
#endif

#ifndef SOAP_TYPE___ns2__GetModules
#define SOAP_TYPE___ns2__GetModules (984)
/* Operation wrapper: */
struct __ns2__GetModules
{
public:
	_ns2__GetModules *ns2__GetModules;	/* optional element of type ns2:GetModules */
};
#endif

#ifndef SOAP_TYPE___ns2__ImportAttributes
#define SOAP_TYPE___ns2__ImportAttributes (987)
/* Operation wrapper: */
struct __ns2__ImportAttributes
{
public:
	_ns2__ImportAttributes *ns2__ImportAttributes;	/* optional element of type ns2:ImportAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__ListAttributeTypes
#define SOAP_TYPE___ns2__ListAttributeTypes (991)
/* Operation wrapper: */
struct __ns2__ListAttributeTypes
{
public:
	_ns2__ListAttributeTypes *ns2__ListAttributeTypes;	/* optional element of type ns2:ListAttributeTypes */
};
#endif

#ifndef SOAP_TYPE___ns2__RenameAttributes
#define SOAP_TYPE___ns2__RenameAttributes (994)
/* Operation wrapper: */
struct __ns2__RenameAttributes
{
public:
	_ns2__RenameAttributes *ns2__RenameAttributes;	/* optional element of type ns2:RenameAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__RenameModule
#define SOAP_TYPE___ns2__RenameModule (998)
/* Operation wrapper: */
struct __ns2__RenameModule
{
public:
	_ns2__RenameModule *ns2__RenameModule;	/* optional element of type ns2:RenameModule */
};
#endif

#ifndef SOAP_TYPE___ns2__RollbackAttributes
#define SOAP_TYPE___ns2__RollbackAttributes (1001)
/* Operation wrapper: */
struct __ns2__RollbackAttributes
{
public:
	_ns2__RollbackAttributes *ns2__RollbackAttributes;	/* optional element of type ns2:RollbackAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__SaveAttributes
#define SOAP_TYPE___ns2__SaveAttributes (1004)
/* Operation wrapper: */
struct __ns2__SaveAttributes
{
public:
	_ns2__SaveAttributes *ns2__SaveAttributes;	/* optional element of type ns2:SaveAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__SupportsEarMark
#define SOAP_TYPE___ns2__SupportsEarMark (1008)
/* Operation wrapper: */
struct __ns2__SupportsEarMark
{
public:
	_ns2__SupportsEarMark *ns2__SupportsEarMark;	/* optional element of type ns2:SupportsEarMark */
};
#endif

#ifndef SOAP_TYPE___ns2__UpdateLabel
#define SOAP_TYPE___ns2__UpdateLabel (1012)
/* Operation wrapper: */
struct __ns2__UpdateLabel
{
public:
	_ns2__UpdateLabel *ns2__UpdateLabel;	/* optional element of type ns2:UpdateLabel */
};
#endif

#ifndef SOAP_TYPE___ns3__Add
#define SOAP_TYPE___ns3__Add (1016)
/* Operation wrapper: */
struct __ns3__Add
{
public:
	_ns3__AddRequest *ns3__AddRequest;	/* optional element of type ns3:AddRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__AddRemote
#define SOAP_TYPE___ns3__AddRemote (1020)
/* Operation wrapper: */
struct __ns3__AddRemote
{
public:
	_ns3__AddRemoteRequest *ns3__AddRemoteRequest;	/* optional element of type ns3:AddRemoteRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__AddtoSuperfile
#define SOAP_TYPE___ns3__AddtoSuperfile (1024)
/* Operation wrapper: */
struct __ns3__AddtoSuperfile
{
public:
	_ns3__AddtoSuperfileRequest *ns3__AddtoSuperfileRequest;	/* optional element of type ns3:AddtoSuperfileRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUArrayAction
#define SOAP_TYPE___ns3__DFUArrayAction (1028)
/* Operation wrapper: */
struct __ns3__DFUArrayAction
{
public:
	_ns3__DFUArrayActionRequest *ns3__DFUArrayActionRequest;	/* optional element of type ns3:DFUArrayActionRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUBrowseData
#define SOAP_TYPE___ns3__DFUBrowseData (1032)
/* Operation wrapper: */
struct __ns3__DFUBrowseData
{
public:
	_ns3__DFUBrowseDataRequest *ns3__DFUBrowseDataRequest;	/* optional element of type ns3:DFUBrowseDataRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUDefFile
#define SOAP_TYPE___ns3__DFUDefFile (1036)
/* Operation wrapper: */
struct __ns3__DFUDefFile
{
public:
	_ns3__DFUDefFileRequest *ns3__DFUDefFileRequest;	/* optional element of type ns3:DFUDefFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUFileView
#define SOAP_TYPE___ns3__DFUFileView (1040)
/* Operation wrapper: */
struct __ns3__DFUFileView
{
public:
	_ns3__DFUFileViewRequest *ns3__DFUFileViewRequest;	/* optional element of type ns3:DFUFileViewRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUGetDataColumns
#define SOAP_TYPE___ns3__DFUGetDataColumns (1044)
/* Operation wrapper: */
struct __ns3__DFUGetDataColumns
{
public:
	_ns3__DFUGetDataColumnsRequest *ns3__DFUGetDataColumnsRequest;	/* optional element of type ns3:DFUGetDataColumnsRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUGetFileMetaData
#define SOAP_TYPE___ns3__DFUGetFileMetaData (1048)
/* Operation wrapper: */
struct __ns3__DFUGetFileMetaData
{
public:
	_ns3__DFUGetFileMetaDataRequest *ns3__DFUGetFileMetaDataRequest;	/* optional element of type ns3:DFUGetFileMetaDataRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUInfo
#define SOAP_TYPE___ns3__DFUInfo (1052)
/* Operation wrapper: */
struct __ns3__DFUInfo
{
public:
	_ns3__DFUInfoRequest *ns3__DFUInfoRequest;	/* optional element of type ns3:DFUInfoRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUQuery
#define SOAP_TYPE___ns3__DFUQuery (1056)
/* Operation wrapper: */
struct __ns3__DFUQuery
{
public:
	_ns3__DFUQueryRequest *ns3__DFUQueryRequest;	/* optional element of type ns3:DFUQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUSearch
#define SOAP_TYPE___ns3__DFUSearch (1060)
/* Operation wrapper: */
struct __ns3__DFUSearch
{
public:
	_ns3__DFUSearchRequest *ns3__DFUSearchRequest;	/* optional element of type ns3:DFUSearchRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUSearchData
#define SOAP_TYPE___ns3__DFUSearchData (1064)
/* Operation wrapper: */
struct __ns3__DFUSearchData
{
public:
	_ns3__DFUSearchDataRequest *ns3__DFUSearchDataRequest;	/* optional element of type ns3:DFUSearchDataRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUSpace
#define SOAP_TYPE___ns3__DFUSpace (1068)
/* Operation wrapper: */
struct __ns3__DFUSpace
{
public:
	_ns3__DFUSpaceRequest *ns3__DFUSpaceRequest;	/* optional element of type ns3:DFUSpaceRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__EraseHistory
#define SOAP_TYPE___ns3__EraseHistory (1072)
/* Operation wrapper: */
struct __ns3__EraseHistory
{
public:
	_ns3__EraseHistoryRequest *ns3__EraseHistoryRequest;	/* optional element of type ns3:EraseHistoryRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__ListHistory
#define SOAP_TYPE___ns3__ListHistory (1076)
/* Operation wrapper: */
struct __ns3__ListHistory
{
public:
	_ns3__ListHistoryRequest *ns3__ListHistoryRequest;	/* optional element of type ns3:ListHistoryRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__Savexml
#define SOAP_TYPE___ns3__Savexml (1080)
/* Operation wrapper: */
struct __ns3__Savexml
{
public:
	_ns3__SavexmlRequest *ns3__SavexmlRequest;	/* optional element of type ns3:SavexmlRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__SuperfileAction
#define SOAP_TYPE___ns3__SuperfileAction (1084)
/* Operation wrapper: */
struct __ns3__SuperfileAction
{
public:
	_ns3__SuperfileActionRequest *ns3__SuperfileActionRequest;	/* optional element of type ns3:SuperfileActionRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__SuperfileList
#define SOAP_TYPE___ns3__SuperfileList (1088)
/* Operation wrapper: */
struct __ns3__SuperfileList
{
public:
	_ns3__SuperfileListRequest *ns3__SuperfileListRequest;	/* optional element of type ns3:SuperfileListRequest */
};
#endif

#ifndef SOAP_TYPE___ns4__Activity
#define SOAP_TYPE___ns4__Activity (1092)
/* Operation wrapper: */
struct __ns4__Activity
{
public:
	_ns4__Activity *ns4__Activity;	/* optional element of type ns4:Activity */
};
#endif

#ifndef SOAP_TYPE___ns4__BrowseResources
#define SOAP_TYPE___ns4__BrowseResources (1096)
/* Operation wrapper: */
struct __ns4__BrowseResources
{
public:
	_ns4__BrowseResources *ns4__BrowseResources;	/* optional element of type ns4:BrowseResources */
};
#endif

#ifndef SOAP_TYPE___ns4__ClearQueue
#define SOAP_TYPE___ns4__ClearQueue (1100)
/* Operation wrapper: */
struct __ns4__ClearQueue
{
public:
	_ns4__ClearQueue *ns4__ClearQueue;	/* optional element of type ns4:ClearQueue */
};
#endif

#ifndef SOAP_TYPE___ns4__GetStatusServerInfo
#define SOAP_TYPE___ns4__GetStatusServerInfo (1104)
/* Operation wrapper: */
struct __ns4__GetStatusServerInfo
{
public:
	_ns4__GetStatusServerInfo *ns4__GetStatusServerInfo;	/* optional element of type ns4:GetStatusServerInfo */
};
#endif

#ifndef SOAP_TYPE___ns4__GetThorQueueAvailability
#define SOAP_TYPE___ns4__GetThorQueueAvailability (1108)
/* Operation wrapper: */
struct __ns4__GetThorQueueAvailability
{
public:
	_ns4__GetThorQueueAvailability *ns4__GetThorQueueAvailability;	/* optional element of type ns4:GetThorQueueAvailability */
};
#endif

#ifndef SOAP_TYPE___ns4__Index
#define SOAP_TYPE___ns4__Index (1112)
/* Operation wrapper: */
struct __ns4__Index
{
public:
	_ns4__Index *ns4__Index;	/* optional element of type ns4:Index */
};
#endif

#ifndef SOAP_TYPE___ns4__LockQuery
#define SOAP_TYPE___ns4__LockQuery (1116)
/* Operation wrapper: */
struct __ns4__LockQuery
{
public:
	_ns4__LockQuery *ns4__LockQuery;	/* optional element of type ns4:LockQuery */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobBack
#define SOAP_TYPE___ns4__MoveJobBack (1120)
/* Operation wrapper: */
struct __ns4__MoveJobBack
{
public:
	_ns4__MoveJobBack *ns4__MoveJobBack;	/* optional element of type ns4:MoveJobBack */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobDown
#define SOAP_TYPE___ns4__MoveJobDown (1123)
/* Operation wrapper: */
struct __ns4__MoveJobDown
{
public:
	_ns4__MoveJobDown *ns4__MoveJobDown;	/* optional element of type ns4:MoveJobDown */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobFront
#define SOAP_TYPE___ns4__MoveJobFront (1126)
/* Operation wrapper: */
struct __ns4__MoveJobFront
{
public:
	_ns4__MoveJobFront *ns4__MoveJobFront;	/* optional element of type ns4:MoveJobFront */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobUp
#define SOAP_TYPE___ns4__MoveJobUp (1129)
/* Operation wrapper: */
struct __ns4__MoveJobUp
{
public:
	_ns4__MoveJobUp *ns4__MoveJobUp;	/* optional element of type ns4:MoveJobUp */
};
#endif

#ifndef SOAP_TYPE___ns4__NotInCommunityEdition
#define SOAP_TYPE___ns4__NotInCommunityEdition (1133)
/* Operation wrapper: */
struct __ns4__NotInCommunityEdition
{
public:
	_ns4__NotInCommunityEdition *ns4__NotInCommunityEdition;	/* optional element of type ns4:NotInCommunityEdition */
};
#endif

#ifndef SOAP_TYPE___ns4__PauseQueue
#define SOAP_TYPE___ns4__PauseQueue (1136)
/* Operation wrapper: */
struct __ns4__PauseQueue
{
public:
	_ns4__PauseQueue *ns4__PauseQueue;	/* optional element of type ns4:PauseQueue */
};
#endif

#ifndef SOAP_TYPE___ns4__RemoveJob
#define SOAP_TYPE___ns4__RemoveJob (1139)
/* Operation wrapper: */
struct __ns4__RemoveJob
{
public:
	_ns4__RemoveJob *ns4__RemoveJob;	/* optional element of type ns4:RemoveJob */
};
#endif

#ifndef SOAP_TYPE___ns4__ResumeQueue
#define SOAP_TYPE___ns4__ResumeQueue (1142)
/* Operation wrapper: */
struct __ns4__ResumeQueue
{
public:
	_ns4__ResumeQueue *ns4__ResumeQueue;	/* optional element of type ns4:ResumeQueue */
};
#endif

#ifndef SOAP_TYPE___ns4__RoxieControlCmd
#define SOAP_TYPE___ns4__RoxieControlCmd (1146)
/* Operation wrapper: */
struct __ns4__RoxieControlCmd
{
public:
	_ns4__RoxieControlCmd *ns4__RoxieControlCmd;	/* optional element of type ns4:RoxieControlCmd */
};
#endif

#ifndef SOAP_TYPE___ns4__SetBanner
#define SOAP_TYPE___ns4__SetBanner (1150)
/* Operation wrapper: */
struct __ns4__SetBanner
{
public:
	_ns4__SetBanner *ns4__SetBanner;	/* optional element of type ns4:SetBanner */
};
#endif

#ifndef SOAP_TYPE___ns4__SetJobPriority
#define SOAP_TYPE___ns4__SetJobPriority (1154)
/* Operation wrapper: */
struct __ns4__SetJobPriority
{
public:
	_ns4__SetJobPriority *ns4__SetJobPriority;	/* optional element of type ns4:SetJobPriority */
};
#endif

#ifndef SOAP_TYPE___ns4__StopQueue
#define SOAP_TYPE___ns4__StopQueue (1157)
/* Operation wrapper: */
struct __ns4__StopQueue
{
public:
	_ns4__StopQueue *ns4__StopQueue;	/* optional element of type ns4:StopQueue */
};
#endif

#ifndef SOAP_TYPE___ns5__SystemLog
#define SOAP_TYPE___ns5__SystemLog (1161)
/* Operation wrapper: */
struct __ns5__SystemLog
{
public:
	_ns5__SystemLogRequest *ns5__SystemLogRequest;	/* optional element of type ns5:SystemLogRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpClusterInfo
#define SOAP_TYPE___ns5__TpClusterInfo (1165)
/* Operation wrapper: */
struct __ns5__TpClusterInfo
{
public:
	_ns5__TpClusterInfoRequest *ns5__TpClusterInfoRequest;	/* optional element of type ns5:TpClusterInfoRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpClusterQuery
#define SOAP_TYPE___ns5__TpClusterQuery (1169)
/* Operation wrapper: */
struct __ns5__TpClusterQuery
{
public:
	_ns5__TpClusterQueryRequest *ns5__TpClusterQueryRequest;	/* optional element of type ns5:TpClusterQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpDropZoneQuery
#define SOAP_TYPE___ns5__TpDropZoneQuery (1173)
/* Operation wrapper: */
struct __ns5__TpDropZoneQuery
{
public:
	_ns5__TpDropZoneQueryRequest *ns5__TpDropZoneQueryRequest;	/* optional element of type ns5:TpDropZoneQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpGetComponentFile
#define SOAP_TYPE___ns5__TpGetComponentFile (1177)
/* Operation wrapper: */
struct __ns5__TpGetComponentFile
{
public:
	_ns5__TpGetComponentFileRequest *ns5__TpGetComponentFileRequest;	/* optional element of type ns5:TpGetComponentFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpGetServicePlugins
#define SOAP_TYPE___ns5__TpGetServicePlugins (1181)
/* Operation wrapper: */
struct __ns5__TpGetServicePlugins
{
public:
	_ns5__TpGetServicePluginsRequest *ns5__TpGetServicePluginsRequest;	/* optional element of type ns5:TpGetServicePluginsRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpGroupQuery
#define SOAP_TYPE___ns5__TpGroupQuery (1185)
/* Operation wrapper: */
struct __ns5__TpGroupQuery
{
public:
	_ns5__TpGroupQueryRequest *ns5__TpGroupQueryRequest;	/* optional element of type ns5:TpGroupQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpListTargetClusters
#define SOAP_TYPE___ns5__TpListTargetClusters (1189)
/* Operation wrapper: */
struct __ns5__TpListTargetClusters
{
public:
	_ns5__TpListTargetClustersRequest *ns5__TpListTargetClustersRequest;	/* optional element of type ns5:TpListTargetClustersRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpLogFile
#define SOAP_TYPE___ns5__TpLogFile (1193)
/* Operation wrapper: */
struct __ns5__TpLogFile
{
public:
	_ns5__TpLogFileRequest *ns5__TpLogFileRequest;	/* optional element of type ns5:TpLogFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpLogFileDisplay
#define SOAP_TYPE___ns5__TpLogFileDisplay (1195)
/* Operation wrapper: */
struct __ns5__TpLogFileDisplay
{
public:
	_ns5__TpLogFileRequest *ns5__TpLogFileRequest;	/* optional element of type ns5:TpLogFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpLogicalClusterQuery
#define SOAP_TYPE___ns5__TpLogicalClusterQuery (1199)
/* Operation wrapper: */
struct __ns5__TpLogicalClusterQuery
{
public:
	_ns5__TpLogicalClusterQueryRequest *ns5__TpLogicalClusterQueryRequest;	/* optional element of type ns5:TpLogicalClusterQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpMachineInfo
#define SOAP_TYPE___ns5__TpMachineInfo (1203)
/* Operation wrapper: */
struct __ns5__TpMachineInfo
{
public:
	_ns5__TpMachineInfoRequest *ns5__TpMachineInfoRequest;	/* optional element of type ns5:TpMachineInfoRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpMachineQuery
#define SOAP_TYPE___ns5__TpMachineQuery (1207)
/* Operation wrapper: */
struct __ns5__TpMachineQuery
{
public:
	_ns5__TpMachineQueryRequest *ns5__TpMachineQueryRequest;	/* optional element of type ns5:TpMachineQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpServiceQuery
#define SOAP_TYPE___ns5__TpServiceQuery (1211)
/* Operation wrapper: */
struct __ns5__TpServiceQuery
{
public:
	_ns5__TpServiceQueryRequest *ns5__TpServiceQueryRequest;	/* optional element of type ns5:TpServiceQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpSetMachineStatus
#define SOAP_TYPE___ns5__TpSetMachineStatus (1215)
/* Operation wrapper: */
struct __ns5__TpSetMachineStatus
{
public:
	_ns5__TpSetMachineStatusRequest *ns5__TpSetMachineStatusRequest;	/* optional element of type ns5:TpSetMachineStatusRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpSwapNode
#define SOAP_TYPE___ns5__TpSwapNode (1219)
/* Operation wrapper: */
struct __ns5__TpSwapNode
{
public:
	_ns5__TpSwapNodeRequest *ns5__TpSwapNodeRequest;	/* optional element of type ns5:TpSwapNodeRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpTargetClusterQuery
#define SOAP_TYPE___ns5__TpTargetClusterQuery (1223)
/* Operation wrapper: */
struct __ns5__TpTargetClusterQuery
{
public:
	_ns5__TpTargetClusterQueryRequest *ns5__TpTargetClusterQueryRequest;	/* optional element of type ns5:TpTargetClusterQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpThorStatus
#define SOAP_TYPE___ns5__TpThorStatus (1227)
/* Operation wrapper: */
struct __ns5__TpThorStatus
{
public:
	_ns5__TpThorStatusRequest *ns5__TpThorStatusRequest;	/* optional element of type ns5:TpThorStatusRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpXMLFile
#define SOAP_TYPE___ns5__TpXMLFile (1231)
/* Operation wrapper: */
struct __ns5__TpXMLFile
{
public:
	_ns5__TpXMLFileRequest *ns5__TpXMLFileRequest;	/* optional element of type ns5:TpXMLFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns6__GVCAjaxGraph
#define SOAP_TYPE___ns6__GVCAjaxGraph (1235)
/* Operation wrapper: */
struct __ns6__GVCAjaxGraph
{
public:
	_ns6__GVCAjaxGraph *ns6__GVCAjaxGraph;	/* optional element of type ns6:GVCAjaxGraph */
};
#endif

#ifndef SOAP_TYPE___ns6__WUAbort
#define SOAP_TYPE___ns6__WUAbort (1239)
/* Operation wrapper: */
struct __ns6__WUAbort
{
public:
	_ns6__WUAbort *ns6__WUAbort;	/* optional element of type ns6:WUAbort */
};
#endif

#ifndef SOAP_TYPE___ns6__WUAction
#define SOAP_TYPE___ns6__WUAction (1243)
/* Operation wrapper: */
struct __ns6__WUAction
{
public:
	_ns6__WUAction *ns6__WUAction;	/* optional element of type ns6:WUAction */
};
#endif

#ifndef SOAP_TYPE___ns6__WUAddLocalFileToWorkunit
#define SOAP_TYPE___ns6__WUAddLocalFileToWorkunit (1247)
/* Operation wrapper: */
struct __ns6__WUAddLocalFileToWorkunit
{
public:
	_ns6__WUAddLocalFileToWorkunit *ns6__WUAddLocalFileToWorkunit;	/* optional element of type ns6:WUAddLocalFileToWorkunit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCDebug
#define SOAP_TYPE___ns6__WUCDebug (1251)
/* Operation wrapper: */
struct __ns6__WUCDebug
{
public:
	_ns6__WUCDebug *ns6__WUCDebug;	/* optional element of type ns6:WUCDebug */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCheckFeatures
#define SOAP_TYPE___ns6__WUCheckFeatures (1255)
/* Operation wrapper: */
struct __ns6__WUCheckFeatures
{
public:
	_ns6__WUCheckFeatures *ns6__WUCheckFeatures;	/* optional element of type ns6:WUCheckFeatures */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobQueueLOG
#define SOAP_TYPE___ns6__WUClusterJobQueueLOG (1259)
/* Operation wrapper: */
struct __ns6__WUClusterJobQueueLOG
{
public:
	_ns6__WUClusterJobQueueLOG *ns6__WUClusterJobQueueLOG;	/* optional element of type ns6:WUClusterJobQueueLOG */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobQueueXLS
#define SOAP_TYPE___ns6__WUClusterJobQueueXLS (1263)
/* Operation wrapper: */
struct __ns6__WUClusterJobQueueXLS
{
public:
	_ns6__WUClusterJobQueueXLS *ns6__WUClusterJobQueueXLS;	/* optional element of type ns6:WUClusterJobQueueXLS */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobSummaryXLS
#define SOAP_TYPE___ns6__WUClusterJobSummaryXLS (1267)
/* Operation wrapper: */
struct __ns6__WUClusterJobSummaryXLS
{
public:
	_ns6__WUClusterJobSummaryXLS *ns6__WUClusterJobSummaryXLS;	/* optional element of type ns6:WUClusterJobSummaryXLS */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobXLS
#define SOAP_TYPE___ns6__WUClusterJobXLS (1271)
/* Operation wrapper: */
struct __ns6__WUClusterJobXLS
{
public:
	_ns6__WUClusterJobXLS *ns6__WUClusterJobXLS;	/* optional element of type ns6:WUClusterJobXLS */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCompileECL
#define SOAP_TYPE___ns6__WUCompileECL (1275)
/* Operation wrapper: */
struct __ns6__WUCompileECL
{
public:
	_ns6__WUCompileECL *ns6__WUCompileECL;	/* optional element of type ns6:WUCompileECL */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCopyLogicalFiles
#define SOAP_TYPE___ns6__WUCopyLogicalFiles (1279)
/* Operation wrapper: */
struct __ns6__WUCopyLogicalFiles
{
public:
	_ns6__WUCopyLogicalFiles *ns6__WUCopyLogicalFiles;	/* optional element of type ns6:WUCopyLogicalFiles */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCopyQuerySet
#define SOAP_TYPE___ns6__WUCopyQuerySet (1283)
/* Operation wrapper: */
struct __ns6__WUCopyQuerySet
{
public:
	_ns6__WUCopyQuerySet *ns6__WUCopyQuerySet;	/* optional element of type ns6:WUCopyQuerySet */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCreate
#define SOAP_TYPE___ns6__WUCreate (1287)
/* Operation wrapper: */
struct __ns6__WUCreate
{
public:
	_ns6__WUCreate *ns6__WUCreate;	/* optional element of type ns6:WUCreate */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCreateAndUpdate
#define SOAP_TYPE___ns6__WUCreateAndUpdate (1291)
/* Operation wrapper: */
struct __ns6__WUCreateAndUpdate
{
public:
	_ns6__WUCreateAndUpdate *ns6__WUCreateAndUpdate;	/* optional element of type ns6:WUCreateAndUpdate */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCreateZAPInfo
#define SOAP_TYPE___ns6__WUCreateZAPInfo (1295)
/* Operation wrapper: */
struct __ns6__WUCreateZAPInfo
{
public:
	_ns6__WUCreateZAPInfo *ns6__WUCreateZAPInfo;	/* optional element of type ns6:WUCreateZAPInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUDelete
#define SOAP_TYPE___ns6__WUDelete (1299)
/* Operation wrapper: */
struct __ns6__WUDelete
{
public:
	_ns6__WUDelete *ns6__WUDelete;	/* optional element of type ns6:WUDelete */
};
#endif

#ifndef SOAP_TYPE___ns6__WUDeployWorkunit
#define SOAP_TYPE___ns6__WUDeployWorkunit (1303)
/* Operation wrapper: */
struct __ns6__WUDeployWorkunit
{
public:
	_ns6__WUDeployWorkunit *ns6__WUDeployWorkunit;	/* optional element of type ns6:WUDeployWorkunit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUExport
#define SOAP_TYPE___ns6__WUExport (1307)
/* Operation wrapper: */
struct __ns6__WUExport
{
public:
	_ns6__WUExport *ns6__WUExport;	/* optional element of type ns6:WUExport */
};
#endif

#ifndef SOAP_TYPE___ns6__WUFile
#define SOAP_TYPE___ns6__WUFile (1311)
/* Operation wrapper: */
struct __ns6__WUFile
{
public:
	_ns6__WUFile *ns6__WUFile;	/* optional element of type ns6:WUFile */
};
#endif

#ifndef SOAP_TYPE___ns6__WUFullResult
#define SOAP_TYPE___ns6__WUFullResult (1315)
/* Operation wrapper: */
struct __ns6__WUFullResult
{
public:
	_ns6__WUFullResult *ns6__WUFullResult;	/* optional element of type ns6:WUFullResult */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGVCGraphInfo
#define SOAP_TYPE___ns6__WUGVCGraphInfo (1319)
/* Operation wrapper: */
struct __ns6__WUGVCGraphInfo
{
public:
	_ns6__WUGVCGraphInfo *ns6__WUGVCGraphInfo;	/* optional element of type ns6:WUGVCGraphInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetArchiveFile
#define SOAP_TYPE___ns6__WUGetArchiveFile (1323)
/* Operation wrapper: */
struct __ns6__WUGetArchiveFile
{
public:
	_ns6__WUGetArchiveFile *ns6__WUGetArchiveFile;	/* optional element of type ns6:WUGetArchiveFile */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetDependancyTrees
#define SOAP_TYPE___ns6__WUGetDependancyTrees (1327)
/* Operation wrapper: */
struct __ns6__WUGetDependancyTrees
{
public:
	_ns6__WUGetDependancyTrees *ns6__WUGetDependancyTrees;	/* optional element of type ns6:WUGetDependancyTrees */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetGraph
#define SOAP_TYPE___ns6__WUGetGraph (1331)
/* Operation wrapper: */
struct __ns6__WUGetGraph
{
public:
	_ns6__WUGetGraph *ns6__WUGetGraph;	/* optional element of type ns6:WUGetGraph */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetGraphNameAndTypes
#define SOAP_TYPE___ns6__WUGetGraphNameAndTypes (1335)
/* Operation wrapper: */
struct __ns6__WUGetGraphNameAndTypes
{
public:
	_ns6__WUGetGraphNameAndTypes *ns6__WUGetGraphNameAndTypes;	/* optional element of type ns6:WUGetGraphNameAndTypes */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetNumFileToCopy
#define SOAP_TYPE___ns6__WUGetNumFileToCopy (1339)
/* Operation wrapper: */
struct __ns6__WUGetNumFileToCopy
{
public:
	_ns6__WUGetNumFileToCopy *ns6__WUGetNumFileToCopy;	/* optional element of type ns6:WUGetNumFileToCopy */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetStats
#define SOAP_TYPE___ns6__WUGetStats (1343)
/* Operation wrapper: */
struct __ns6__WUGetStats
{
public:
	_ns6__WUGetStats *ns6__WUGetStats;	/* optional element of type ns6:WUGetStats */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetZAPInfo
#define SOAP_TYPE___ns6__WUGetZAPInfo (1347)
/* Operation wrapper: */
struct __ns6__WUGetZAPInfo
{
public:
	_ns6__WUGetZAPInfo *ns6__WUGetZAPInfo;	/* optional element of type ns6:WUGetZAPInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGraphInfo
#define SOAP_TYPE___ns6__WUGraphInfo (1351)
/* Operation wrapper: */
struct __ns6__WUGraphInfo
{
public:
	_ns6__WUGraphInfo *ns6__WUGraphInfo;	/* optional element of type ns6:WUGraphInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGraphTiming
#define SOAP_TYPE___ns6__WUGraphTiming (1355)
/* Operation wrapper: */
struct __ns6__WUGraphTiming
{
public:
	_ns6__WUGraphTiming *ns6__WUGraphTiming;	/* optional element of type ns6:WUGraphTiming */
};
#endif

#ifndef SOAP_TYPE___ns6__WUInfo
#define SOAP_TYPE___ns6__WUInfo (1359)
/* Operation wrapper: */
struct __ns6__WUInfo
{
public:
	_ns6__WUInfo *ns6__WUInfo;	/* optional element of type ns6:WUInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUInfoDetails
#define SOAP_TYPE___ns6__WUInfoDetails (1362)
/* Operation wrapper: */
struct __ns6__WUInfoDetails
{
public:
	_ns6__WUInfoDetails *ns6__WUInfoDetails;	/* optional element of type ns6:WUInfoDetails */
};
#endif

#ifndef SOAP_TYPE___ns6__WUJobList
#define SOAP_TYPE___ns6__WUJobList (1366)
/* Operation wrapper: */
struct __ns6__WUJobList
{
public:
	_ns6__WUJobList *ns6__WUJobList;	/* optional element of type ns6:WUJobList */
};
#endif

#ifndef SOAP_TYPE___ns6__WULightWeightQuery
#define SOAP_TYPE___ns6__WULightWeightQuery (1370)
/* Operation wrapper: */
struct __ns6__WULightWeightQuery
{
public:
	_ns6__WULightWeightQuery *ns6__WULightWeightQuery;	/* optional element of type ns6:WULightWeightQuery */
};
#endif

#ifndef SOAP_TYPE___ns6__WUListArchiveFiles
#define SOAP_TYPE___ns6__WUListArchiveFiles (1374)
/* Operation wrapper: */
struct __ns6__WUListArchiveFiles
{
public:
	_ns6__WUListArchiveFiles *ns6__WUListArchiveFiles;	/* optional element of type ns6:WUListArchiveFiles */
};
#endif

#ifndef SOAP_TYPE___ns6__WUListLocalFileRequired
#define SOAP_TYPE___ns6__WUListLocalFileRequired (1378)
/* Operation wrapper: */
struct __ns6__WUListLocalFileRequired
{
public:
	_ns6__WUListLocalFileRequired *ns6__WUListLocalFileRequired;	/* optional element of type ns6:WUListLocalFileRequired */
};
#endif

#ifndef SOAP_TYPE___ns6__WUListQueries
#define SOAP_TYPE___ns6__WUListQueries (1382)
/* Operation wrapper: */
struct __ns6__WUListQueries
{
public:
	_ns6__WUListQueries *ns6__WUListQueries;	/* optional element of type ns6:WUListQueries */
};
#endif

#ifndef SOAP_TYPE___ns6__WUListQueriesUsingFile
#define SOAP_TYPE___ns6__WUListQueriesUsingFile (1386)
/* Operation wrapper: */
struct __ns6__WUListQueriesUsingFile
{
public:
	_ns6__WUListQueriesUsingFile *ns6__WUListQueriesUsingFile;	/* optional element of type ns6:WUListQueriesUsingFile */
};
#endif

#ifndef SOAP_TYPE___ns6__WUMultiQuerysetDetails
#define SOAP_TYPE___ns6__WUMultiQuerysetDetails (1390)
/* Operation wrapper: */
struct __ns6__WUMultiQuerysetDetails
{
public:
	_ns6__WUMultiQuerysetDetails *ns6__WUMultiQuerysetDetails;	/* optional element of type ns6:WUMultiQuerysetDetails */
};
#endif

#ifndef SOAP_TYPE___ns6__WUProcessGraph
#define SOAP_TYPE___ns6__WUProcessGraph (1394)
/* Operation wrapper: */
struct __ns6__WUProcessGraph
{
public:
	_ns6__WUProcessGraph *ns6__WUProcessGraph;	/* optional element of type ns6:WUProcessGraph */
};
#endif

#ifndef SOAP_TYPE___ns6__WUProtect
#define SOAP_TYPE___ns6__WUProtect (1398)
/* Operation wrapper: */
struct __ns6__WUProtect
{
public:
	_ns6__WUProtect *ns6__WUProtect;	/* optional element of type ns6:WUProtect */
};
#endif

#ifndef SOAP_TYPE___ns6__WUPublishWorkunit
#define SOAP_TYPE___ns6__WUPublishWorkunit (1402)
/* Operation wrapper: */
struct __ns6__WUPublishWorkunit
{
public:
	_ns6__WUPublishWorkunit *ns6__WUPublishWorkunit;	/* optional element of type ns6:WUPublishWorkunit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUPushEvent
#define SOAP_TYPE___ns6__WUPushEvent (1406)
/* Operation wrapper: */
struct __ns6__WUPushEvent
{
public:
	_ns6__WUPushEvent *ns6__WUPushEvent;	/* optional element of type ns6:WUPushEvent */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuery
#define SOAP_TYPE___ns6__WUQuery (1410)
/* Operation wrapper: */
struct __ns6__WUQuery
{
public:
	_ns6__WUQuery *ns6__WUQuery;	/* optional element of type ns6:WUQuery */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQueryConfig
#define SOAP_TYPE___ns6__WUQueryConfig (1414)
/* Operation wrapper: */
struct __ns6__WUQueryConfig
{
public:
	_ns6__WUQueryConfig *ns6__WUQueryConfig;	/* optional element of type ns6:WUQueryConfig */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQueryDetails
#define SOAP_TYPE___ns6__WUQueryDetails (1418)
/* Operation wrapper: */
struct __ns6__WUQueryDetails
{
public:
	_ns6__WUQueryDetails *ns6__WUQueryDetails;	/* optional element of type ns6:WUQueryDetails */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQueryFiles
#define SOAP_TYPE___ns6__WUQueryFiles (1422)
/* Operation wrapper: */
struct __ns6__WUQueryFiles
{
public:
	_ns6__WUQueryFiles *ns6__WUQueryFiles;	/* optional element of type ns6:WUQueryFiles */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQueryGetGraph
#define SOAP_TYPE___ns6__WUQueryGetGraph (1426)
/* Operation wrapper: */
struct __ns6__WUQueryGetGraph
{
public:
	_ns6__WUQueryGetGraph *ns6__WUQueryGetGraph;	/* optional element of type ns6:WUQueryGetGraph */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetAliasAction
#define SOAP_TYPE___ns6__WUQuerysetAliasAction (1430)
/* Operation wrapper: */
struct __ns6__WUQuerysetAliasAction
{
public:
	_ns6__WUQuerysetAliasAction *ns6__WUQuerysetAliasAction;	/* optional element of type ns6:WUQuerysetAliasAction */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetCopyQuery
#define SOAP_TYPE___ns6__WUQuerysetCopyQuery (1434)
/* Operation wrapper: */
struct __ns6__WUQuerysetCopyQuery
{
public:
	_ns6__WUQuerysetCopyQuery *ns6__WUQuerysetCopyQuery;	/* optional element of type ns6:WUQuerysetCopyQuery */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetDetails
#define SOAP_TYPE___ns6__WUQuerysetDetails (1438)
/* Operation wrapper: */
struct __ns6__WUQuerysetDetails
{
public:
	_ns6__WUQuerysetDetails *ns6__WUQuerysetDetails;	/* optional element of type ns6:WUQuerysetDetails */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetQueryAction
#define SOAP_TYPE___ns6__WUQuerysetQueryAction (1442)
/* Operation wrapper: */
struct __ns6__WUQuerysetQueryAction
{
public:
	_ns6__WUQuerysetQueryAction *ns6__WUQuerysetQueryAction;	/* optional element of type ns6:WUQuerysetQueryAction */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysets
#define SOAP_TYPE___ns6__WUQuerysets (1446)
/* Operation wrapper: */
struct __ns6__WUQuerysets
{
public:
	_ns6__WUQuerysets *ns6__WUQuerysets;	/* optional element of type ns6:WUQuerysets */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResubmit
#define SOAP_TYPE___ns6__WUResubmit (1450)
/* Operation wrapper: */
struct __ns6__WUResubmit
{
public:
	_ns6__WUResubmit *ns6__WUResubmit;	/* optional element of type ns6:WUResubmit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResult
#define SOAP_TYPE___ns6__WUResult (1454)
/* Operation wrapper: */
struct __ns6__WUResult
{
public:
	_ns6__WUResult *ns6__WUResult;	/* optional element of type ns6:WUResult */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResultBin
#define SOAP_TYPE___ns6__WUResultBin (1458)
/* Operation wrapper: */
struct __ns6__WUResultBin
{
public:
	_ns6__WUResultBin *ns6__WUResultBin;	/* optional element of type ns6:WUResultBin */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResultSummary
#define SOAP_TYPE___ns6__WUResultSummary (1462)
/* Operation wrapper: */
struct __ns6__WUResultSummary
{
public:
	_ns6__WUResultSummary *ns6__WUResultSummary;	/* optional element of type ns6:WUResultSummary */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResultView
#define SOAP_TYPE___ns6__WUResultView (1466)
/* Operation wrapper: */
struct __ns6__WUResultView
{
public:
	_ns6__WUResultView *ns6__WUResultView;	/* optional element of type ns6:WUResultView */
};
#endif

#ifndef SOAP_TYPE___ns6__WURun
#define SOAP_TYPE___ns6__WURun (1470)
/* Operation wrapper: */
struct __ns6__WURun
{
public:
	_ns6__WURun *ns6__WURun;	/* optional element of type ns6:WURun */
};
#endif

#ifndef SOAP_TYPE___ns6__WUSchedule
#define SOAP_TYPE___ns6__WUSchedule (1474)
/* Operation wrapper: */
struct __ns6__WUSchedule
{
public:
	_ns6__WUSchedule *ns6__WUSchedule;	/* optional element of type ns6:WUSchedule */
};
#endif

#ifndef SOAP_TYPE___ns6__WUShowScheduled
#define SOAP_TYPE___ns6__WUShowScheduled (1478)
/* Operation wrapper: */
struct __ns6__WUShowScheduled
{
public:
	_ns6__WUShowScheduled *ns6__WUShowScheduled;	/* optional element of type ns6:WUShowScheduled */
};
#endif

#ifndef SOAP_TYPE___ns6__WUSubmit
#define SOAP_TYPE___ns6__WUSubmit (1482)
/* Operation wrapper: */
struct __ns6__WUSubmit
{
public:
	_ns6__WUSubmit *ns6__WUSubmit;	/* optional element of type ns6:WUSubmit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUSyntaxCheckECL
#define SOAP_TYPE___ns6__WUSyntaxCheckECL (1486)
/* Operation wrapper: */
struct __ns6__WUSyntaxCheckECL
{
public:
	_ns6__WUSyntaxCheckECL *ns6__WUSyntaxCheckECL;	/* optional element of type ns6:WUSyntaxCheckECL */
};
#endif

#ifndef SOAP_TYPE___ns6__WUUpdate
#define SOAP_TYPE___ns6__WUUpdate (1489)
/* Operation wrapper: */
struct __ns6__WUUpdate
{
public:
	_ns6__WUUpdate *ns6__WUUpdate;	/* optional element of type ns6:WUUpdate */
};
#endif

#ifndef SOAP_TYPE___ns6__WUUpdateQueryEntry
#define SOAP_TYPE___ns6__WUUpdateQueryEntry (1493)
/* Operation wrapper: */
struct __ns6__WUUpdateQueryEntry
{
public:
	_ns6__WUUpdateQueryEntry *ns6__WUUpdateQueryEntry;	/* optional element of type ns6:WUUpdateQueryEntry */
};
#endif

#ifndef SOAP_TYPE___ns6__WUWaitCompiled
#define SOAP_TYPE___ns6__WUWaitCompiled (1497)
/* Operation wrapper: */
struct __ns6__WUWaitCompiled
{
public:
	_ns6__WUWaitCompiled *ns6__WUWaitCompiled;	/* optional element of type ns6:WUWaitCompiled */
};
#endif

#ifndef SOAP_TYPE___ns6__WUWaitComplete
#define SOAP_TYPE___ns6__WUWaitComplete (1500)
/* Operation wrapper: */
struct __ns6__WUWaitComplete
{
public:
	_ns6__WUWaitComplete *ns6__WUWaitComplete;	/* optional element of type ns6:WUWaitComplete */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1501)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1502)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1504)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1505)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (15)
typedef std::wstring *xsd__string;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
