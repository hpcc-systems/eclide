/* soapStub.h
   Generated by gSOAP 2.7.15 from Services.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#if _COMMS_VER < 68201
#define SOAP_NAMESPACE_OF_ns1	"http://webservices.seisint.com/ws_account"
#define SOAP_NAMESPACE_OF_ns2	"http://webservices.seisint.com/WsAttributes"
#define SOAP_NAMESPACE_OF_ns3	"http://webservices.seisint.com/WsDfu"
#define SOAP_NAMESPACE_OF_ns4	"http://webservices.seisint.com/WsSMC"
#define SOAP_NAMESPACE_OF_ns5	"http://webservices.seisint.com/WsTopology"
#define SOAP_NAMESPACE_OF_ns6	"http://webservices.seisint.com/WsWorkunits"
#else
#define SOAP_NAMESPACE_OF_ns1	"urn:hpccsystems:ws:ws_account"
#define SOAP_NAMESPACE_OF_ns2	"urn:hpccsystems:ws:wsattributes"
#define SOAP_NAMESPACE_OF_ns3	"urn:hpccsystems:ws:wsdfu"
#define SOAP_NAMESPACE_OF_ns4	"urn:hpccsystems:ws:wssmc"
#define SOAP_NAMESPACE_OF_ns5	"urn:hpccsystems:ws:wstopology"
#define SOAP_NAMESPACE_OF_ns6	"urn:hpccsystems:ws:wsworkunits"
#endif
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns6__WUQuerySetFilterType
#define SOAP_TYPE_ns6__WUQuerySetFilterType (414)
/* ns6:WUQuerySetFilterType */
enum ns6__WUQuerySetFilterType {ns6__WUQuerySetFilterType__All = 0, ns6__WUQuerySetFilterType__Id = 1, ns6__WUQuerySetFilterType__Name = 2, ns6__WUQuerySetFilterType__Alias = 3, ns6__WUQuerySetFilterType__Status = 4};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAliasActionTypes
#define SOAP_TYPE_ns6__QuerySetAliasActionTypes (415)
/* ns6:QuerySetAliasActionTypes */
enum ns6__QuerySetAliasActionTypes {ns6__QuerySetAliasActionTypes__Deactivate = 0};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryActionTypes
#define SOAP_TYPE_ns6__QuerySetQueryActionTypes (416)
/* ns6:QuerySetQueryActionTypes */
enum ns6__QuerySetQueryActionTypes {ns6__QuerySetQueryActionTypes__Suspend = 0, ns6__QuerySetQueryActionTypes__Unsuspend = 1, ns6__QuerySetQueryActionTypes__ToggleSuspend = 2, ns6__QuerySetQueryActionTypes__Activate = 3, ns6__QuerySetQueryActionTypes__Delete = 4, ns6__QuerySetQueryActionTypes__RemoveAllAliases = 5};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() : __ptr(NULL), __size(0), id(NULL), type(NULL), options(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__EspException
#define SOAP_TYPE_ns1__EspException (16)
/* ns1:EspException */
class SOAP_CMAC ns1__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns1__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfEspException
#define SOAP_TYPE_ns1__ArrayOfEspException (17)
/* ns1:ArrayOfEspException */
class SOAP_CMAC ns1__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns1__EspException * >Exception;	/* optional element of type ns1:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns1__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE__ns1__MyAccountRequest
#define SOAP_TYPE__ns1__MyAccountRequest (18)
/* ns1:MyAccountRequest */
class SOAP_CMAC _ns1__MyAccountRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE__ns1__MyAccountRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__MyAccountRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__MyAccountRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__MyAccountResponse
#define SOAP_TYPE__ns1__MyAccountResponse (19)
/* ns1:MyAccountResponse */
class SOAP_CMAC _ns1__MyAccountResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	std::wstring *username;	/* optional element of type xsd:string */
	std::wstring *firstName;	/* optional element of type xsd:string */
	std::wstring *lastName;	/* optional element of type xsd:string */
	std::wstring *passwordExpiration;	/* optional element of type xsd:string */
	int *passwordDaysRemaining;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__ns1__MyAccountResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__MyAccountResponse() : Exceptions(NULL), username(NULL), firstName(NULL), lastName(NULL), passwordExpiration(NULL), passwordDaysRemaining(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__MyAccountResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserRequest
#define SOAP_TYPE__ns1__UpdateUserRequest (20)
/* ns1:UpdateUserRequest */
class SOAP_CMAC _ns1__UpdateUserRequest
{
public:
	std::wstring *username;	/* optional element of type xsd:string */
	std::wstring *oldpass;	/* optional element of type xsd:string */
	std::wstring *newpass1;	/* optional element of type xsd:string */
	std::wstring *newpass2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__ns1__UpdateUserRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserRequest() : username(NULL), oldpass(NULL), newpass1(NULL), newpass2(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserResponse
#define SOAP_TYPE__ns1__UpdateUserResponse (21)
/* ns1:UpdateUserResponse */
class SOAP_CMAC _ns1__UpdateUserResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	int *retcode;	/* optional element of type xsd:int */
	std::wstring *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__ns1__UpdateUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserResponse() : Exceptions(NULL), retcode(NULL), message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserInputRequest
#define SOAP_TYPE__ns1__UpdateUserInputRequest (22)
/* ns1:UpdateUserInputRequest */
class SOAP_CMAC _ns1__UpdateUserInputRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns1__UpdateUserInputRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserInputRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserInputRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UpdateUserInputResponse
#define SOAP_TYPE__ns1__UpdateUserInputResponse (23)
/* ns1:UpdateUserInputResponse */
class SOAP_CMAC _ns1__UpdateUserInputResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	std::wstring *username;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns1__UpdateUserInputResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UpdateUserInputResponse() : Exceptions(NULL), username(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__UpdateUserInputResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__VerifyUserRequest
#define SOAP_TYPE__ns1__VerifyUserRequest (24)
/* ns1:VerifyUserRequest */
class SOAP_CMAC _ns1__VerifyUserRequest
{
public:
	std::wstring *application;	/* optional element of type xsd:string */
	std::wstring *version;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns1__VerifyUserRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__VerifyUserRequest() : application(NULL), version(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__VerifyUserRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__VerifyUserResponse
#define SOAP_TYPE__ns1__VerifyUserResponse (25)
/* ns1:VerifyUserResponse */
class SOAP_CMAC _ns1__VerifyUserResponse
{
public:
	ns1__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfEspException */
	int *retcode;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__ns1__VerifyUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__VerifyUserResponse() : Exceptions(NULL), retcode(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns1__VerifyUserResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EspException
#define SOAP_TYPE_ns2__EspException (26)
/* ns2:EspException */
class SOAP_CMAC ns2__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns2__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfEspException
#define SOAP_TYPE_ns2__ArrayOfEspException (27)
/* ns2:ArrayOfEspException */
class SOAP_CMAC ns2__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns2__EspException * >Exception;	/* optional element of type ns2:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns2__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RenameAttributeRequest
#define SOAP_TYPE_ns2__RenameAttributeRequest (28)
/* ns2:RenameAttributeRequest */
class SOAP_CMAC ns2__RenameAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *NewModuleName;	/* optional element of type xsd:string */
	std::wstring *NewAttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns2__RenameAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RenameAttributeRequest() : ModuleName(NULL), AttributeName(NULL), NewModuleName(NULL), NewAttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__RenameAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImportAttributeRequest
#define SOAP_TYPE_ns2__ImportAttributeRequest (29)
/* ns2:ImportAttributeRequest */
class SOAP_CMAC ns2__ImportAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Flags;	/* optional element of type xsd:int */
	int *ResultType;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Text;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns2__ImportAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImportAttributeRequest() : ModuleName(NULL), AttributeName(NULL), Type(NULL), Flags(NULL), ResultType(NULL), Description(NULL), Text(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ImportAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RollbackAttributeRequest
#define SOAP_TYPE_ns2__RollbackAttributeRequest (30)
/* ns2:RollbackAttributeRequest */
class SOAP_CMAC ns2__RollbackAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns2__RollbackAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RollbackAttributeRequest() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__RollbackAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CheckinAttributeRequest
#define SOAP_TYPE_ns2__CheckinAttributeRequest (31)
/* ns2:CheckinAttributeRequest */
class SOAP_CMAC ns2__CheckinAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns2__CheckinAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CheckinAttributeRequest() : ModuleName(NULL), AttributeName(NULL), Description(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__CheckinAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CheckoutAttributeRequest
#define SOAP_TYPE_ns2__CheckoutAttributeRequest (32)
/* ns2:CheckoutAttributeRequest */
class SOAP_CMAC ns2__CheckoutAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns2__CheckoutAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CheckoutAttributeRequest() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__CheckoutAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLLabel
#define SOAP_TYPE_ns2__ECLLabel (33)
/* ns2:ECLLabel */
class SOAP_CMAC ns2__ECLLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *ModifiedDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns2__ECLLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLLabel() : Name(NULL), ModifiedDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLModule
#define SOAP_TYPE_ns2__ECLModule (34)
/* ns2:ECLModule */
class SOAP_CMAC ns2__ECLModule
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	int *Flags;	/* optional element of type xsd:int */
	int *Access;	/* optional element of type xsd:int */
	LONG64 *Timestamp;	/* optional element of type xsd:long */
	bool *IsPlugin;	/* optional element of type xsd:boolean */
	int *Rank;	/* optional element of type xsd:int */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *FileCRC;	/* optional element of type xsd:string */
	std::wstring *Version;	/* optional element of type xsd:string */
	std::wstring *Checksum;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns2__ECLModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLModule() : Name(NULL), Flags(NULL), Access(NULL), Timestamp(NULL), IsPlugin(NULL), Rank(NULL), FileName(NULL), FileCRC(NULL), Version(NULL), Checksum(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ECLAttribute_MatchedLines
#define SOAP_TYPE__ns2__ECLAttribute_MatchedLines (427)
/* ns2:ECLAttribute-MatchedLines */
class SOAP_CMAC _ns2__ECLAttribute_MatchedLines
{
public:
	std::vector<class ns2__ECLTextLine * >Line;	/* optional element of type ns2:ECLTextLine */
public:
	virtual int soap_type() const { return 427; } /* = unique id SOAP_TYPE__ns2__ECLAttribute_MatchedLines */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ECLAttribute_MatchedLines()  { this->soap_default(NULL); }
	virtual ~_ns2__ECLAttribute_MatchedLines() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLAttribute
#define SOAP_TYPE_ns2__ECLAttribute (35)
/* ns2:ECLAttribute */
class SOAP_CMAC ns2__ECLAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Version;	/* optional element of type xsd:int */
	int *LatestVersion;	/* optional element of type xsd:int */
	int *SandboxVersion;	/* optional element of type xsd:int */
	int *Flags;	/* optional element of type xsd:int */
	int *Access;	/* optional element of type xsd:int */
	bool *IsLocked;	/* optional element of type xsd:boolean */
	bool *IsCheckedOut;	/* optional element of type xsd:boolean */
	bool *IsSandbox;	/* optional element of type xsd:boolean */
	bool *IsOrphaned;	/* optional element of type xsd:boolean */
	int *ResultType;	/* optional element of type xsd:int */
	std::wstring *LockedBy;	/* optional element of type xsd:string */
	std::wstring *ModifiedBy;	/* optional element of type xsd:string */
	std::wstring *ModifiedDate;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Checksum;	/* optional element of type xsd:string */
	std::wstring *Text;	/* optional element of type xsd:string */
	_ns2__ECLAttribute_MatchedLines *MatchedLines;	/* optional element of type ns2:ECLAttribute-MatchedLines */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns2__ECLAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLAttribute() : ModuleName(NULL), Name(NULL), Type(NULL), Version(NULL), LatestVersion(NULL), SandboxVersion(NULL), Flags(NULL), Access(NULL), IsLocked(NULL), IsCheckedOut(NULL), IsSandbox(NULL), IsOrphaned(NULL), ResultType(NULL), LockedBy(NULL), ModifiedBy(NULL), ModifiedDate(NULL), Description(NULL), Checksum(NULL), Text(NULL), MatchedLines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLAttribute() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLTextLine
#define SOAP_TYPE_ns2__ECLTextLine (36)
/* ns2:ECLTextLine */
class SOAP_CMAC ns2__ECLTextLine
{
public:
	int *LineNumber;	/* optional element of type xsd:int */
	std::wstring *LineText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns2__ECLTextLine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLTextLine() : LineNumber(NULL), LineText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLTextLine() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfCheckinAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfCheckinAttributeRequest (37)
/* ns2:ArrayOfCheckinAttributeRequest */
class SOAP_CMAC ns2__ArrayOfCheckinAttributeRequest
{
public:
	std::vector<ns2__CheckinAttributeRequest * >CheckinAttributeRequest;	/* optional element of type ns2:CheckinAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns2__ArrayOfCheckinAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfCheckinAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfCheckinAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLAttribute
#define SOAP_TYPE_ns2__ArrayOfECLAttribute (38)
/* ns2:ArrayOfECLAttribute */
class SOAP_CMAC ns2__ArrayOfECLAttribute
{
public:
	std::vector<ns2__ECLAttribute * >ECLAttribute;	/* optional element of type ns2:ECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLAttribute() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLAttribute() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfCheckoutAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfCheckoutAttributeRequest (39)
/* ns2:ArrayOfCheckoutAttributeRequest */
class SOAP_CMAC ns2__ArrayOfCheckoutAttributeRequest
{
public:
	std::vector<ns2__CheckoutAttributeRequest * >CheckoutAttributeRequest;	/* optional element of type ns2:CheckoutAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns2__ArrayOfCheckoutAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfCheckoutAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfCheckoutAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DeleteAttributeRequest
#define SOAP_TYPE_ns2__DeleteAttributeRequest (40)
/* ns2:DeleteAttributeRequest */
class SOAP_CMAC ns2__DeleteAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns2__DeleteAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DeleteAttributeRequest() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__DeleteAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfDeleteAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfDeleteAttributeRequest (41)
/* ns2:ArrayOfDeleteAttributeRequest */
class SOAP_CMAC ns2__ArrayOfDeleteAttributeRequest
{
public:
	std::vector<ns2__DeleteAttributeRequest * >DeleteAttributeRequest;	/* optional element of type ns2:DeleteAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns2__ArrayOfDeleteAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfDeleteAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfDeleteAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EspStringArray
#define SOAP_TYPE_ns2__EspStringArray (42)
/* ns2:EspStringArray */
class SOAP_CMAC ns2__EspStringArray
{
public:
	std::vector<std::wstring * >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns2__EspStringArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EspStringArray() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__EspStringArray() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ECLAttributeLabel
#define SOAP_TYPE_ns2__ECLAttributeLabel (43)
/* ns2:ECLAttributeLabel */
class SOAP_CMAC ns2__ECLAttributeLabel
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	int *AttributeVersion;	/* optional element of type xsd:int */
	std::wstring *LabelName;	/* optional element of type xsd:string */
	std::wstring *ModifiedDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns2__ECLAttributeLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ECLAttributeLabel() : ModuleName(NULL), AttributeName(NULL), AttributeVersion(NULL), LabelName(NULL), ModifiedDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ECLAttributeLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLAttributeLabel
#define SOAP_TYPE_ns2__ArrayOfECLAttributeLabel (44)
/* ns2:ArrayOfECLAttributeLabel */
class SOAP_CMAC ns2__ArrayOfECLAttributeLabel
{
public:
	std::vector<ns2__ECLAttributeLabel * >ECLAttributeLabel;	/* optional element of type ns2:ECLAttributeLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLAttributeLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLAttributeLabel() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLAttributeLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLLabel
#define SOAP_TYPE_ns2__ArrayOfECLLabel (45)
/* ns2:ArrayOfECLLabel */
class SOAP_CMAC ns2__ArrayOfECLLabel
{
public:
	std::vector<ns2__ECLLabel * >ECLLabel;	/* optional element of type ns2:ECLLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLLabel() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLLabel() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfECLModule
#define SOAP_TYPE_ns2__ArrayOfECLModule (46)
/* ns2:ArrayOfECLModule */
class SOAP_CMAC ns2__ArrayOfECLModule
{
public:
	std::vector<ns2__ECLModule * >ECLModule;	/* optional element of type ns2:ECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns2__ArrayOfECLModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfECLModule() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfECLModule() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfImportAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfImportAttributeRequest (47)
/* ns2:ArrayOfImportAttributeRequest */
class SOAP_CMAC ns2__ArrayOfImportAttributeRequest
{
public:
	std::vector<ns2__ImportAttributeRequest * >ImportAttributeRequest;	/* optional element of type ns2:ImportAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns2__ArrayOfImportAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfImportAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfImportAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AttributeType
#define SOAP_TYPE_ns2__AttributeType (48)
/* ns2:AttributeType */
class SOAP_CMAC ns2__AttributeType
{
public:
	int *ID;	/* optional element of type xsd:int */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns2__AttributeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AttributeType() : ID(NULL), Name(NULL), Description(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__AttributeType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfRenameAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfRenameAttributeRequest (49)
/* ns2:ArrayOfRenameAttributeRequest */
class SOAP_CMAC ns2__ArrayOfRenameAttributeRequest
{
public:
	std::vector<ns2__RenameAttributeRequest * >RenameAttributeRequest;	/* optional element of type ns2:RenameAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns2__ArrayOfRenameAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfRenameAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfRenameAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfRollbackAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfRollbackAttributeRequest (50)
/* ns2:ArrayOfRollbackAttributeRequest */
class SOAP_CMAC ns2__ArrayOfRollbackAttributeRequest
{
public:
	std::vector<ns2__RollbackAttributeRequest * >RollbackAttributeRequest;	/* optional element of type ns2:RollbackAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns2__ArrayOfRollbackAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfRollbackAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfRollbackAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SaveAttributeRequest
#define SOAP_TYPE_ns2__SaveAttributeRequest (51)
/* ns2:SaveAttributeRequest */
class SOAP_CMAC ns2__SaveAttributeRequest
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	int *Flags;	/* optional element of type xsd:int */
	int *ResultType;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Text;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns2__SaveAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SaveAttributeRequest() : ModuleName(NULL), AttributeName(NULL), Flags(NULL), ResultType(NULL), Description(NULL), Text(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__SaveAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfSaveAttributeRequest
#define SOAP_TYPE_ns2__ArrayOfSaveAttributeRequest (52)
/* ns2:ArrayOfSaveAttributeRequest */
class SOAP_CMAC ns2__ArrayOfSaveAttributeRequest
{
public:
	std::vector<ns2__SaveAttributeRequest * >SaveAttributeRequest;	/* optional element of type ns2:SaveAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns2__ArrayOfSaveAttributeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfSaveAttributeRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns2__ArrayOfSaveAttributeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CheckinAttributes
#define SOAP_TYPE__ns2__CheckinAttributes (53)
/* ns2:CheckinAttributes */
class SOAP_CMAC _ns2__CheckinAttributes
{
public:
	ns2__ArrayOfCheckinAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfCheckinAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__ns2__CheckinAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CheckinAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CheckinAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__UpdateAttributesResponse
#define SOAP_TYPE__ns2__UpdateAttributesResponse (54)
/* ns2:UpdateAttributesResponse */
class SOAP_CMAC _ns2__UpdateAttributesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__ns2__UpdateAttributesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__UpdateAttributesResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__UpdateAttributesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CheckoutAttributes
#define SOAP_TYPE__ns2__CheckoutAttributes (55)
/* ns2:CheckoutAttributes */
class SOAP_CMAC _ns2__CheckoutAttributes
{
public:
	ns2__ArrayOfCheckoutAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfCheckoutAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns2__CheckoutAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CheckoutAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CheckoutAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateAttribute
#define SOAP_TYPE__ns2__CreateAttribute (56)
/* ns2:CreateAttribute */
class SOAP_CMAC _ns2__CreateAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns2__CreateAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateAttribute() : ModuleName(NULL), AttributeName(NULL), Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateAttribute() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateAttributeResponse
#define SOAP_TYPE__ns2__CreateAttributeResponse (57)
/* ns2:CreateAttributeResponse */
class SOAP_CMAC _ns2__CreateAttributeResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLAttribute *AttributeInfo;	/* optional element of type ns2:ECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns2__CreateAttributeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateAttributeResponse() : Exceptions(NULL), AttributeInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateAttributeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateLabel
#define SOAP_TYPE__ns2__CreateLabel (58)
/* ns2:CreateLabel */
class SOAP_CMAC _ns2__CreateLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns2__CreateLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateLabel() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateLabel() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateLabelResponse
#define SOAP_TYPE__ns2__CreateLabelResponse (59)
/* ns2:CreateLabelResponse */
class SOAP_CMAC _ns2__CreateLabelResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__ns2__CreateLabelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateLabelResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateLabelResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateModule
#define SOAP_TYPE__ns2__CreateModule (60)
/* ns2:CreateModule */
class SOAP_CMAC _ns2__CreateModule
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__ns2__CreateModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateModule() : ModuleName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__CreateModuleResponse
#define SOAP_TYPE__ns2__CreateModuleResponse (61)
/* ns2:CreateModuleResponse */
class SOAP_CMAC _ns2__CreateModuleResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLModule *ModuleInfo;	/* optional element of type ns2:ECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__ns2__CreateModuleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__CreateModuleResponse() : Exceptions(NULL), ModuleInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__CreateModuleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteAttributes
#define SOAP_TYPE__ns2__DeleteAttributes (62)
/* ns2:DeleteAttributes */
class SOAP_CMAC _ns2__DeleteAttributes
{
public:
	ns2__ArrayOfDeleteAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfDeleteAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__ns2__DeleteAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteLabel
#define SOAP_TYPE__ns2__DeleteLabel (63)
/* ns2:DeleteLabel */
class SOAP_CMAC _ns2__DeleteLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__ns2__DeleteLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteLabel() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteLabel() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteLabelResponse
#define SOAP_TYPE__ns2__DeleteLabelResponse (64)
/* ns2:DeleteLabelResponse */
class SOAP_CMAC _ns2__DeleteLabelResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__ns2__DeleteLabelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteLabelResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteLabelResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteModule
#define SOAP_TYPE__ns2__DeleteModule (65)
/* ns2:DeleteModule */
class SOAP_CMAC _ns2__DeleteModule
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__ns2__DeleteModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteModule() : ModuleName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__DeleteModuleResponse
#define SOAP_TYPE__ns2__DeleteModuleResponse (66)
/* ns2:DeleteModuleResponse */
class SOAP_CMAC _ns2__DeleteModuleResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__ns2__DeleteModuleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__DeleteModuleResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__DeleteModuleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__FindAttributes
#define SOAP_TYPE__ns2__FindAttributes (67)
/* ns2:FindAttributes */
class SOAP_CMAC _ns2__FindAttributes
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *UserName;	/* optional element of type xsd:string */
	std::wstring *label;	/* optional element of type xsd:string */
	std::wstring *Pattern;	/* optional element of type xsd:string */
	std::wstring *Regexp;	/* optional element of type xsd:string */
	std::wstring *ChangedSince;	/* optional element of type xsd:string */
	ns2__EspStringArray *TypeList;	/* optional element of type ns2:EspStringArray */
	bool Sandboxed;	/* optional element of type xsd:boolean */
	bool Locked;	/* optional element of type xsd:boolean */
	bool CheckedOut;	/* optional element of type xsd:boolean */
	bool Orphaned;	/* optional element of type xsd:boolean */
	bool GetText;	/* optional element of type xsd:boolean */
	bool GetMatchedLines;	/* optional element of type xsd:boolean */
	bool IncludeHistory;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__ns2__FindAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__FindAttributes() : ModuleName(NULL), AttributeName(NULL), UserName(NULL), label(NULL), Pattern(NULL), Regexp(NULL), ChangedSince(NULL), TypeList(NULL), Sandboxed((bool)0), Locked((bool)0), CheckedOut((bool)0), Orphaned((bool)0), GetText((bool)0), GetMatchedLines((bool)0), IncludeHistory((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__FindAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__FindAttributesResponse
#define SOAP_TYPE__ns2__FindAttributesResponse (68)
/* ns2:FindAttributesResponse */
class SOAP_CMAC _ns2__FindAttributesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__ns2__FindAttributesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__FindAttributesResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__FindAttributesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttribute
#define SOAP_TYPE__ns2__GetAttribute (69)
/* ns2:GetAttribute */
class SOAP_CMAC _ns2__GetAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Version;	/* optional element of type xsd:int */
	bool GetSandbox;	/* optional element of type xsd:boolean */
	bool GetText;	/* optional element of type xsd:boolean */
	std::wstring *Label;	/* optional element of type xsd:string */
	bool SandboxForLabel;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__ns2__GetAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttribute() : ModuleName(NULL), AttributeName(NULL), Type(NULL), Version(NULL), GetSandbox((bool)0), GetText((bool)0), Label(NULL), SandboxForLabel((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttribute() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeResponse
#define SOAP_TYPE__ns2__GetAttributeResponse (70)
/* ns2:GetAttributeResponse */
class SOAP_CMAC _ns2__GetAttributeResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLAttribute *outAttribute;	/* optional element of type ns2:ECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__ns2__GetAttributeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeResponse() : Exceptions(NULL), outAttribute(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeHistory
#define SOAP_TYPE__ns2__GetAttributeHistory (71)
/* ns2:GetAttributeHistory */
class SOAP_CMAC _ns2__GetAttributeHistory
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *FromDate;	/* optional element of type xsd:string */
	std::wstring *ToDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE__ns2__GetAttributeHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeHistory() : ModuleName(NULL), AttributeName(NULL), FromDate(NULL), ToDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeHistory() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeHistoryResponse
#define SOAP_TYPE__ns2__GetAttributeHistoryResponse (72)
/* ns2:GetAttributeHistoryResponse */
class SOAP_CMAC _ns2__GetAttributeHistoryResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE__ns2__GetAttributeHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeHistoryResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeLabels
#define SOAP_TYPE__ns2__GetAttributeLabels (73)
/* ns2:GetAttributeLabels */
class SOAP_CMAC _ns2__GetAttributeLabels
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE__ns2__GetAttributeLabels */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeLabels() : ModuleName(NULL), AttributeName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeLabels() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributeLabelsResponse
#define SOAP_TYPE__ns2__GetAttributeLabelsResponse (74)
/* ns2:GetAttributeLabelsResponse */
class SOAP_CMAC _ns2__GetAttributeLabelsResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttributeLabel *Labels;	/* optional element of type ns2:ArrayOfECLAttributeLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE__ns2__GetAttributeLabelsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributeLabelsResponse() : Exceptions(NULL), Labels(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributeLabelsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributes
#define SOAP_TYPE__ns2__GetAttributes (75)
/* ns2:GetAttributes */
class SOAP_CMAC _ns2__GetAttributes
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	ns2__EspStringArray *TypeList;	/* optional element of type ns2:EspStringArray */
	std::wstring *Label;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE__ns2__GetAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributes() : ModuleName(NULL), TypeList(NULL), Label(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetAttributesResponse
#define SOAP_TYPE__ns2__GetAttributesResponse (76)
/* ns2:GetAttributesResponse */
class SOAP_CMAC _ns2__GetAttributesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLAttribute *outAttributes;	/* optional element of type ns2:ArrayOfECLAttribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE__ns2__GetAttributesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetAttributesResponse() : Exceptions(NULL), outAttributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetAttributesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetLabels
#define SOAP_TYPE__ns2__GetLabels (77)
/* ns2:GetLabels */
class SOAP_CMAC _ns2__GetLabels
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE__ns2__GetLabels */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetLabels() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetLabels() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetLabelsResponse
#define SOAP_TYPE__ns2__GetLabelsResponse (78)
/* ns2:GetLabelsResponse */
class SOAP_CMAC _ns2__GetLabelsResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLLabel *outLabels;	/* optional element of type ns2:ArrayOfECLLabel */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE__ns2__GetLabelsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetLabelsResponse() : Exceptions(NULL), outLabels(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetLabelsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetModules
#define SOAP_TYPE__ns2__GetModules (79)
/* ns2:GetModules */
class SOAP_CMAC _ns2__GetModules
{
public:
	LONG64 *ModifiedSince;	/* optional element of type xsd:long */
	bool IncludeDeleted;	/* optional element of type xsd:boolean */
	bool GetChecksum;	/* optional element of type xsd:boolean */
	std::wstring *Label;	/* optional element of type xsd:string */
	std::wstring *EarMark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE__ns2__GetModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetModules() : ModifiedSince(NULL), IncludeDeleted((bool)0), GetChecksum((bool)0), Label(NULL), EarMark(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetModules() { }
};
#endif

#ifndef SOAP_TYPE__ns2__GetModulesResponse
#define SOAP_TYPE__ns2__GetModulesResponse (80)
/* ns2:GetModulesResponse */
class SOAP_CMAC _ns2__GetModulesResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ArrayOfECLModule *outModules;	/* optional element of type ns2:ArrayOfECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE__ns2__GetModulesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__GetModulesResponse() : Exceptions(NULL), outModules(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__GetModulesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ImportAttributes
#define SOAP_TYPE__ns2__ImportAttributes (81)
/* ns2:ImportAttributes */
class SOAP_CMAC _ns2__ImportAttributes
{
public:
	ns2__ArrayOfImportAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfImportAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE__ns2__ImportAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ImportAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__ImportAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ListAttributeTypes
#define SOAP_TYPE__ns2__ListAttributeTypes (82)
/* ns2:ListAttributeTypes */
class SOAP_CMAC _ns2__ListAttributeTypes
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE__ns2__ListAttributeTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ListAttributeTypes() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__ListAttributeTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ListAttributeTypesResponse_Types
#define SOAP_TYPE__ns2__ListAttributeTypesResponse_Types (464)
/* ns2:ListAttributeTypesResponse-Types */
class SOAP_CMAC _ns2__ListAttributeTypesResponse_Types
{
public:
	std::vector<ns2__AttributeType * >Type;	/* optional element of type ns2:AttributeType */
public:
	virtual int soap_type() const { return 464; } /* = unique id SOAP_TYPE__ns2__ListAttributeTypesResponse_Types */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ListAttributeTypesResponse_Types()  { this->soap_default(NULL); }
	virtual ~_ns2__ListAttributeTypesResponse_Types() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ListAttributeTypesResponse
#define SOAP_TYPE__ns2__ListAttributeTypesResponse (83)
/* ns2:ListAttributeTypesResponse */
class SOAP_CMAC _ns2__ListAttributeTypesResponse
{
public:
	_ns2__ListAttributeTypesResponse_Types *Types;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ListAttributeTypesResponse-Types */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE__ns2__ListAttributeTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ListAttributeTypesResponse() : Types(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__ListAttributeTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RenameAttributes
#define SOAP_TYPE__ns2__RenameAttributes (84)
/* ns2:RenameAttributes */
class SOAP_CMAC _ns2__RenameAttributes
{
public:
	ns2__ArrayOfRenameAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfRenameAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE__ns2__RenameAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RenameAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RenameAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RenameModule
#define SOAP_TYPE__ns2__RenameModule (85)
/* ns2:RenameModule */
class SOAP_CMAC _ns2__RenameModule
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *NewModuleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE__ns2__RenameModule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RenameModule() : ModuleName(NULL), NewModuleName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RenameModule() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RenameModuleResponse
#define SOAP_TYPE__ns2__RenameModuleResponse (86)
/* ns2:RenameModuleResponse */
class SOAP_CMAC _ns2__RenameModuleResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	ns2__ECLModule *ModuleInfo;	/* optional element of type ns2:ECLModule */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE__ns2__RenameModuleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RenameModuleResponse() : Exceptions(NULL), ModuleInfo(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RenameModuleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__RollbackAttributes
#define SOAP_TYPE__ns2__RollbackAttributes (87)
/* ns2:RollbackAttributes */
class SOAP_CMAC _ns2__RollbackAttributes
{
public:
	ns2__ArrayOfRollbackAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfRollbackAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE__ns2__RollbackAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__RollbackAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__RollbackAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__SaveAttributes
#define SOAP_TYPE__ns2__SaveAttributes (88)
/* ns2:SaveAttributes */
class SOAP_CMAC _ns2__SaveAttributes
{
public:
	ns2__ArrayOfSaveAttributeRequest *Attributes;	/* optional element of type ns2:ArrayOfSaveAttributeRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE__ns2__SaveAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__SaveAttributes() : Attributes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__SaveAttributes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__SupportsEarMark
#define SOAP_TYPE__ns2__SupportsEarMark (89)
/* ns2:SupportsEarMark */
class SOAP_CMAC _ns2__SupportsEarMark
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE__ns2__SupportsEarMark */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__SupportsEarMark() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__SupportsEarMark() { }
};
#endif

#ifndef SOAP_TYPE__ns2__SupportsEarMarkResponse
#define SOAP_TYPE__ns2__SupportsEarMarkResponse (90)
/* ns2:SupportsEarMarkResponse */
class SOAP_CMAC _ns2__SupportsEarMarkResponse
{
public:
	bool Support;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE__ns2__SupportsEarMarkResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__SupportsEarMarkResponse() : Support((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__SupportsEarMarkResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__UpdateLabel
#define SOAP_TYPE__ns2__UpdateLabel (91)
/* ns2:UpdateLabel */
class SOAP_CMAC _ns2__UpdateLabel
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AtributeName;	/* optional element of type xsd:string */
	int *AttrbuteVersion;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE__ns2__UpdateLabel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__UpdateLabel() : Name(NULL), ModuleName(NULL), AtributeName(NULL), AttrbuteVersion(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__UpdateLabel() { }
};
#endif

#ifndef SOAP_TYPE__ns2__UpdateLabelResponse
#define SOAP_TYPE__ns2__UpdateLabelResponse (92)
/* ns2:UpdateLabelResponse */
class SOAP_CMAC _ns2__UpdateLabelResponse
{
public:
	ns2__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE__ns2__UpdateLabelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__UpdateLabelResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns2__UpdateLabelResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns3__EspException
#define SOAP_TYPE_ns3__EspException (93)
/* ns3:EspException */
class SOAP_CMAC ns3__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns3__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfEspException
#define SOAP_TYPE_ns3__ArrayOfEspException (94)
/* ns3:ArrayOfEspException */
class SOAP_CMAC ns3__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns3__EspException * >Exception;	/* optional element of type ns3:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns3__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUDataColumn
#define SOAP_TYPE_ns3__DFUDataColumn (95)
/* ns3:DFUDataColumn */
class SOAP_CMAC ns3__DFUDataColumn
{
public:
	std::wstring *ColumnLabel;	/* optional element of type xsd:string */
	std::wstring *ColumnType;	/* optional element of type xsd:string */
	std::wstring *ColumnValue;	/* optional element of type xsd:string */
	int *ColumnSize;	/* optional element of type xsd:int */
	int *MaxSize;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns3__DFUDataColumn */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUDataColumn() : ColumnLabel(NULL), ColumnType(NULL), ColumnValue(NULL), ColumnSize(NULL), MaxSize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUDataColumn() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUFileDetail_Graphs
#define SOAP_TYPE__ns3__DFUFileDetail_Graphs (477)
/* ns3:DFUFileDetail-Graphs */
class SOAP_CMAC _ns3__DFUFileDetail_Graphs
{
public:
	std::vector<std::wstring * >ECLGraph;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 477; } /* = unique id SOAP_TYPE__ns3__DFUFileDetail_Graphs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUFileDetail_Graphs()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUFileDetail_Graphs() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUFileDetail
#define SOAP_TYPE_ns3__DFUFileDetail (96)
/* ns3:DFUFileDetail */
class SOAP_CMAC ns3__DFUFileDetail
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Filename;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Dir;	/* optional element of type xsd:string */
	std::wstring *PathMask;	/* optional element of type xsd:string */
	std::wstring *Filesize;	/* optional element of type xsd:string */
	std::wstring *ActualSize;	/* optional element of type xsd:string */
	std::wstring *RecordSize;	/* optional element of type xsd:string */
	std::wstring *RecordCount;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	std::wstring *Persistent;	/* optional element of type xsd:string */
	std::wstring *Format;	/* optional element of type xsd:string */
	std::wstring *MaxRecordSize;	/* optional element of type xsd:string */
	std::wstring *CsvSeparate;	/* optional element of type xsd:string */
	std::wstring *CsvQuote;	/* optional element of type xsd:string */
	std::wstring *CsvTerminate;	/* optional element of type xsd:string */
	std::wstring *Modified;	/* optional element of type xsd:string */
	std::wstring *Ecl;	/* optional element of type xsd:string */
	bool ZipFile;	/* optional element of type xsd:boolean */
	class ns3__DFUFileStat *Stat;	/* optional element of type ns3:DFUFileStat */
	class ns3__ArrayOfDFUPart *DFUFileParts;	/* optional element of type ns3:ArrayOfDFUPart */
	bool isSuperfile;	/* optional element of type xsd:boolean */
	bool ShowFileContent;	/* optional element of type xsd:boolean */
	class ns3__EspStringArray *subfiles;	/* optional element of type ns3:EspStringArray */
	class ns3__ArrayOfDFULogicalFile *Superfiles;	/* optional element of type ns3:ArrayOfDFULogicalFile */
	bool *FromRoxieCluster;	/* optional element of type xsd:boolean */
	_ns3__DFUFileDetail_Graphs *Graphs;	/* optional element of type ns3:DFUFileDetail-Graphs */
	std::wstring *UserPermission;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns3__DFUFileDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUFileDetail() : Name(NULL), Filename(NULL), Description(NULL), Dir(NULL), PathMask(NULL), Filesize(NULL), ActualSize(NULL), RecordSize(NULL), RecordCount(NULL), Wuid(NULL), Owner(NULL), Cluster(NULL), JobName(NULL), Persistent(NULL), Format(NULL), MaxRecordSize(NULL), CsvSeparate(NULL), CsvQuote(NULL), CsvTerminate(NULL), Modified(NULL), Ecl(NULL), ZipFile((bool)0), Stat(NULL), DFUFileParts(NULL), isSuperfile((bool)0), ShowFileContent((bool)0), subfiles(NULL), Superfiles(NULL), FromRoxieCluster(NULL), Graphs(NULL), UserPermission(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUFileDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUFileStat
#define SOAP_TYPE_ns3__DFUFileStat (97)
/* ns3:DFUFileStat */
class SOAP_CMAC ns3__DFUFileStat
{
public:
	std::wstring *MinSkew;	/* optional element of type xsd:string */
	std::wstring *MaxSkew;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns3__DFUFileStat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUFileStat() : MinSkew(NULL), MaxSkew(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUFileStat() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUPart
#define SOAP_TYPE_ns3__DFUPart (98)
/* ns3:DFUPart */
class SOAP_CMAC ns3__DFUPart
{
public:
	int *Id;	/* optional element of type xsd:int */
	int *Copy;	/* optional element of type xsd:int */
	std::wstring *ActualSize;	/* optional element of type xsd:string */
	std::wstring *Ip;	/* optional element of type xsd:string */
	std::wstring *Partsize;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns3__DFUPart */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUPart() : Id(NULL), Copy(NULL), ActualSize(NULL), Ip(NULL), Partsize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUPart() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFULogicalFile
#define SOAP_TYPE_ns3__DFULogicalFile (99)
/* ns3:DFULogicalFile */
class SOAP_CMAC ns3__DFULogicalFile
{
public:
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Parts;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Totalsize;	/* optional element of type xsd:string */
	std::wstring *RecordCount;	/* optional element of type xsd:string */
	std::wstring *Modified;	/* optional element of type xsd:string */
	std::wstring *LongSize;	/* optional element of type xsd:string */
	std::wstring *LongRecordCount;	/* optional element of type xsd:string */
	bool *isSuperfile;	/* optional element of type xsd:boolean */
	bool *isZipfile;	/* optional element of type xsd:boolean */
	bool isDirectory;	/* optional element of type xsd:boolean */
	bool Replicate;	/* optional element of type xsd:boolean */
	LONG64 *IntSize;	/* optional element of type xsd:long */
	LONG64 *IntRecordCount;	/* optional element of type xsd:long */
	bool *FromRoxieCluster;	/* optional element of type xsd:boolean */
	bool *BrowseData;	/* optional element of type xsd:boolean */
	bool *IsKeyFile;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns3__DFULogicalFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFULogicalFile() : Prefix(NULL), ClusterName(NULL), Directory(NULL), Description(NULL), Parts(NULL), Name(NULL), Owner(NULL), Totalsize(NULL), RecordCount(NULL), Modified(NULL), LongSize(NULL), LongRecordCount(NULL), isSuperfile(NULL), isZipfile(NULL), isDirectory((bool)0), Replicate((bool)0), IntSize(NULL), IntRecordCount(NULL), FromRoxieCluster(NULL), BrowseData(NULL), IsKeyFile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFULogicalFile() { }
};
#endif

#ifndef SOAP_TYPE_ns3__EspStringArray
#define SOAP_TYPE_ns3__EspStringArray (100)
/* ns3:EspStringArray */
class SOAP_CMAC ns3__EspStringArray
{
public:
	std::vector<std::wstring * >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns3__EspStringArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__EspStringArray() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__EspStringArray() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFULogicalFile
#define SOAP_TYPE_ns3__ArrayOfDFULogicalFile (101)
/* ns3:ArrayOfDFULogicalFile */
class SOAP_CMAC ns3__ArrayOfDFULogicalFile
{
public:
	std::vector<ns3__DFULogicalFile * >DFULogicalFile;	/* optional element of type ns3:DFULogicalFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFULogicalFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFULogicalFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFULogicalFile() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUPart
#define SOAP_TYPE_ns3__ArrayOfDFUPart (102)
/* ns3:ArrayOfDFUPart */
class SOAP_CMAC ns3__ArrayOfDFUPart
{
public:
	std::vector<ns3__DFUPart * >DFUPart;	/* optional element of type ns3:DFUPart */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUPart */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUPart() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUPart() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUDataColumn
#define SOAP_TYPE_ns3__ArrayOfDFUDataColumn (103)
/* ns3:ArrayOfDFUDataColumn */
class SOAP_CMAC ns3__ArrayOfDFUDataColumn
{
public:
	std::vector<ns3__DFUDataColumn * >DFUDataColumn;	/* optional element of type ns3:DFUDataColumn */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUDataColumn */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUDataColumn() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUDataColumn() { }
};
#endif

#ifndef SOAP_TYPE_ns3__DFUSpaceItem
#define SOAP_TYPE_ns3__DFUSpaceItem (104)
/* ns3:DFUSpaceItem */
class SOAP_CMAC ns3__DFUSpaceItem
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *NumOfFiles;	/* optional element of type xsd:string */
	std::wstring *NumOfFilesUnknown;	/* optional element of type xsd:string */
	std::wstring *TotalSize;	/* optional element of type xsd:string */
	std::wstring *LargestFile;	/* optional element of type xsd:string */
	std::wstring *LargestSize;	/* optional element of type xsd:string */
	std::wstring *SmallestFile;	/* optional element of type xsd:string */
	std::wstring *SmallestSize;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns3__DFUSpaceItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__DFUSpaceItem() : Name(NULL), NumOfFiles(NULL), NumOfFilesUnknown(NULL), TotalSize(NULL), LargestFile(NULL), LargestSize(NULL), SmallestFile(NULL), SmallestSize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__DFUSpaceItem() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfDFUSpaceItem
#define SOAP_TYPE_ns3__ArrayOfDFUSpaceItem (105)
/* ns3:ArrayOfDFUSpaceItem */
class SOAP_CMAC ns3__ArrayOfDFUSpaceItem
{
public:
	std::vector<ns3__DFUSpaceItem * >DFUSpaceItem;	/* optional element of type ns3:DFUSpaceItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns3__ArrayOfDFUSpaceItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfDFUSpaceItem() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ArrayOfDFUSpaceItem() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddRequest
#define SOAP_TYPE__ns3__AddRequest (106)
/* ns3:AddRequest */
class SOAP_CMAC _ns3__AddRequest
{
public:
	std::wstring *dstname;	/* optional element of type xsd:string */
	xsd__base64Binary *xmlmap;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE__ns3__AddRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddRequest() : dstname(NULL), xmlmap(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddResponse
#define SOAP_TYPE__ns3__AddResponse (107)
/* ns3:AddResponse */
class SOAP_CMAC _ns3__AddResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE__ns3__AddResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddRemoteRequest
#define SOAP_TYPE__ns3__AddRemoteRequest (108)
/* ns3:AddRemoteRequest */
class SOAP_CMAC _ns3__AddRemoteRequest
{
public:
	std::wstring *dstname;	/* optional element of type xsd:string */
	std::wstring *srcname;	/* optional element of type xsd:string */
	std::wstring *srcdali;	/* optional element of type xsd:string */
	std::wstring *srcusername;	/* optional element of type xsd:string */
	std::wstring *srcpassword;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE__ns3__AddRemoteRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddRemoteRequest() : dstname(NULL), srcname(NULL), srcdali(NULL), srcusername(NULL), srcpassword(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddRemoteRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddRemoteResponse
#define SOAP_TYPE__ns3__AddRemoteResponse (109)
/* ns3:AddRemoteResponse */
class SOAP_CMAC _ns3__AddRemoteResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE__ns3__AddRemoteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddRemoteResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddRemoteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddtoSuperfileRequest
#define SOAP_TYPE__ns3__AddtoSuperfileRequest (110)
/* ns3:AddtoSuperfileRequest */
class SOAP_CMAC _ns3__AddtoSuperfileRequest
{
public:
	std::wstring *Superfile;	/* optional element of type xsd:string */
	std::wstring *Subfiles;	/* optional element of type xsd:string */
	ns3__EspStringArray *names;	/* optional element of type ns3:EspStringArray */
	bool ExistingFile;	/* optional element of type xsd:boolean */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE__ns3__AddtoSuperfileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddtoSuperfileRequest() : Superfile(NULL), Subfiles(NULL), names(NULL), ExistingFile((bool)0), BackToPage(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddtoSuperfileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddtoSuperfileResponse_SubfileNames
#define SOAP_TYPE__ns3__AddtoSuperfileResponse_SubfileNames (489)
/* ns3:AddtoSuperfileResponse-SubfileNames */
class SOAP_CMAC _ns3__AddtoSuperfileResponse_SubfileNames
{
public:
	std::vector<std::wstring * >SubfileName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 489; } /* = unique id SOAP_TYPE__ns3__AddtoSuperfileResponse_SubfileNames */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddtoSuperfileResponse_SubfileNames()  { this->soap_default(NULL); }
	virtual ~_ns3__AddtoSuperfileResponse_SubfileNames() { }
};
#endif

#ifndef SOAP_TYPE__ns3__AddtoSuperfileResponse
#define SOAP_TYPE__ns3__AddtoSuperfileResponse (111)
/* ns3:AddtoSuperfileResponse */
class SOAP_CMAC _ns3__AddtoSuperfileResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *Subfiles;	/* optional element of type xsd:string */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	_ns3__AddtoSuperfileResponse_SubfileNames *SubfileNames;	/* optional element of type ns3:AddtoSuperfileResponse-SubfileNames */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE__ns3__AddtoSuperfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__AddtoSuperfileResponse() : Exceptions(NULL), Subfiles(NULL), BackToPage(NULL), SubfileNames(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__AddtoSuperfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUArrayActionRequest
#define SOAP_TYPE__ns3__DFUArrayActionRequest (112)
/* ns3:DFUArrayActionRequest */
class SOAP_CMAC _ns3__DFUArrayActionRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	bool *NoDelete;	/* optional element of type xsd:boolean */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	ns3__EspStringArray *LogicalFiles;	/* optional element of type ns3:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE__ns3__DFUArrayActionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUArrayActionRequest() : Type(NULL), NoDelete(NULL), BackToPage(NULL), LogicalFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUArrayActionRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUArrayActionResponse
#define SOAP_TYPE__ns3__DFUArrayActionResponse (113)
/* ns3:DFUArrayActionResponse */
class SOAP_CMAC _ns3__DFUArrayActionResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *BackToPage;	/* optional element of type xsd:string */
	std::wstring *RedirectTo;	/* optional element of type xsd:string */
	std::wstring *DFUArrayActionResult;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE__ns3__DFUArrayActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUArrayActionResponse() : Exceptions(NULL), BackToPage(NULL), RedirectTo(NULL), DFUArrayActionResult(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUArrayActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUBrowseDataRequest
#define SOAP_TYPE__ns3__DFUBrowseDataRequest (114)
/* ns3:DFUBrowseDataRequest */
class SOAP_CMAC _ns3__DFUBrowseDataRequest
{
public:
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	bool SchemaOnly;	/* optional element of type xsd:boolean */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE__ns3__DFUBrowseDataRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUBrowseDataRequest() : LogicalName(NULL), FilterBy(NULL), ShowColumns(NULL), SchemaOnly((bool)0), StartForGoback(NULL), CountForGoback(NULL), ChooseFile(NULL), Cluster(NULL), ClusterType(NULL), ParentName(NULL), Start(NULL), Count(NULL), DisableUppercaseTranslation(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUBrowseDataRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUBrowseDataResponse_ColumnsHidden
#define SOAP_TYPE__ns3__DFUBrowseDataResponse_ColumnsHidden (491)
/* ns3:DFUBrowseDataResponse-ColumnsHidden */
class SOAP_CMAC _ns3__DFUBrowseDataResponse_ColumnsHidden
{
public:
	std::vector<ns3__DFUDataColumn * >ColumnHidden;	/* optional element of type ns3:DFUDataColumn */
public:
	virtual int soap_type() const { return 491; } /* = unique id SOAP_TYPE__ns3__DFUBrowseDataResponse_ColumnsHidden */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUBrowseDataResponse_ColumnsHidden()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUBrowseDataResponse_ColumnsHidden() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUBrowseDataResponse
#define SOAP_TYPE__ns3__DFUBrowseDataResponse (115)
/* ns3:DFUBrowseDataResponse */
class SOAP_CMAC _ns3__DFUBrowseDataResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *FilterForGoBack;	/* optional element of type xsd:string */
	_ns3__DFUBrowseDataResponse_ColumnsHidden *ColumnsHidden;	/* optional element of type ns3:DFUBrowseDataResponse-ColumnsHidden */
	int *ColumnCount;	/* optional element of type xsd:int */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	int *ChooseFile;	/* optional element of type xsd:int */
	bool SchemaOnly;	/* optional element of type xsd:boolean */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	LONG64 *Count;	/* optional element of type xsd:long */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *Total;	/* optional element of type xsd:long */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *MsgToDisplay;	/* optional element of type xsd:string */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE__ns3__DFUBrowseDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUBrowseDataResponse() : Exceptions(NULL), Name(NULL), LogicalName(NULL), FilterBy(NULL), FilterForGoBack(NULL), ColumnsHidden(NULL), ColumnCount(NULL), StartForGoback(NULL), CountForGoback(NULL), ChooseFile(NULL), SchemaOnly((bool)0), Cluster(NULL), ClusterType(NULL), ParentName(NULL), Start(NULL), Count(NULL), PageSize(NULL), Total(NULL), Result(NULL), MsgToDisplay(NULL), DisableUppercaseTranslation(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUBrowseDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUDefFileRequest
#define SOAP_TYPE__ns3__DFUDefFileRequest (116)
/* ns3:DFUDefFileRequest */
class SOAP_CMAC _ns3__DFUDefFileRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Format;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE__ns3__DFUDefFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUDefFileRequest() : Name(NULL), Format(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUDefFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUDefFileResponse
#define SOAP_TYPE__ns3__DFUDefFileResponse (117)
/* ns3:DFUDefFileResponse */
class SOAP_CMAC _ns3__DFUDefFileResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	xsd__base64Binary *defFile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE__ns3__DFUDefFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUDefFileResponse() : Exceptions(NULL), defFile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUDefFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUFileViewRequest
#define SOAP_TYPE__ns3__DFUFileViewRequest (118)
/* ns3:DFUFileViewRequest */
class SOAP_CMAC _ns3__DFUFileViewRequest
{
public:
	std::wstring *Scope;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE__ns3__DFUFileViewRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUFileViewRequest() : Scope(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUFileViewRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUFileViewResponse
#define SOAP_TYPE__ns3__DFUFileViewResponse (119)
/* ns3:DFUFileViewResponse */
class SOAP_CMAC _ns3__DFUFileViewResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *Scope;	/* optional element of type xsd:string */
	int *NumFiles;	/* optional element of type xsd:int */
	ns3__ArrayOfDFULogicalFile *DFULogicalFiles;	/* optional element of type ns3:ArrayOfDFULogicalFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE__ns3__DFUFileViewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUFileViewResponse() : Exceptions(NULL), Scope(NULL), NumFiles(NULL), DFULogicalFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUFileViewResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUGetDataColumnsRequest
#define SOAP_TYPE__ns3__DFUGetDataColumnsRequest (120)
/* ns3:DFUGetDataColumnsRequest */
class SOAP_CMAC _ns3__DFUGetDataColumnsRequest
{
public:
	std::wstring *OpenLogicalName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE__ns3__DFUGetDataColumnsRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUGetDataColumnsRequest() : OpenLogicalName(NULL), LogicalName(NULL), FilterBy(NULL), ShowColumns(NULL), ChooseFile(NULL), Cluster(NULL), ClusterType(NULL), StartIndex(NULL), EndIndex(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUGetDataColumnsRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUGetDataColumnsResponse
#define SOAP_TYPE__ns3__DFUGetDataColumnsResponse (121)
/* ns3:DFUGetDataColumnsResponse */
class SOAP_CMAC _ns3__DFUGetDataColumnsResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	LONG64 *RowCount;	/* optional element of type xsd:long */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE__ns3__DFUGetDataColumnsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUGetDataColumnsResponse() : Exceptions(NULL), LogicalName(NULL), StartIndex(NULL), EndIndex(NULL), DFUDataKeyedColumns1(NULL), DFUDataKeyedColumns2(NULL), DFUDataKeyedColumns3(NULL), DFUDataKeyedColumns4(NULL), DFUDataKeyedColumns5(NULL), DFUDataKeyedColumns6(NULL), DFUDataKeyedColumns7(NULL), DFUDataKeyedColumns8(NULL), DFUDataKeyedColumns9(NULL), DFUDataKeyedColumns10(NULL), DFUDataKeyedColumns11(NULL), DFUDataKeyedColumns12(NULL), DFUDataKeyedColumns13(NULL), DFUDataKeyedColumns14(NULL), DFUDataKeyedColumns15(NULL), DFUDataKeyedColumns16(NULL), DFUDataKeyedColumns17(NULL), DFUDataKeyedColumns18(NULL), DFUDataKeyedColumns19(NULL), DFUDataKeyedColumns20(NULL), DFUDataNonKeyedColumns1(NULL), DFUDataNonKeyedColumns2(NULL), DFUDataNonKeyedColumns3(NULL), DFUDataNonKeyedColumns4(NULL), DFUDataNonKeyedColumns5(NULL), DFUDataNonKeyedColumns6(NULL), DFUDataNonKeyedColumns7(NULL), DFUDataNonKeyedColumns8(NULL), DFUDataNonKeyedColumns9(NULL), DFUDataNonKeyedColumns10(NULL), DFUDataNonKeyedColumns11(NULL), DFUDataNonKeyedColumns12(NULL), DFUDataNonKeyedColumns13(NULL), DFUDataNonKeyedColumns14(NULL), DFUDataNonKeyedColumns15(NULL), DFUDataNonKeyedColumns16(NULL), DFUDataNonKeyedColumns17(NULL), DFUDataNonKeyedColumns18(NULL), DFUDataNonKeyedColumns19(NULL), DFUDataNonKeyedColumns20(NULL), RowCount(NULL), ShowColumns(NULL), ChooseFile(NULL), Cluster(NULL), ClusterType(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUGetDataColumnsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUInfoRequest
#define SOAP_TYPE__ns3__DFUInfoRequest (122)
/* ns3:DFUInfoRequest */
class SOAP_CMAC _ns3__DFUInfoRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	bool UpdateDescription;	/* optional element of type xsd:boolean */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *FileDesc;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE__ns3__DFUInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUInfoRequest() : Name(NULL), Cluster(NULL), UpdateDescription((bool)0), FileName(NULL), FileDesc(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUInfoResponse
#define SOAP_TYPE__ns3__DFUInfoResponse (123)
/* ns3:DFUInfoResponse */
class SOAP_CMAC _ns3__DFUInfoResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	ns3__DFUFileDetail *FileDetail;	/* optional element of type ns3:DFUFileDetail */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE__ns3__DFUInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUInfoResponse() : Exceptions(NULL), FileDetail(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUQueryRequest
#define SOAP_TYPE__ns3__DFUQueryRequest (124)
/* ns3:DFUQueryRequest */
class SOAP_CMAC _ns3__DFUQueryRequest
{
public:
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *FileType;	/* optional element of type xsd:string */
	LONG64 FileSizeFrom;	/* optional element of type xsd:long */
	LONG64 FileSizeTo;	/* optional element of type xsd:long */
	int FirstN;	/* optional element of type xsd:int */
	std::wstring *FirstNType;	/* optional element of type xsd:string */
	int *PageSize;	/* optional element of type xsd:int */
	int *PageStartFrom;	/* optional element of type xsd:int */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	bool OneLevelDirFileReturn;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE__ns3__DFUQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUQueryRequest() : Prefix(NULL), ClusterName(NULL), LogicalName(NULL), Description(NULL), Owner(NULL), StartDate(NULL), EndDate(NULL), FileType(NULL), FileSizeFrom(0), FileSizeTo(0), FirstN(0), FirstNType(NULL), PageSize(NULL), PageStartFrom(NULL), Sortby(NULL), Descending((bool)0), OneLevelDirFileReturn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUQueryResponse
#define SOAP_TYPE__ns3__DFUQueryResponse (125)
/* ns3:DFUQueryResponse */
class SOAP_CMAC _ns3__DFUQueryResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	ns3__ArrayOfDFULogicalFile *DFULogicalFiles;	/* optional element of type ns3:ArrayOfDFULogicalFile */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *FileType;	/* optional element of type xsd:string */
	LONG64 FileSizeFrom;	/* optional element of type xsd:long */
	LONG64 FileSizeTo;	/* optional element of type xsd:long */
	int FirstN;	/* optional element of type xsd:int */
	std::wstring *FirstNType;	/* optional element of type xsd:string */
	int PageSize;	/* optional element of type xsd:int */
	LONG64 PageStartFrom;	/* optional element of type xsd:long */
	LONG64 LastPageFrom;	/* optional element of type xsd:long */
	LONG64 *PageEndAt;	/* optional element of type xsd:long */
	LONG64 PrevPageFrom;	/* optional element of type xsd:long */
	LONG64 NextPageFrom;	/* optional element of type xsd:long */
	LONG64 *NumFiles;	/* optional element of type xsd:long */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	std::wstring *BasicQuery;	/* optional element of type xsd:string */
	std::wstring *ParametersForPaging;	/* optional element of type xsd:string */
	std::wstring *Filters;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 125; } /* = unique id SOAP_TYPE__ns3__DFUQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUQueryResponse() : Exceptions(NULL), DFULogicalFiles(NULL), Prefix(NULL), ClusterName(NULL), LogicalName(NULL), Description(NULL), Owner(NULL), StartDate(NULL), EndDate(NULL), FileType(NULL), FileSizeFrom(0), FileSizeTo(0), FirstN(0), FirstNType(NULL), PageSize(0), PageStartFrom(0), LastPageFrom(0), PageEndAt(NULL), PrevPageFrom(0), NextPageFrom(0), NumFiles(NULL), Sortby(NULL), Descending((bool)0), BasicQuery(NULL), ParametersForPaging(NULL), Filters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchRequest
#define SOAP_TYPE__ns3__DFUSearchRequest (126)
/* ns3:DFUSearchRequest */
class SOAP_CMAC _ns3__DFUSearchRequest
{
public:
	std::wstring *ShowExample;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE__ns3__DFUSearchRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchRequest() : ShowExample(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchResponse_ClusterNames
#define SOAP_TYPE__ns3__DFUSearchResponse_ClusterNames (495)
/* ns3:DFUSearchResponse-ClusterNames */
class SOAP_CMAC _ns3__DFUSearchResponse_ClusterNames
{
public:
	std::vector<std::wstring * >ClusterName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 495; } /* = unique id SOAP_TYPE__ns3__DFUSearchResponse_ClusterNames */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchResponse_ClusterNames()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchResponse_ClusterNames() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchResponse_FileTypes
#define SOAP_TYPE__ns3__DFUSearchResponse_FileTypes (497)
/* ns3:DFUSearchResponse-FileTypes */
class SOAP_CMAC _ns3__DFUSearchResponse_FileTypes
{
public:
	std::vector<std::wstring * >FileType;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 497; } /* = unique id SOAP_TYPE__ns3__DFUSearchResponse_FileTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchResponse_FileTypes()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchResponse_FileTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchResponse
#define SOAP_TYPE__ns3__DFUSearchResponse (127)
/* ns3:DFUSearchResponse */
class SOAP_CMAC _ns3__DFUSearchResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *ShowExample;	/* optional element of type xsd:string */
	_ns3__DFUSearchResponse_ClusterNames *ClusterNames;	/* optional element of type ns3:DFUSearchResponse-ClusterNames */
	_ns3__DFUSearchResponse_FileTypes *FileTypes;	/* optional element of type ns3:DFUSearchResponse-FileTypes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE__ns3__DFUSearchResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchResponse() : Exceptions(NULL), ShowExample(NULL), ClusterNames(NULL), FileTypes(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchDataRequest
#define SOAP_TYPE__ns3__DFUSearchDataRequest (128)
/* ns3:DFUSearchDataRequest */
class SOAP_CMAC _ns3__DFUSearchDataRequest
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *OpenLogicalName;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	std::wstring *File;	/* optional element of type xsd:string */
	std::wstring *Key;	/* optional element of type xsd:string */
	bool SchemaOnly;	/* optional element of type xsd:boolean */
	bool RoxieSelections;	/* optional element of type xsd:boolean */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	std::wstring *SelectedKey;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE__ns3__DFUSearchDataRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchDataRequest() : Cluster(NULL), ClusterType(NULL), OpenLogicalName(NULL), FilterBy(NULL), ShowColumns(NULL), ChooseFile(NULL), StartIndex(NULL), EndIndex(NULL), LogicalName(NULL), ParentName(NULL), StartForGoback(NULL), CountForGoback(NULL), Start(NULL), Count(NULL), File(NULL), Key(NULL), SchemaOnly((bool)0), RoxieSelections((bool)0), DisableUppercaseTranslation(NULL), SelectedKey(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchDataRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchDataResponse_ColumnsHidden
#define SOAP_TYPE__ns3__DFUSearchDataResponse_ColumnsHidden (499)
/* ns3:DFUSearchDataResponse-ColumnsHidden */
class SOAP_CMAC _ns3__DFUSearchDataResponse_ColumnsHidden
{
public:
	std::vector<ns3__DFUDataColumn * >ColumnHidden;	/* optional element of type ns3:DFUDataColumn */
public:
	virtual int soap_type() const { return 499; } /* = unique id SOAP_TYPE__ns3__DFUSearchDataResponse_ColumnsHidden */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchDataResponse_ColumnsHidden()  { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchDataResponse_ColumnsHidden() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSearchDataResponse
#define SOAP_TYPE__ns3__DFUSearchDataResponse (129)
/* ns3:DFUSearchDataResponse */
class SOAP_CMAC _ns3__DFUSearchDataResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *OpenLogicalName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *ParentName;	/* optional element of type xsd:string */
	LONG64 *StartIndex;	/* optional element of type xsd:long */
	LONG64 *EndIndex;	/* optional element of type xsd:long */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns1;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns2;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns3;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns4;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns5;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns6;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns7;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns8;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns9;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns10;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns11;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns12;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns13;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns14;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns15;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns16;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns17;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns18;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns19;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	ns3__ArrayOfDFUDataColumn *DFUDataNonKeyedColumns20;	/* optional element of type ns3:ArrayOfDFUDataColumn */
	LONG64 *RowCount;	/* optional element of type xsd:long */
	std::wstring *ShowColumns;	/* optional element of type xsd:string */
	int *ChooseFile;	/* optional element of type xsd:int */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *FilterBy;	/* optional element of type xsd:string */
	std::wstring *FilterForGoBack;	/* optional element of type xsd:string */
	_ns3__DFUSearchDataResponse_ColumnsHidden *ColumnsHidden;	/* optional element of type ns3:DFUSearchDataResponse-ColumnsHidden */
	int *ColumnCount;	/* optional element of type xsd:int */
	LONG64 *StartForGoback;	/* optional element of type xsd:long */
	int *CountForGoback;	/* optional element of type xsd:int */
	LONG64 *Start;	/* optional element of type xsd:long */
	LONG64 *Count;	/* optional element of type xsd:long */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *Total;	/* optional element of type xsd:long */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *MsgToDisplay;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *ClusterType;	/* optional element of type xsd:string */
	std::wstring *File;	/* optional element of type xsd:string */
	std::wstring *Key;	/* optional element of type xsd:string */
	bool *SchemaOnly;	/* optional element of type xsd:boolean */
	bool *RoxieSelections;	/* optional element of type xsd:boolean */
	bool *DisableUppercaseTranslation;	/* optional element of type xsd:boolean */
	bool *AutoUppercaseTranslation;	/* optional element of type xsd:boolean */
	std::wstring *SelectedKey;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE__ns3__DFUSearchDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSearchDataResponse() : Exceptions(NULL), OpenLogicalName(NULL), LogicalName(NULL), ParentName(NULL), StartIndex(NULL), EndIndex(NULL), DFUDataKeyedColumns1(NULL), DFUDataKeyedColumns2(NULL), DFUDataKeyedColumns3(NULL), DFUDataKeyedColumns4(NULL), DFUDataKeyedColumns5(NULL), DFUDataKeyedColumns6(NULL), DFUDataKeyedColumns7(NULL), DFUDataKeyedColumns8(NULL), DFUDataKeyedColumns9(NULL), DFUDataKeyedColumns10(NULL), DFUDataKeyedColumns11(NULL), DFUDataKeyedColumns12(NULL), DFUDataKeyedColumns13(NULL), DFUDataKeyedColumns14(NULL), DFUDataKeyedColumns15(NULL), DFUDataKeyedColumns16(NULL), DFUDataKeyedColumns17(NULL), DFUDataKeyedColumns18(NULL), DFUDataKeyedColumns19(NULL), DFUDataKeyedColumns20(NULL), DFUDataNonKeyedColumns1(NULL), DFUDataNonKeyedColumns2(NULL), DFUDataNonKeyedColumns3(NULL), DFUDataNonKeyedColumns4(NULL), DFUDataNonKeyedColumns5(NULL), DFUDataNonKeyedColumns6(NULL), DFUDataNonKeyedColumns7(NULL), DFUDataNonKeyedColumns8(NULL), DFUDataNonKeyedColumns9(NULL), DFUDataNonKeyedColumns10(NULL), DFUDataNonKeyedColumns11(NULL), DFUDataNonKeyedColumns12(NULL), DFUDataNonKeyedColumns13(NULL), DFUDataNonKeyedColumns14(NULL), DFUDataNonKeyedColumns15(NULL), DFUDataNonKeyedColumns16(NULL), DFUDataNonKeyedColumns17(NULL), DFUDataNonKeyedColumns18(NULL), DFUDataNonKeyedColumns19(NULL), DFUDataNonKeyedColumns20(NULL), RowCount(NULL), ShowColumns(NULL), ChooseFile(NULL), Name(NULL), FilterBy(NULL), FilterForGoBack(NULL), ColumnsHidden(NULL), ColumnCount(NULL), StartForGoback(NULL), CountForGoback(NULL), Start(NULL), Count(NULL), PageSize(NULL), Total(NULL), Result(NULL), MsgToDisplay(NULL), Cluster(NULL), ClusterType(NULL), File(NULL), Key(NULL), SchemaOnly(NULL), RoxieSelections(NULL), DisableUppercaseTranslation(NULL), AutoUppercaseTranslation(NULL), SelectedKey(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSearchDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSpaceRequest
#define SOAP_TYPE__ns3__DFUSpaceRequest (130)
/* ns3:DFUSpaceRequest */
class SOAP_CMAC _ns3__DFUSpaceRequest
{
public:
	std::wstring *CountBy;	/* optional element of type xsd:string */
	std::wstring *ScopeUnder;	/* optional element of type xsd:string */
	std::wstring *OwnerUnder;	/* optional element of type xsd:string */
	std::wstring *Interval;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE__ns3__DFUSpaceRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSpaceRequest() : CountBy(NULL), ScopeUnder(NULL), OwnerUnder(NULL), Interval(NULL), StartDate(NULL), EndDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSpaceRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DFUSpaceResponse
#define SOAP_TYPE__ns3__DFUSpaceResponse (131)
/* ns3:DFUSpaceResponse */
class SOAP_CMAC _ns3__DFUSpaceResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *CountBy;	/* optional element of type xsd:string */
	std::wstring *ScopeUnder;	/* optional element of type xsd:string */
	std::wstring *OwnerUnder;	/* optional element of type xsd:string */
	std::wstring *Interval;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	ns3__ArrayOfDFUSpaceItem *DFUSpaceItems;	/* optional element of type ns3:ArrayOfDFUSpaceItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE__ns3__DFUSpaceResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DFUSpaceResponse() : Exceptions(NULL), CountBy(NULL), ScopeUnder(NULL), OwnerUnder(NULL), Interval(NULL), StartDate(NULL), EndDate(NULL), DFUSpaceItems(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__DFUSpaceResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SavexmlRequest
#define SOAP_TYPE__ns3__SavexmlRequest (132)
/* ns3:SavexmlRequest */
class SOAP_CMAC _ns3__SavexmlRequest
{
public:
	std::wstring *name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE__ns3__SavexmlRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SavexmlRequest() : name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SavexmlRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SavexmlResponse
#define SOAP_TYPE__ns3__SavexmlResponse (133)
/* ns3:SavexmlResponse */
class SOAP_CMAC _ns3__SavexmlResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	xsd__base64Binary *xmlmap;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE__ns3__SavexmlResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SavexmlResponse() : Exceptions(NULL), xmlmap(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SavexmlResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileActionRequest
#define SOAP_TYPE__ns3__SuperfileActionRequest (134)
/* ns3:SuperfileActionRequest */
class SOAP_CMAC _ns3__SuperfileActionRequest
{
public:
	std::wstring *action;	/* optional element of type xsd:string */
	std::wstring *superfile;	/* optional element of type xsd:string */
	ns3__EspStringArray *subfiles;	/* optional element of type ns3:EspStringArray */
	std::wstring *before;	/* optional element of type xsd:string */
	bool *delete_;	/* optional element of type xsd:boolean */
	bool *removeSuperfile;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE__ns3__SuperfileActionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileActionRequest() : action(NULL), superfile(NULL), subfiles(NULL), before(NULL), delete_(NULL), removeSuperfile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileActionRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileActionResponse
#define SOAP_TYPE__ns3__SuperfileActionResponse (135)
/* ns3:SuperfileActionResponse */
class SOAP_CMAC _ns3__SuperfileActionResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *superfile;	/* optional element of type xsd:string */
	int *retcode;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE__ns3__SuperfileActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileActionResponse() : Exceptions(NULL), superfile(NULL), retcode(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileAddRawRequest
#define SOAP_TYPE__ns3__SuperfileAddRawRequest (136)
/* ns3:SuperfileAddRawRequest */
class SOAP_CMAC _ns3__SuperfileAddRawRequest
{
public:
	std::wstring *superfile;	/* optional element of type xsd:string */
	std::wstring *subfiles;	/* optional element of type xsd:string */
	std::wstring *before;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 136; } /* = unique id SOAP_TYPE__ns3__SuperfileAddRawRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileAddRawRequest() : superfile(NULL), subfiles(NULL), before(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileAddRawRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileAddRawResponse
#define SOAP_TYPE__ns3__SuperfileAddRawResponse (137)
/* ns3:SuperfileAddRawResponse */
class SOAP_CMAC _ns3__SuperfileAddRawResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *superfile;	/* optional element of type xsd:string */
	int *retcode;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE__ns3__SuperfileAddRawResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileAddRawResponse() : Exceptions(NULL), superfile(NULL), retcode(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileAddRawResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileListRequest
#define SOAP_TYPE__ns3__SuperfileListRequest (138)
/* ns3:SuperfileListRequest */
class SOAP_CMAC _ns3__SuperfileListRequest
{
public:
	std::wstring *superfile;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE__ns3__SuperfileListRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileListRequest() : superfile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileListRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SuperfileListResponse
#define SOAP_TYPE__ns3__SuperfileListResponse (139)
/* ns3:SuperfileListResponse */
class SOAP_CMAC _ns3__SuperfileListResponse
{
public:
	ns3__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:ArrayOfEspException */
	std::wstring *superfile;	/* optional element of type xsd:string */
	ns3__EspStringArray *subfiles;	/* optional element of type ns3:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE__ns3__SuperfileListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SuperfileListResponse() : Exceptions(NULL), superfile(NULL), subfiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns3__SuperfileListResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns4__EspException
#define SOAP_TYPE_ns4__EspException (140)
/* ns4:EspException */
class SOAP_CMAC ns4__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE_ns4__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfEspException
#define SOAP_TYPE_ns4__ArrayOfEspException (141)
/* ns4:ArrayOfEspException */
class SOAP_CMAC ns4__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns4__EspException * >Exception;	/* optional element of type ns4:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 141; } /* = unique id SOAP_TYPE_ns4__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns4__DFUJob
#define SOAP_TYPE_ns4__DFUJob (142)
/* ns4:DFUJob */
class SOAP_CMAC ns4__DFUJob
{
public:
	std::wstring *TimeStarted;	/* optional element of type xsd:string */
	int *Done;	/* optional element of type xsd:int */
	int *Total;	/* optional element of type xsd:int */
	std::wstring *Command;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE_ns4__DFUJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__DFUJob() : TimeStarted(NULL), Done(NULL), Total(NULL), Command(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__DFUJob() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ActiveWorkunit
#define SOAP_TYPE_ns4__ActiveWorkunit (143)
/* ns4:ActiveWorkunit */
class SOAP_CMAC ns4__ActiveWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	int *StateID;	/* optional element of type xsd:int */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *Server;	/* optional element of type xsd:string */
	std::wstring *Instance;	/* optional element of type xsd:string */
	std::wstring *Priority;	/* optional element of type xsd:string */
	std::wstring *Extra;	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	std::wstring *Duration;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	int *MemoryBlocked;	/* optional element of type xsd:int */
	bool IsPausing;	/* optional element of type xsd:boolean */
	std::wstring *Warning;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE_ns4__ActiveWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ActiveWorkunit() : Wuid(NULL), State(NULL), StateID(NULL), Owner(NULL), Jobname(NULL), Server(NULL), Instance(NULL), Priority(NULL), Extra(NULL), GraphName(NULL), Duration(NULL), GID(NULL), QueueName(NULL), MemoryBlocked(NULL), IsPausing((bool)0), Warning(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ActiveWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns4__HThorCluster
#define SOAP_TYPE_ns4__HThorCluster (144)
/* ns4:HThorCluster */
class SOAP_CMAC ns4__HThorCluster
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *QueueStatus;	/* optional element of type xsd:string */
	int *JobsRunning;	/* optional element of type xsd:int */
	int *JobsInQueue;	/* optional element of type xsd:int */
	int *QueueStatus2;	/* optional element of type xsd:int */
	int *ClusterSize;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE_ns4__HThorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__HThorCluster() : ClusterName(NULL), QueueName(NULL), QueueStatus(NULL), JobsRunning(NULL), JobsInQueue(NULL), QueueStatus2(NULL), ClusterSize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__HThorCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ThorCluster
#define SOAP_TYPE_ns4__ThorCluster (145)
/* ns4:ThorCluster */
class SOAP_CMAC ns4__ThorCluster
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *QueueStatus;	/* optional element of type xsd:string */
	int *QueueAvailable;	/* optional element of type xsd:int */
	int *JobsRunning;	/* optional element of type xsd:int */
	int *JobsInQueue;	/* optional element of type xsd:int */
	int *QueueStatus2;	/* optional element of type xsd:int */
	std::wstring *ThorLCR;	/* optional element of type xsd:string */
	int *ClusterSize;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 145; } /* = unique id SOAP_TYPE_ns4__ThorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ThorCluster() : ClusterName(NULL), QueueName(NULL), QueueStatus(NULL), QueueAvailable(NULL), JobsRunning(NULL), JobsInQueue(NULL), QueueStatus2(NULL), ThorLCR(NULL), ClusterSize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ThorCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Permission
#define SOAP_TYPE_ns4__Permission (146)
/* ns4:Permission */
class SOAP_CMAC ns4__Permission
{
public:
	std::wstring *Feature;	/* optional element of type xsd:string */
	class ns4__ArrayOfCapability *Capabilities;	/* optional element of type ns4:ArrayOfCapability */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 146; } /* = unique id SOAP_TYPE_ns4__Permission */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Permission() : Feature(NULL), Capabilities(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__Permission() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Capability
#define SOAP_TYPE_ns4__Capability (147)
/* ns4:Capability */
class SOAP_CMAC ns4__Capability
{
public:
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE_ns4__Capability */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Capability() : name(NULL), description(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__Capability() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfCapability
#define SOAP_TYPE_ns4__ArrayOfCapability (148)
/* ns4:ArrayOfCapability */
class SOAP_CMAC ns4__ArrayOfCapability
{
public:
	std::vector<ns4__Capability * >Capability;	/* optional element of type ns4:Capability */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE_ns4__ArrayOfCapability */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfCapability() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfCapability() { }
};
#endif

#ifndef SOAP_TYPE_ns4__RoxieCluster
#define SOAP_TYPE_ns4__RoxieCluster (149)
/* ns4:RoxieCluster */
class SOAP_CMAC ns4__RoxieCluster
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *QueueStatus;	/* optional element of type xsd:string */
	int *JobsRunning;	/* optional element of type xsd:int */
	int *JobsInQueue;	/* optional element of type xsd:int */
	int *QueueStatus2;	/* optional element of type xsd:int */
	int *ClusterSize;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE_ns4__RoxieCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__RoxieCluster() : ClusterName(NULL), QueueName(NULL), QueueStatus(NULL), JobsRunning(NULL), JobsInQueue(NULL), QueueStatus2(NULL), ClusterSize(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__RoxieCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfActiveWorkunit
#define SOAP_TYPE_ns4__ArrayOfActiveWorkunit (150)
/* ns4:ArrayOfActiveWorkunit */
class SOAP_CMAC ns4__ArrayOfActiveWorkunit
{
public:
	std::vector<ns4__ActiveWorkunit * >ActiveWorkunit;	/* optional element of type ns4:ActiveWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 150; } /* = unique id SOAP_TYPE_ns4__ArrayOfActiveWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfActiveWorkunit() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfActiveWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfDFUJob
#define SOAP_TYPE_ns4__ArrayOfDFUJob (151)
/* ns4:ArrayOfDFUJob */
class SOAP_CMAC ns4__ArrayOfDFUJob
{
public:
	std::vector<ns4__DFUJob * >DFUJob;	/* optional element of type ns4:DFUJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE_ns4__ArrayOfDFUJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfDFUJob() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfDFUJob() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfHThorCluster
#define SOAP_TYPE_ns4__ArrayOfHThorCluster (152)
/* ns4:ArrayOfHThorCluster */
class SOAP_CMAC ns4__ArrayOfHThorCluster
{
public:
	std::vector<ns4__HThorCluster * >HThorCluster;	/* optional element of type ns4:HThorCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 152; } /* = unique id SOAP_TYPE_ns4__ArrayOfHThorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfHThorCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfHThorCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfRoxieCluster
#define SOAP_TYPE_ns4__ArrayOfRoxieCluster (153)
/* ns4:ArrayOfRoxieCluster */
class SOAP_CMAC ns4__ArrayOfRoxieCluster
{
public:
	std::vector<ns4__RoxieCluster * >RoxieCluster;	/* optional element of type ns4:RoxieCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 153; } /* = unique id SOAP_TYPE_ns4__ArrayOfRoxieCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfRoxieCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfRoxieCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfThorCluster
#define SOAP_TYPE_ns4__ArrayOfThorCluster (154)
/* ns4:ArrayOfThorCluster */
class SOAP_CMAC ns4__ArrayOfThorCluster
{
public:
	std::vector<ns4__ThorCluster * >ThorCluster;	/* optional element of type ns4:ThorCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 154; } /* = unique id SOAP_TYPE_ns4__ArrayOfThorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfThorCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfThorCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns4__HPCCResourceRepository
#define SOAP_TYPE_ns4__HPCCResourceRepository (155)
/* ns4:HPCCResourceRepository */
class SOAP_CMAC ns4__HPCCResourceRepository
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	class ns4__ArrayOfHPCCResource *HPCCResources;	/* optional element of type ns4:ArrayOfHPCCResource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE_ns4__HPCCResourceRepository */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__HPCCResourceRepository() : Name(NULL), Path(NULL), HPCCResources(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__HPCCResourceRepository() { }
};
#endif

#ifndef SOAP_TYPE_ns4__HPCCResource
#define SOAP_TYPE_ns4__HPCCResource (156)
/* ns4:HPCCResource */
class SOAP_CMAC ns4__HPCCResource
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	std::wstring *Version;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 156; } /* = unique id SOAP_TYPE_ns4__HPCCResource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__HPCCResource() : Name(NULL), Description(NULL), FileName(NULL), Version(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__HPCCResource() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfHPCCResource
#define SOAP_TYPE_ns4__ArrayOfHPCCResource (157)
/* ns4:ArrayOfHPCCResource */
class SOAP_CMAC ns4__ArrayOfHPCCResource
{
public:
	std::vector<ns4__HPCCResource * >HPCCResource;	/* optional element of type ns4:HPCCResource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 157; } /* = unique id SOAP_TYPE_ns4__ArrayOfHPCCResource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfHPCCResource() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfHPCCResource() { }
};
#endif

#ifndef SOAP_TYPE_ns4__ArrayOfHPCCResourceRepository
#define SOAP_TYPE_ns4__ArrayOfHPCCResourceRepository (158)
/* ns4:ArrayOfHPCCResourceRepository */
class SOAP_CMAC ns4__ArrayOfHPCCResourceRepository
{
public:
	std::vector<ns4__HPCCResourceRepository * >HPCCResourceRepository;	/* optional element of type ns4:HPCCResourceRepository */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE_ns4__ArrayOfHPCCResourceRepository */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__ArrayOfHPCCResourceRepository() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns4__ArrayOfHPCCResourceRepository() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Activity
#define SOAP_TYPE__ns4__Activity (159)
/* ns4:Activity */
class SOAP_CMAC _ns4__Activity
{
public:
	std::wstring *ChatURL;	/* optional element of type xsd:string */
	std::wstring *BannerContent;	/* optional element of type xsd:string */
	std::wstring *BannerColor;	/* optional element of type xsd:string */
	std::wstring *BannerSize;	/* optional element of type xsd:string */
	std::wstring *BannerScroll;	/* optional element of type xsd:string */
	int *BannerAction;	/* optional element of type xsd:int */
	bool *EnableChatURL;	/* optional element of type xsd:boolean */
	bool FromSubmitBtn;	/* optional element of type xsd:boolean */
	std::wstring *SortBy;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE__ns4__Activity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Activity() : ChatURL(NULL), BannerContent(NULL), BannerColor(NULL), BannerSize(NULL), BannerScroll(NULL), BannerAction(NULL), EnableChatURL(NULL), FromSubmitBtn((bool)0), SortBy(NULL), Descending((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__Activity() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ActivityResponse
#define SOAP_TYPE__ns4__ActivityResponse (160)
/* ns4:ActivityResponse */
class SOAP_CMAC _ns4__ActivityResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	std::wstring *Build;	/* optional element of type xsd:string */
	ns4__ArrayOfThorCluster *ThorClusters;	/* optional element of type ns4:ArrayOfThorCluster */
	ns4__ArrayOfRoxieCluster *RoxieClusters;	/* optional element of type ns4:ArrayOfRoxieCluster */
	ns4__ArrayOfHThorCluster *HThorClusters;	/* optional element of type ns4:ArrayOfHThorCluster */
	ns4__ArrayOfDFUJob *DFUJobs;	/* optional element of type ns4:ArrayOfDFUJob */
	ns4__ArrayOfActiveWorkunit *Running;	/* optional element of type ns4:ArrayOfActiveWorkunit */
	std::wstring *BannerContent;	/* optional element of type xsd:string */
	std::wstring *BannerColor;	/* optional element of type xsd:string */
	std::wstring *BannerSize;	/* optional element of type xsd:string */
	std::wstring *BannerScroll;	/* optional element of type xsd:string */
	std::wstring *ChatURL;	/* optional element of type xsd:string */
	int *ShowBanner;	/* optional element of type xsd:int */
	int *ShowChatURL;	/* optional element of type xsd:int */
	std::wstring *SortBy;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	bool SuperUser;	/* optional element of type xsd:boolean */
	std::wstring *AccessRight;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 160; } /* = unique id SOAP_TYPE__ns4__ActivityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ActivityResponse() : Exceptions(NULL), Build(NULL), ThorClusters(NULL), RoxieClusters(NULL), HThorClusters(NULL), DFUJobs(NULL), Running(NULL), BannerContent(NULL), BannerColor(NULL), BannerSize(NULL), BannerScroll(NULL), ChatURL(NULL), ShowBanner(NULL), ShowChatURL(NULL), SortBy(NULL), Descending((bool)0), SuperUser((bool)0), AccessRight(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__ActivityResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__BrowseResources
#define SOAP_TYPE__ns4__BrowseResources (161)
/* ns4:BrowseResources */
class SOAP_CMAC _ns4__BrowseResources
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE__ns4__BrowseResources */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__BrowseResources() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__BrowseResources() { }
};
#endif

#ifndef SOAP_TYPE__ns4__BrowseResourcesResponse
#define SOAP_TYPE__ns4__BrowseResourcesResponse (162)
/* ns4:BrowseResourcesResponse */
class SOAP_CMAC _ns4__BrowseResourcesResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	std::wstring *PortalURL;	/* optional element of type xsd:string */
	std::wstring *NetAddress;	/* optional element of type xsd:string */
	int *OS;	/* optional element of type xsd:int */
	ns4__ArrayOfHPCCResourceRepository *HPCCResourceRepositories;	/* optional element of type ns4:ArrayOfHPCCResourceRepository */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 162; } /* = unique id SOAP_TYPE__ns4__BrowseResourcesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__BrowseResourcesResponse() : Exceptions(NULL), PortalURL(NULL), NetAddress(NULL), OS(NULL), HPCCResourceRepositories(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__BrowseResourcesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ClearQueue
#define SOAP_TYPE__ns4__ClearQueue (163)
/* ns4:ClearQueue */
class SOAP_CMAC _ns4__ClearQueue
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE__ns4__ClearQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ClearQueue() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__ClearQueue() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCQueueResponse
#define SOAP_TYPE__ns4__SMCQueueResponse (164)
/* ns4:SMCQueueResponse */
class SOAP_CMAC _ns4__SMCQueueResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE__ns4__SMCQueueResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCQueueResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCQueueResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__GetThorQueueAvailability
#define SOAP_TYPE__ns4__GetThorQueueAvailability (165)
/* ns4:GetThorQueueAvailability */
class SOAP_CMAC _ns4__GetThorQueueAvailability
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 165; } /* = unique id SOAP_TYPE__ns4__GetThorQueueAvailability */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetThorQueueAvailability() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__GetThorQueueAvailability() { }
};
#endif

#ifndef SOAP_TYPE__ns4__GetThorQueueAvailabilityResponse
#define SOAP_TYPE__ns4__GetThorQueueAvailabilityResponse (166)
/* ns4:GetThorQueueAvailabilityResponse */
class SOAP_CMAC _ns4__GetThorQueueAvailabilityResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	ns4__ArrayOfThorCluster *ThorClusters;	/* optional element of type ns4:ArrayOfThorCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique id SOAP_TYPE__ns4__GetThorQueueAvailabilityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__GetThorQueueAvailabilityResponse() : Exceptions(NULL), ThorClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__GetThorQueueAvailabilityResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Index
#define SOAP_TYPE__ns4__Index (167)
/* ns4:Index */
class SOAP_CMAC _ns4__Index
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE__ns4__Index */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Index() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__Index() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCIndexResponse
#define SOAP_TYPE__ns4__SMCIndexResponse (168)
/* ns4:SMCIndexResponse */
class SOAP_CMAC _ns4__SMCIndexResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE__ns4__SMCIndexResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCIndexResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCIndexResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobBack
#define SOAP_TYPE__ns4__MoveJobBack (169)
/* ns4:MoveJobBack */
class SOAP_CMAC _ns4__MoveJobBack
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE__ns4__MoveJobBack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobBack() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobBack() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCJobResponse
#define SOAP_TYPE__ns4__SMCJobResponse (170)
/* ns4:SMCJobResponse */
class SOAP_CMAC _ns4__SMCJobResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE__ns4__SMCJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCJobResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobDown
#define SOAP_TYPE__ns4__MoveJobDown (171)
/* ns4:MoveJobDown */
class SOAP_CMAC _ns4__MoveJobDown
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique id SOAP_TYPE__ns4__MoveJobDown */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobDown() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobDown() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobFront
#define SOAP_TYPE__ns4__MoveJobFront (172)
/* ns4:MoveJobFront */
class SOAP_CMAC _ns4__MoveJobFront
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE__ns4__MoveJobFront */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobFront() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobFront() { }
};
#endif

#ifndef SOAP_TYPE__ns4__MoveJobUp
#define SOAP_TYPE__ns4__MoveJobUp (173)
/* ns4:MoveJobUp */
class SOAP_CMAC _ns4__MoveJobUp
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique id SOAP_TYPE__ns4__MoveJobUp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__MoveJobUp() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__MoveJobUp() { }
};
#endif

#ifndef SOAP_TYPE__ns4__NotInCommunityEdition
#define SOAP_TYPE__ns4__NotInCommunityEdition (174)
/* ns4:NotInCommunityEdition */
class SOAP_CMAC _ns4__NotInCommunityEdition
{
public:
	std::wstring *EEPortal;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE__ns4__NotInCommunityEdition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__NotInCommunityEdition() : EEPortal(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__NotInCommunityEdition() { }
};
#endif

#ifndef SOAP_TYPE__ns4__NotInCommunityEditionResponse
#define SOAP_TYPE__ns4__NotInCommunityEditionResponse (175)
/* ns4:NotInCommunityEditionResponse */
class SOAP_CMAC _ns4__NotInCommunityEditionResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE__ns4__NotInCommunityEditionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__NotInCommunityEditionResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__NotInCommunityEditionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__PauseQueue
#define SOAP_TYPE__ns4__PauseQueue (176)
/* ns4:PauseQueue */
class SOAP_CMAC _ns4__PauseQueue
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE__ns4__PauseQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__PauseQueue() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__PauseQueue() { }
};
#endif

#ifndef SOAP_TYPE__ns4__RemoveJob
#define SOAP_TYPE__ns4__RemoveJob (177)
/* ns4:RemoveJob */
class SOAP_CMAC _ns4__RemoveJob
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique id SOAP_TYPE__ns4__RemoveJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__RemoveJob() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__RemoveJob() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ResumeQueue
#define SOAP_TYPE__ns4__ResumeQueue (178)
/* ns4:ResumeQueue */
class SOAP_CMAC _ns4__ResumeQueue
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE__ns4__ResumeQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ResumeQueue() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__ResumeQueue() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SetBanner
#define SOAP_TYPE__ns4__SetBanner (179)
/* ns4:SetBanner */
class SOAP_CMAC _ns4__SetBanner
{
public:
	std::wstring *ChatURL;	/* optional element of type xsd:string */
	std::wstring *BannerContent;	/* optional element of type xsd:string */
	std::wstring *BannerColor;	/* optional element of type xsd:string */
	std::wstring *BannerSize;	/* optional element of type xsd:string */
	std::wstring *BannerScroll;	/* optional element of type xsd:string */
	int *BannerAction;	/* optional element of type xsd:int */
	bool *EnableChatURL;	/* optional element of type xsd:boolean */
	bool FromSubmitBtn;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE__ns4__SetBanner */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetBanner() : ChatURL(NULL), BannerContent(NULL), BannerColor(NULL), BannerSize(NULL), BannerScroll(NULL), BannerAction(NULL), EnableChatURL(NULL), FromSubmitBtn((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SetBanner() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SetBannerResponse
#define SOAP_TYPE__ns4__SetBannerResponse (180)
/* ns4:SetBannerResponse */
class SOAP_CMAC _ns4__SetBannerResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique id SOAP_TYPE__ns4__SetBannerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetBannerResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SetBannerResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SetJobPriority
#define SOAP_TYPE__ns4__SetJobPriority (181)
/* ns4:SetJobPriority */
class SOAP_CMAC _ns4__SetJobPriority
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Priority;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 181; } /* = unique id SOAP_TYPE__ns4__SetJobPriority */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SetJobPriority() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), Wuid(NULL), Priority(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SetJobPriority() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SMCPriorityResponse
#define SOAP_TYPE__ns4__SMCPriorityResponse (182)
/* ns4:SMCPriorityResponse */
class SOAP_CMAC _ns4__SMCPriorityResponse
{
public:
	ns4__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE__ns4__SMCPriorityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SMCPriorityResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__SMCPriorityResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__StopQueue
#define SOAP_TYPE__ns4__StopQueue (183)
/* ns4:StopQueue */
class SOAP_CMAC _ns4__StopQueue
{
public:
	int *ClusterType;	/* optional element of type xsd:int */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique id SOAP_TYPE__ns4__StopQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__StopQueue() : ClusterType(NULL), Cluster(NULL), QueueName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns4__StopQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns5__EspException
#define SOAP_TYPE_ns5__EspException (184)
/* ns5:EspException */
class SOAP_CMAC ns5__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique id SOAP_TYPE_ns5__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfEspException
#define SOAP_TYPE_ns5__ArrayOfEspException (185)
/* ns5:ArrayOfEspException */
class SOAP_CMAC ns5__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns5__EspException * >Exception;	/* optional element of type ns5:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique id SOAP_TYPE_ns5__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpTargetCluster
#define SOAP_TYPE_ns5__TpTargetCluster (186)
/* ns5:TpTargetCluster */
class SOAP_CMAC ns5__TpTargetCluster
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	class ns5__ArrayOfTpCluster *TpClusters;	/* optional element of type ns5:ArrayOfTpCluster */
	class ns5__ArrayOfTpEclServer *TpEclCCServers;	/* optional element of type ns5:ArrayOfTpEclServer */
	class ns5__ArrayOfTpEclAgent *TpEclAgents;	/* optional element of type ns5:ArrayOfTpEclAgent */
	class ns5__ArrayOfTpEclScheduler *TpEclSchedulers;	/* optional element of type ns5:ArrayOfTpEclScheduler */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 186; } /* = unique id SOAP_TYPE_ns5__TpTargetCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpTargetCluster() : Name(NULL), Prefix(NULL), Type(NULL), TpClusters(NULL), TpEclCCServers(NULL), TpEclAgents(NULL), TpEclSchedulers(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpTargetCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpCluster
#define SOAP_TYPE_ns5__TpCluster (187)
/* ns5:TpCluster */
class SOAP_CMAC ns5__TpCluster
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *QueueName;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Desc;	/* optional element of type xsd:string */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *DataModel;	/* optional element of type xsd:string */
	int *OS;	/* optional element of type xsd:int */
	bool *HasThorSpareProcess;	/* optional element of type xsd:boolean */
	class ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 187; } /* = unique id SOAP_TYPE_ns5__TpCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpCluster() : Type(NULL), Name(NULL), QueueName(NULL), Build(NULL), Directory(NULL), LogDirectory(NULL), Desc(NULL), Prefix(NULL), Path(NULL), DataModel(NULL), OS(NULL), HasThorSpareProcess(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpMachine
#define SOAP_TYPE_ns5__TpMachine (188)
/* ns5:TpMachine */
class SOAP_CMAC ns5__TpMachine
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Netaddress;	/* optional element of type xsd:string */
	std::wstring *ConfigNetaddress;	/* optional element of type xsd:string */
	std::wstring *Domain;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Available;	/* optional element of type xsd:string */
	int *OS;	/* optional element of type xsd:int */
	std::wstring *Path;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	int *ProcessNumber;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 188; } /* = unique id SOAP_TYPE_ns5__TpMachine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpMachine() : Name(NULL), Netaddress(NULL), ConfigNetaddress(NULL), Domain(NULL), Directory(NULL), Type(NULL), Available(NULL), OS(NULL), Path(NULL), Port(NULL), ProcessNumber(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpMachine() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpMachine
#define SOAP_TYPE_ns5__ArrayOfTpMachine (189)
/* ns5:ArrayOfTpMachine */
class SOAP_CMAC ns5__ArrayOfTpMachine
{
public:
	std::vector<ns5__TpMachine * >TpMachine;	/* optional element of type ns5:TpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 189; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpMachine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpMachine() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpMachine() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEclServer
#define SOAP_TYPE_ns5__TpEclServer (190)
/* ns5:TpEclServer */
class SOAP_CMAC ns5__TpEclServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 190; } /* = unique id SOAP_TYPE_ns5__TpEclServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEclServer() : Name(NULL), Description(NULL), Build(NULL), LogDirectory(NULL), Type(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEclServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEclAgent
#define SOAP_TYPE_ns5__TpEclAgent (191)
/* ns5:TpEclAgent */
class SOAP_CMAC ns5__TpEclAgent
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *DaliServer;	/* optional element of type xsd:string */
	std::wstring *LogDir;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 191; } /* = unique id SOAP_TYPE_ns5__TpEclAgent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEclAgent() : Name(NULL), Description(NULL), Build(NULL), Type(NULL), Path(NULL), DaliServer(NULL), LogDir(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEclAgent() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEclScheduler
#define SOAP_TYPE_ns5__TpEclScheduler (192)
/* ns5:TpEclScheduler */
class SOAP_CMAC ns5__TpEclScheduler
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 192; } /* = unique id SOAP_TYPE_ns5__TpEclScheduler */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEclScheduler() : Name(NULL), Description(NULL), Build(NULL), LogDirectory(NULL), Type(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEclScheduler() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpCluster
#define SOAP_TYPE_ns5__ArrayOfTpCluster (193)
/* ns5:ArrayOfTpCluster */
class SOAP_CMAC ns5__ArrayOfTpCluster
{
public:
	std::vector<ns5__TpCluster * >TpCluster;	/* optional element of type ns5:TpCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 193; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEclAgent
#define SOAP_TYPE_ns5__ArrayOfTpEclAgent (194)
/* ns5:ArrayOfTpEclAgent */
class SOAP_CMAC ns5__ArrayOfTpEclAgent
{
public:
	std::vector<ns5__TpEclAgent * >TpEclAgent;	/* optional element of type ns5:TpEclAgent */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 194; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEclAgent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEclAgent() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEclAgent() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEclScheduler
#define SOAP_TYPE_ns5__ArrayOfTpEclScheduler (195)
/* ns5:ArrayOfTpEclScheduler */
class SOAP_CMAC ns5__ArrayOfTpEclScheduler
{
public:
	std::vector<ns5__TpEclScheduler * >TpEclScheduler;	/* optional element of type ns5:TpEclScheduler */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEclScheduler */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEclScheduler() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEclScheduler() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEclServer
#define SOAP_TYPE_ns5__ArrayOfTpEclServer (196)
/* ns5:ArrayOfTpEclServer */
class SOAP_CMAC ns5__ArrayOfTpEclServer
{
public:
	std::vector<ns5__TpEclServer * >TpEclServer;	/* optional element of type ns5:TpEclServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 196; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEclServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEclServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEclServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpServices
#define SOAP_TYPE_ns5__TpServices (197)
/* ns5:TpServices */
class SOAP_CMAC ns5__TpServices
{
public:
	class ns5__ArrayOfTpDali *TpDalis;	/* optional element of type ns5:ArrayOfTpDali */
	class ns5__ArrayOfTpDfuServer *TpDfuServers;	/* optional element of type ns5:ArrayOfTpDfuServer */
	class ns5__ArrayOfTpDkcSlave *TpDkcSlaves;	/* optional element of type ns5:ArrayOfTpDkcSlave */
	class ns5__ArrayOfTpDropZone *TpDropZones;	/* optional element of type ns5:ArrayOfTpDropZone */
	ns5__ArrayOfTpEclAgent *TpEclAgents;	/* optional element of type ns5:ArrayOfTpEclAgent */
	ns5__ArrayOfTpEclServer *TpEclServers;	/* optional element of type ns5:ArrayOfTpEclServer */
	ns5__ArrayOfTpEclServer *TpEclCCServers;	/* optional element of type ns5:ArrayOfTpEclServer */
	ns5__ArrayOfTpEclScheduler *TpEclSchedulers;	/* optional element of type ns5:ArrayOfTpEclScheduler */
	class ns5__ArrayOfTpEspServer *TpEspServers;	/* optional element of type ns5:ArrayOfTpEspServer */
	class ns5__ArrayOfTpFTSlave *TpFTSlaves;	/* optional element of type ns5:ArrayOfTpFTSlave */
	class ns5__ArrayOfTpGenesisServer *TpGenesisServers;	/* optional element of type ns5:ArrayOfTpGenesisServer */
	class ns5__ArrayOfTpLdapServer *TpLdapServers;	/* optional element of type ns5:ArrayOfTpLdapServer */
	class ns5__ArrayOfTpMySqlServer *TpMySqlServers;	/* optional element of type ns5:ArrayOfTpMySqlServer */
	class ns5__ArrayOfTpSashaServer *TpSashaServers;	/* optional element of type ns5:ArrayOfTpSashaServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 197; } /* = unique id SOAP_TYPE_ns5__TpServices */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpServices() : TpDalis(NULL), TpDfuServers(NULL), TpDkcSlaves(NULL), TpDropZones(NULL), TpEclAgents(NULL), TpEclServers(NULL), TpEclCCServers(NULL), TpEclSchedulers(NULL), TpEspServers(NULL), TpFTSlaves(NULL), TpGenesisServers(NULL), TpLdapServers(NULL), TpMySqlServers(NULL), TpSashaServers(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpServices() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDali
#define SOAP_TYPE_ns5__TpDali (198)
/* ns5:TpDali */
class SOAP_CMAC ns5__TpDali
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *BackupComputer;	/* optional element of type xsd:string */
	std::wstring *BackupDirectory;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 198; } /* = unique id SOAP_TYPE_ns5__TpDali */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDali() : Name(NULL), Description(NULL), Build(NULL), BackupComputer(NULL), BackupDirectory(NULL), Type(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDali() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDfuServer
#define SOAP_TYPE_ns5__TpDfuServer (199)
/* ns5:TpDfuServer */
class SOAP_CMAC ns5__TpDfuServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE_ns5__TpDfuServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDfuServer() : Name(NULL), Description(NULL), Build(NULL), Queue(NULL), Type(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDfuServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDkcSlave
#define SOAP_TYPE_ns5__TpDkcSlave (200)
/* ns5:TpDkcSlave */
class SOAP_CMAC ns5__TpDkcSlave
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 200; } /* = unique id SOAP_TYPE_ns5__TpDkcSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDkcSlave() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDkcSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpDropZone
#define SOAP_TYPE_ns5__TpDropZone (201)
/* ns5:TpDropZone */
class SOAP_CMAC ns5__TpDropZone
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 201; } /* = unique id SOAP_TYPE_ns5__TpDropZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpDropZone() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpDropZone() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpEspServer
#define SOAP_TYPE_ns5__TpEspServer (202)
/* ns5:TpEspServer */
class SOAP_CMAC ns5__TpEspServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	class ns5__ArrayOfTpBinding *TpBindings;	/* optional element of type ns5:ArrayOfTpBinding */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 202; } /* = unique id SOAP_TYPE_ns5__TpEspServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpEspServer() : Name(NULL), Description(NULL), Build(NULL), Type(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), TpBindings(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpEspServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpBinding
#define SOAP_TYPE_ns5__TpBinding (203)
/* ns5:TpBinding */
class SOAP_CMAC ns5__TpBinding
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Service;	/* optional element of type xsd:string */
	std::wstring *ServiceType;	/* optional element of type xsd:string */
	std::wstring *Port;	/* optional element of type xsd:string */
	std::wstring *Protocol;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 203; } /* = unique id SOAP_TYPE_ns5__TpBinding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpBinding() : Name(NULL), Service(NULL), ServiceType(NULL), Port(NULL), Protocol(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpBinding() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpBinding
#define SOAP_TYPE_ns5__ArrayOfTpBinding (204)
/* ns5:ArrayOfTpBinding */
class SOAP_CMAC ns5__ArrayOfTpBinding
{
public:
	std::vector<ns5__TpBinding * >TpBinding;	/* optional element of type ns5:TpBinding */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 204; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpBinding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpBinding() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpBinding() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpFTSlave
#define SOAP_TYPE_ns5__TpFTSlave (205)
/* ns5:TpFTSlave */
class SOAP_CMAC ns5__TpFTSlave
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 205; } /* = unique id SOAP_TYPE_ns5__TpFTSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpFTSlave() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpFTSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpGenesisServer
#define SOAP_TYPE_ns5__TpGenesisServer (206)
/* ns5:TpGenesisServer */
class SOAP_CMAC ns5__TpGenesisServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 206; } /* = unique id SOAP_TYPE_ns5__TpGenesisServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpGenesisServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpGenesisServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpLdapServer
#define SOAP_TYPE_ns5__TpLdapServer (207)
/* ns5:TpLdapServer */
class SOAP_CMAC ns5__TpLdapServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 207; } /* = unique id SOAP_TYPE_ns5__TpLdapServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpLdapServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpLdapServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpMySqlServer
#define SOAP_TYPE_ns5__TpMySqlServer (208)
/* ns5:TpMySqlServer */
class SOAP_CMAC ns5__TpMySqlServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 208; } /* = unique id SOAP_TYPE_ns5__TpMySqlServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpMySqlServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpMySqlServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpSashaServer
#define SOAP_TYPE_ns5__TpSashaServer (209)
/* ns5:TpSashaServer */
class SOAP_CMAC ns5__TpSashaServer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *Build;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 209; } /* = unique id SOAP_TYPE_ns5__TpSashaServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpSashaServer() : Name(NULL), Description(NULL), Build(NULL), Path(NULL), LogDirectory(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpSashaServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDali
#define SOAP_TYPE_ns5__ArrayOfTpDali (210)
/* ns5:ArrayOfTpDali */
class SOAP_CMAC ns5__ArrayOfTpDali
{
public:
	std::vector<ns5__TpDali * >TpDali;	/* optional element of type ns5:TpDali */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 210; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDali */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDali() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDali() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDfuServer
#define SOAP_TYPE_ns5__ArrayOfTpDfuServer (211)
/* ns5:ArrayOfTpDfuServer */
class SOAP_CMAC ns5__ArrayOfTpDfuServer
{
public:
	std::vector<ns5__TpDfuServer * >TpDfuServer;	/* optional element of type ns5:TpDfuServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 211; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDfuServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDfuServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDfuServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDkcSlave
#define SOAP_TYPE_ns5__ArrayOfTpDkcSlave (212)
/* ns5:ArrayOfTpDkcSlave */
class SOAP_CMAC ns5__ArrayOfTpDkcSlave
{
public:
	std::vector<ns5__TpDkcSlave * >TpDkcSlave;	/* optional element of type ns5:TpDkcSlave */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 212; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDkcSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDkcSlave() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDkcSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpDropZone
#define SOAP_TYPE_ns5__ArrayOfTpDropZone (213)
/* ns5:ArrayOfTpDropZone */
class SOAP_CMAC ns5__ArrayOfTpDropZone
{
public:
	std::vector<ns5__TpDropZone * >TpDropZone;	/* optional element of type ns5:TpDropZone */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 213; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpDropZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpDropZone() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpDropZone() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpEspServer
#define SOAP_TYPE_ns5__ArrayOfTpEspServer (214)
/* ns5:ArrayOfTpEspServer */
class SOAP_CMAC ns5__ArrayOfTpEspServer
{
public:
	std::vector<ns5__TpEspServer * >TpEspServer;	/* optional element of type ns5:TpEspServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 214; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpEspServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpEspServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpEspServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpFTSlave
#define SOAP_TYPE_ns5__ArrayOfTpFTSlave (215)
/* ns5:ArrayOfTpFTSlave */
class SOAP_CMAC ns5__ArrayOfTpFTSlave
{
public:
	std::vector<ns5__TpFTSlave * >TpFTSlave;	/* optional element of type ns5:TpFTSlave */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 215; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpFTSlave */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpFTSlave() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpFTSlave() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpGenesisServer
#define SOAP_TYPE_ns5__ArrayOfTpGenesisServer (216)
/* ns5:ArrayOfTpGenesisServer */
class SOAP_CMAC ns5__ArrayOfTpGenesisServer
{
public:
	std::vector<ns5__TpGenesisServer * >TpGenesisServer;	/* optional element of type ns5:TpGenesisServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 216; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpGenesisServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpGenesisServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpGenesisServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpLdapServer
#define SOAP_TYPE_ns5__ArrayOfTpLdapServer (217)
/* ns5:ArrayOfTpLdapServer */
class SOAP_CMAC ns5__ArrayOfTpLdapServer
{
public:
	std::vector<ns5__TpLdapServer * >TpLdapServer;	/* optional element of type ns5:TpLdapServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 217; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpLdapServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpLdapServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpLdapServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpMySqlServer
#define SOAP_TYPE_ns5__ArrayOfTpMySqlServer (218)
/* ns5:ArrayOfTpMySqlServer */
class SOAP_CMAC ns5__ArrayOfTpMySqlServer
{
public:
	std::vector<ns5__TpMySqlServer * >TpMySqlServer;	/* optional element of type ns5:TpMySqlServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 218; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpMySqlServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpMySqlServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpMySqlServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpSashaServer
#define SOAP_TYPE_ns5__ArrayOfTpSashaServer (219)
/* ns5:ArrayOfTpSashaServer */
class SOAP_CMAC ns5__ArrayOfTpSashaServer
{
public:
	std::vector<ns5__TpSashaServer * >TpSashaServer;	/* optional element of type ns5:TpSashaServer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 219; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpSashaServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpSashaServer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpSashaServer() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpQueryType
#define SOAP_TYPE_ns5__TpQueryType (220)
/* ns5:TpQueryType */
class SOAP_CMAC ns5__TpQueryType
{
public:
	std::wstring *TPCLUSTER;	/* optional element of type xsd:string */
	std::wstring *TPNODE;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 220; } /* = unique id SOAP_TYPE_ns5__TpQueryType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpQueryType() : TPCLUSTER(NULL), TPNODE(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpQueryType() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpLogicalCluster
#define SOAP_TYPE_ns5__TpLogicalCluster (221)
/* ns5:TpLogicalCluster */
class SOAP_CMAC ns5__TpLogicalCluster
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *LanguageVersion;	/* optional element of type xsd:string */
	std::wstring *Process;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 221; } /* = unique id SOAP_TYPE_ns5__TpLogicalCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpLogicalCluster() : Name(NULL), Queue(NULL), LanguageVersion(NULL), Process(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpLogicalCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpGroup
#define SOAP_TYPE_ns5__TpGroup (222)
/* ns5:TpGroup */
class SOAP_CMAC ns5__TpGroup
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Prefix;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE_ns5__TpGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpGroup() : Name(NULL), Prefix(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpGroup() { }
};
#endif

#ifndef SOAP_TYPE_ns5__TpQueue
#define SOAP_TYPE_ns5__TpQueue (223)
/* ns5:TpQueue */
class SOAP_CMAC ns5__TpQueue
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *WorkUnit;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 223; } /* = unique id SOAP_TYPE_ns5__TpQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__TpQueue() : Name(NULL), WorkUnit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__TpQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpQueue
#define SOAP_TYPE_ns5__ArrayOfTpQueue (224)
/* ns5:ArrayOfTpQueue */
class SOAP_CMAC ns5__ArrayOfTpQueue
{
public:
	std::vector<ns5__TpQueue * >TpQueue;	/* optional element of type ns5:TpQueue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 224; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpQueue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpQueue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpQueue() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpGroup
#define SOAP_TYPE_ns5__ArrayOfTpGroup (225)
/* ns5:ArrayOfTpGroup */
class SOAP_CMAC ns5__ArrayOfTpGroup
{
public:
	std::vector<ns5__TpGroup * >TpGroup;	/* optional element of type ns5:TpGroup */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 225; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpGroup() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpGroup() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpLogicalCluster
#define SOAP_TYPE_ns5__ArrayOfTpLogicalCluster (226)
/* ns5:ArrayOfTpLogicalCluster */
class SOAP_CMAC ns5__ArrayOfTpLogicalCluster
{
public:
	std::vector<ns5__TpLogicalCluster * >TpLogicalCluster;	/* optional element of type ns5:TpLogicalCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 226; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpLogicalCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpLogicalCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpLogicalCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ArrayOfTpTargetCluster
#define SOAP_TYPE_ns5__ArrayOfTpTargetCluster (227)
/* ns5:ArrayOfTpTargetCluster */
class SOAP_CMAC ns5__ArrayOfTpTargetCluster
{
public:
	std::vector<ns5__TpTargetCluster * >TpTargetCluster;	/* optional element of type ns5:TpTargetCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 227; } /* = unique id SOAP_TYPE_ns5__ArrayOfTpTargetCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ArrayOfTpTargetCluster() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns5__ArrayOfTpTargetCluster() { }
};
#endif

#ifndef SOAP_TYPE__ns5__SystemLogRequest
#define SOAP_TYPE__ns5__SystemLogRequest (228)
/* ns5:SystemLogRequest */
class SOAP_CMAC _ns5__SystemLogRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Zip;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 228; } /* = unique id SOAP_TYPE__ns5__SystemLogRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__SystemLogRequest() : Name(NULL), Type(NULL), Zip(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__SystemLogRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__SystemLogResponse
#define SOAP_TYPE__ns5__SystemLogResponse (229)
/* ns5:SystemLogResponse */
class SOAP_CMAC _ns5__SystemLogResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 229; } /* = unique id SOAP_TYPE__ns5__SystemLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__SystemLogResponse() : Exceptions(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__SystemLogResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterInfoRequest
#define SOAP_TYPE__ns5__TpClusterInfoRequest (230)
/* ns5:TpClusterInfoRequest */
class SOAP_CMAC _ns5__TpClusterInfoRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 230; } /* = unique id SOAP_TYPE__ns5__TpClusterInfoRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterInfoRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterInfoRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterInfoResponse
#define SOAP_TYPE__ns5__TpClusterInfoResponse (231)
/* ns5:TpClusterInfoResponse */
class SOAP_CMAC _ns5__TpClusterInfoResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *WorkUnit;	/* optional element of type xsd:string */
	ns5__ArrayOfTpQueue *TpQueues;	/* optional element of type ns5:ArrayOfTpQueue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 231; } /* = unique id SOAP_TYPE__ns5__TpClusterInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterInfoResponse() : Exceptions(NULL), Name(NULL), WorkUnit(NULL), TpQueues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterQueryRequest
#define SOAP_TYPE__ns5__TpClusterQueryRequest (232)
/* ns5:TpClusterQueryRequest */
class SOAP_CMAC _ns5__TpClusterQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 232; } /* = unique id SOAP_TYPE__ns5__TpClusterQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterQueryRequest() : Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpClusterQueryResponse
#define SOAP_TYPE__ns5__TpClusterQueryResponse (233)
/* ns5:TpClusterQueryResponse */
class SOAP_CMAC _ns5__TpClusterQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *EnableSNMP;	/* optional element of type xsd:boolean */
	ns5__ArrayOfTpCluster *TpClusters;	/* optional element of type ns5:ArrayOfTpCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 233; } /* = unique id SOAP_TYPE__ns5__TpClusterQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpClusterQueryResponse() : Exceptions(NULL), EnableSNMP(NULL), TpClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpClusterQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGetComponentFileRequest
#define SOAP_TYPE__ns5__TpGetComponentFileRequest (234)
/* ns5:TpGetComponentFileRequest */
class SOAP_CMAC _ns5__TpGetComponentFileRequest
{
public:
	std::wstring *CompType;	/* optional element of type xsd:string */
	std::wstring *CompName;	/* optional element of type xsd:string */
	std::wstring *NetAddress;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *FileType;	/* optional element of type xsd:string */
	int *OsType;	/* optional element of type xsd:int */
	std::wstring *PlainText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 234; } /* = unique id SOAP_TYPE__ns5__TpGetComponentFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGetComponentFileRequest() : CompType(NULL), CompName(NULL), NetAddress(NULL), Directory(NULL), FileType(NULL), OsType(NULL), PlainText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGetComponentFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGetComponentFileResponse
#define SOAP_TYPE__ns5__TpGetComponentFileResponse (235)
/* ns5:TpGetComponentFileResponse */
class SOAP_CMAC _ns5__TpGetComponentFileResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	xsd__base64Binary *FileContents;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 235; } /* = unique id SOAP_TYPE__ns5__TpGetComponentFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGetComponentFileResponse() : Exceptions(NULL), FileContents(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGetComponentFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGroupQueryRequest
#define SOAP_TYPE__ns5__TpGroupQueryRequest (236)
/* ns5:TpGroupQueryRequest */
class SOAP_CMAC _ns5__TpGroupQueryRequest
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 236; } /* = unique id SOAP_TYPE__ns5__TpGroupQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGroupQueryRequest() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGroupQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpGroupQueryResponse
#define SOAP_TYPE__ns5__TpGroupQueryResponse (237)
/* ns5:TpGroupQueryResponse */
class SOAP_CMAC _ns5__TpGroupQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	ns5__ArrayOfTpGroup *TpGroups;	/* optional element of type ns5:ArrayOfTpGroup */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 237; } /* = unique id SOAP_TYPE__ns5__TpGroupQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpGroupQueryResponse() : Exceptions(NULL), TpGroups(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpGroupQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogFileRequest
#define SOAP_TYPE__ns5__TpLogFileRequest (238)
/* ns5:TpLogFileRequest */
class SOAP_CMAC _ns5__TpLogFileRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	int *FirstRows;	/* optional element of type xsd:int */
	int *LastRows;	/* optional element of type xsd:int */
	int *FilterType;	/* optional element of type xsd:int */
	bool Reversely;	/* optional element of type xsd:boolean */
	bool Zip;	/* optional element of type xsd:boolean */
	int *PageNumber;	/* optional element of type xsd:int */
	bool LoadData;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 238; } /* = unique id SOAP_TYPE__ns5__TpLogFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogFileRequest() : Name(NULL), Type(NULL), StartDate(NULL), EndDate(NULL), FirstRows(NULL), LastRows(NULL), FilterType(NULL), Reversely((bool)0), Zip((bool)0), PageNumber(NULL), LoadData((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogFileResponse
#define SOAP_TYPE__ns5__TpLogFileResponse (239)
/* ns5:TpLogFileResponse */
class SOAP_CMAC _ns5__TpLogFileResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	int *LastHours;	/* optional element of type xsd:int */
	int *FirstRows;	/* optional element of type xsd:int */
	int *LastRows;	/* optional element of type xsd:int */
	bool *Reversely;	/* optional element of type xsd:boolean */
	bool *Zip;	/* optional element of type xsd:boolean */
	int *FilterType;	/* optional element of type xsd:int */
	std::wstring *LogData;	/* optional element of type xsd:string */
	bool HasDate;	/* optional element of type xsd:boolean */
	LONG64 *FileSize;	/* optional element of type xsd:long */
	LONG64 *PageFrom;	/* optional element of type xsd:long */
	LONG64 *PageTo;	/* optional element of type xsd:long */
	int *PageNumber;	/* optional element of type xsd:int */
	int PrevPage;	/* optional element of type xsd:int */
	int NextPage;	/* optional element of type xsd:int */
	int *TotalPages;	/* optional element of type xsd:int */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 239; } /* = unique id SOAP_TYPE__ns5__TpLogFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogFileResponse() : Exceptions(NULL), Name(NULL), Type(NULL), StartDate(NULL), EndDate(NULL), LastHours(NULL), FirstRows(NULL), LastRows(NULL), Reversely(NULL), Zip(NULL), FilterType(NULL), LogData(NULL), HasDate((bool)0), FileSize(NULL), PageFrom(NULL), PageTo(NULL), PageNumber(NULL), PrevPage(0), NextPage(0), TotalPages(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogicalClusterQueryRequest
#define SOAP_TYPE__ns5__TpLogicalClusterQueryRequest (240)
/* ns5:TpLogicalClusterQueryRequest */
class SOAP_CMAC _ns5__TpLogicalClusterQueryRequest
{
public:
	std::wstring *EclServerQueue;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 240; } /* = unique id SOAP_TYPE__ns5__TpLogicalClusterQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogicalClusterQueryRequest() : EclServerQueue(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogicalClusterQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpLogicalClusterQueryResponse
#define SOAP_TYPE__ns5__TpLogicalClusterQueryResponse (241)
/* ns5:TpLogicalClusterQueryResponse */
class SOAP_CMAC _ns5__TpLogicalClusterQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	ns5__ArrayOfTpLogicalCluster *TpLogicalClusters;	/* optional element of type ns5:ArrayOfTpLogicalCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 241; } /* = unique id SOAP_TYPE__ns5__TpLogicalClusterQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpLogicalClusterQueryResponse() : Exceptions(NULL), TpLogicalClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpLogicalClusterQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpMachineQueryRequest
#define SOAP_TYPE__ns5__TpMachineQueryRequest (242)
/* ns5:TpMachineQueryRequest */
class SOAP_CMAC _ns5__TpMachineQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *OldIP;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	std::wstring *Directory;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 242; } /* = unique id SOAP_TYPE__ns5__TpMachineQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpMachineQueryRequest() : Type(NULL), Cluster(NULL), OldIP(NULL), Path(NULL), Directory(NULL), LogDirectory(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpMachineQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpMachineQueryResponse
#define SOAP_TYPE__ns5__TpMachineQueryResponse (243)
/* ns5:TpMachineQueryResponse */
class SOAP_CMAC _ns5__TpMachineQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *EnablePreflightInfo;	/* optional element of type xsd:boolean */
	bool *HasThorSpareProcess;	/* optional element of type xsd:boolean */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *OldIP;	/* optional element of type xsd:string */
	std::wstring *LogDirectory;	/* optional element of type xsd:string */
	std::wstring *Path;	/* optional element of type xsd:string */
	int *MemThreshold;	/* optional element of type xsd:int */
	int *DiskThreshold;	/* optional element of type xsd:int */
	int *CpuThreshold;	/* optional element of type xsd:int */
	std::wstring *MemThresholdType;	/* optional element of type xsd:string */
	std::wstring *DiskThresholdType;	/* optional element of type xsd:string */
	std::wstring *PreflightProcessFilter;	/* optional element of type xsd:string */
	bool *EnableSNMP;	/* optional element of type xsd:boolean */
	ns5__ArrayOfTpMachine *TpMachines;	/* optional element of type ns5:ArrayOfTpMachine */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 243; } /* = unique id SOAP_TYPE__ns5__TpMachineQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpMachineQueryResponse() : Exceptions(NULL), EnablePreflightInfo(NULL), HasThorSpareProcess(NULL), Type(NULL), Cluster(NULL), OldIP(NULL), LogDirectory(NULL), Path(NULL), MemThreshold(NULL), DiskThreshold(NULL), CpuThreshold(NULL), MemThresholdType(NULL), DiskThresholdType(NULL), PreflightProcessFilter(NULL), EnableSNMP(NULL), TpMachines(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpMachineQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpServiceQueryRequest
#define SOAP_TYPE__ns5__TpServiceQueryRequest (244)
/* ns5:TpServiceQueryRequest */
class SOAP_CMAC _ns5__TpServiceQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 244; } /* = unique id SOAP_TYPE__ns5__TpServiceQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpServiceQueryRequest() : Type(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpServiceQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpServiceQueryResponse
#define SOAP_TYPE__ns5__TpServiceQueryResponse (245)
/* ns5:TpServiceQueryResponse */
class SOAP_CMAC _ns5__TpServiceQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	int *MemThreshold;	/* optional element of type xsd:int */
	int *DiskThreshold;	/* optional element of type xsd:int */
	int *CpuThreshold;	/* optional element of type xsd:int */
	bool *EncapsulatedSystem;	/* optional element of type xsd:boolean */
	bool *EnableSNMP;	/* optional element of type xsd:boolean */
	std::wstring *PreflightProcessFilter;	/* optional element of type xsd:string */
	std::wstring *MemThresholdType;	/* optional element of type xsd:string */
	std::wstring *DiskThresholdType;	/* optional element of type xsd:string */
	ns5__TpServices *ServiceList;	/* optional element of type ns5:TpServices */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 245; } /* = unique id SOAP_TYPE__ns5__TpServiceQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpServiceQueryResponse() : Exceptions(NULL), MemThreshold(NULL), DiskThreshold(NULL), CpuThreshold(NULL), EncapsulatedSystem(NULL), EnableSNMP(NULL), PreflightProcessFilter(NULL), MemThresholdType(NULL), DiskThresholdType(NULL), ServiceList(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpServiceQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSetMachineStatusRequest
#define SOAP_TYPE__ns5__TpSetMachineStatusRequest (246)
/* ns5:TpSetMachineStatusRequest */
class SOAP_CMAC _ns5__TpSetMachineStatusRequest
{
public:
	std::wstring *MachinePath;	/* optional element of type xsd:string */
	std::wstring *StatusValue;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 246; } /* = unique id SOAP_TYPE__ns5__TpSetMachineStatusRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSetMachineStatusRequest() : MachinePath(NULL), StatusValue(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSetMachineStatusRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSetMachineStatusResponse
#define SOAP_TYPE__ns5__TpSetMachineStatusResponse (247)
/* ns5:TpSetMachineStatusResponse */
class SOAP_CMAC _ns5__TpSetMachineStatusResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *TpSetMachineStatusResult;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 247; } /* = unique id SOAP_TYPE__ns5__TpSetMachineStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSetMachineStatusResponse() : Exceptions(NULL), TpSetMachineStatusResult(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSetMachineStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSwapNodeRequest
#define SOAP_TYPE__ns5__TpSwapNodeRequest (248)
/* ns5:TpSwapNodeRequest */
class SOAP_CMAC _ns5__TpSwapNodeRequest
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *OldIP;	/* optional element of type xsd:string */
	std::wstring *NewIP;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 248; } /* = unique id SOAP_TYPE__ns5__TpSwapNodeRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSwapNodeRequest() : Cluster(NULL), OldIP(NULL), NewIP(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSwapNodeRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpSwapNodeResponse
#define SOAP_TYPE__ns5__TpSwapNodeResponse (249)
/* ns5:TpSwapNodeResponse */
class SOAP_CMAC _ns5__TpSwapNodeResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool *TpSwapNodeResult;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 249; } /* = unique id SOAP_TYPE__ns5__TpSwapNodeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpSwapNodeResponse() : Exceptions(NULL), TpSwapNodeResult(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpSwapNodeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpTargetClusterQueryRequest
#define SOAP_TYPE__ns5__TpTargetClusterQueryRequest (250)
/* ns5:TpTargetClusterQueryRequest */
class SOAP_CMAC _ns5__TpTargetClusterQueryRequest
{
public:
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	bool ShowDetails;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 250; } /* = unique id SOAP_TYPE__ns5__TpTargetClusterQueryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpTargetClusterQueryRequest() : Type(NULL), Name(NULL), ShowDetails((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpTargetClusterQueryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpTargetClusterQueryResponse
#define SOAP_TYPE__ns5__TpTargetClusterQueryResponse (251)
/* ns5:TpTargetClusterQueryResponse */
class SOAP_CMAC _ns5__TpTargetClusterQueryResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	bool ShowDetails;	/* optional element of type xsd:boolean */
	int *MemThreshold;	/* optional element of type xsd:int */
	int *DiskThreshold;	/* optional element of type xsd:int */
	int *CpuThreshold;	/* optional element of type xsd:int */
	std::wstring *MemThresholdType;	/* optional element of type xsd:string */
	std::wstring *DiskThresholdType;	/* optional element of type xsd:string */
	std::wstring *PreflightProcessFilter;	/* optional element of type xsd:string */
	ns5__ArrayOfTpTargetCluster *TpTargetClusters;	/* optional element of type ns5:ArrayOfTpTargetCluster */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 251; } /* = unique id SOAP_TYPE__ns5__TpTargetClusterQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpTargetClusterQueryResponse() : Exceptions(NULL), ShowDetails((bool)0), MemThreshold(NULL), DiskThreshold(NULL), CpuThreshold(NULL), MemThresholdType(NULL), DiskThresholdType(NULL), PreflightProcessFilter(NULL), TpTargetClusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpTargetClusterQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpThorStatusRequest
#define SOAP_TYPE__ns5__TpThorStatusRequest (252)
/* ns5:TpThorStatusRequest */
class SOAP_CMAC _ns5__TpThorStatusRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE__ns5__TpThorStatusRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpThorStatusRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpThorStatusRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpThorStatusResponse
#define SOAP_TYPE__ns5__TpThorStatusResponse (253)
/* ns5:TpThorStatusResponse */
class SOAP_CMAC _ns5__TpThorStatusResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Group;	/* optional element of type xsd:string */
	std::wstring *ThorMasterIPAddress;	/* optional element of type xsd:string */
	int *Port;	/* optional element of type xsd:int */
	std::wstring *StartTime;	/* optional element of type xsd:string */
	std::wstring *LogFile;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Graph;	/* optional element of type xsd:string */
	int *SubGraph;	/* optional element of type xsd:int */
	int *SubGraphDuration;	/* optional element of type xsd:int */
	int *AutoRefresh;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 253; } /* = unique id SOAP_TYPE__ns5__TpThorStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpThorStatusResponse() : Exceptions(NULL), Name(NULL), Queue(NULL), Group(NULL), ThorMasterIPAddress(NULL), Port(NULL), StartTime(NULL), LogFile(NULL), Wuid(NULL), Graph(NULL), SubGraph(NULL), SubGraphDuration(NULL), AutoRefresh(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpThorStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpXMLFileRequest
#define SOAP_TYPE__ns5__TpXMLFileRequest (254)
/* ns5:TpXMLFileRequest */
class SOAP_CMAC _ns5__TpXMLFileRequest
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 254; } /* = unique id SOAP_TYPE__ns5__TpXMLFileRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpXMLFileRequest() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpXMLFileRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns5__TpXMLFileResponse
#define SOAP_TYPE__ns5__TpXMLFileResponse (255)
/* ns5:TpXMLFileResponse */
class SOAP_CMAC _ns5__TpXMLFileResponse
{
public:
	ns5__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns5:ArrayOfEspException */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 255; } /* = unique id SOAP_TYPE__ns5__TpXMLFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__TpXMLFileResponse() : Exceptions(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns5__TpXMLFileResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns6__EspException
#define SOAP_TYPE_ns6__EspException (256)
/* ns6:EspException */
class SOAP_CMAC ns6__EspException
{
public:
	std::wstring *Code;	/* optional element of type xsd:string */
	std::wstring *Audience;	/* optional element of type xsd:string */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 256; } /* = unique id SOAP_TYPE_ns6__EspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__EspException() : Code(NULL), Audience(NULL), Source(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__EspException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfEspException
#define SOAP_TYPE_ns6__ArrayOfEspException (257)
/* ns6:ArrayOfEspException */
class SOAP_CMAC ns6__ArrayOfEspException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::vector<ns6__EspException * >Exception;	/* optional element of type ns6:EspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 257; } /* = unique id SOAP_TYPE_ns6__ArrayOfEspException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfEspException() : Source(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfEspException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__EspStringArray
#define SOAP_TYPE_ns6__EspStringArray (258)
/* ns6:EspStringArray */
class SOAP_CMAC ns6__EspStringArray
{
public:
	std::vector<std::wstring * >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 258; } /* = unique id SOAP_TYPE_ns6__EspStringArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__EspStringArray() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__EspStringArray() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUActionResult
#define SOAP_TYPE_ns6__WUActionResult (259)
/* ns6:WUActionResult */
class SOAP_CMAC ns6__WUActionResult
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Action;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 259; } /* = unique id SOAP_TYPE_ns6__WUActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUActionResult() : Wuid(NULL), Action(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfWUActionResult
#define SOAP_TYPE_ns6__ArrayOfWUActionResult (260)
/* ns6:ArrayOfWUActionResult */
class SOAP_CMAC ns6__ArrayOfWUActionResult
{
public:
	std::vector<ns6__WUActionResult * >WUActionResult;	/* optional element of type ns6:WUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 260; } /* = unique id SOAP_TYPE_ns6__ArrayOfWUActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfWUActionResult() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfWUActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLException
#define SOAP_TYPE_ns6__ECLException (261)
/* ns6:ECLException */
class SOAP_CMAC ns6__ECLException
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Severity;	/* optional element of type xsd:string */
	int *Code;	/* optional element of type xsd:int */
	std::wstring *Message;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	int *LineNo;	/* optional element of type xsd:int */
	int *Column;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 261; } /* = unique id SOAP_TYPE_ns6__ECLException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLException() : Source(NULL), Severity(NULL), Code(NULL), Message(NULL), FileName(NULL), LineNo(NULL), Column(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUECLAttribute
#define SOAP_TYPE_ns6__WUECLAttribute (262)
/* ns6:WUECLAttribute */
class SOAP_CMAC ns6__WUECLAttribute
{
public:
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	bool *IsLocked;	/* optional element of type xsd:boolean */
	bool *IsCheckedOut;	/* optional element of type xsd:boolean */
	bool *IsSandbox;	/* optional element of type xsd:boolean */
	bool *IsOrphaned;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 262; } /* = unique id SOAP_TYPE_ns6__WUECLAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUECLAttribute() : ModuleName(NULL), AttributeName(NULL), IsLocked(NULL), IsCheckedOut(NULL), IsSandbox(NULL), IsOrphaned(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUECLAttribute() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLException
#define SOAP_TYPE_ns6__ArrayOfECLException (263)
/* ns6:ArrayOfECLException */
class SOAP_CMAC ns6__ArrayOfECLException
{
public:
	std::vector<ns6__ECLException * >ECLException;	/* optional element of type ns6:ECLException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 263; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLException() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLException() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUCopyLogicalClusterFileSections
#define SOAP_TYPE_ns6__WUCopyLogicalClusterFileSections (264)
/* ns6:WUCopyLogicalClusterFileSections */
class SOAP_CMAC ns6__WUCopyLogicalClusterFileSections
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	class ns6__ArrayOfWULogicalFileCopyInfo *OnCluster;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	ns6__ArrayOfWULogicalFileCopyInfo *NotOnCluster;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	ns6__ArrayOfWULogicalFileCopyInfo *Foreign;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	ns6__ArrayOfWULogicalFileCopyInfo *NotFound;	/* optional element of type ns6:ArrayOfWULogicalFileCopyInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 264; } /* = unique id SOAP_TYPE_ns6__WUCopyLogicalClusterFileSections */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUCopyLogicalClusterFileSections() : ClusterName(NULL), OnCluster(NULL), NotOnCluster(NULL), Foreign(NULL), NotFound(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUCopyLogicalClusterFileSections() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WULogicalFileCopyInfo
#define SOAP_TYPE_ns6__WULogicalFileCopyInfo (265)
/* ns6:WULogicalFileCopyInfo */
class SOAP_CMAC ns6__WULogicalFileCopyInfo
{
public:
	bool *IsIndex;	/* optional element of type xsd:boolean */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *DfuCopyWuid;	/* optional element of type xsd:string */
	std::wstring *DfuCopyError;	/* optional element of type xsd:string */
	ns6__EspStringArray *Clusters;	/* optional element of type ns6:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 265; } /* = unique id SOAP_TYPE_ns6__WULogicalFileCopyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WULogicalFileCopyInfo() : IsIndex(NULL), LogicalName(NULL), DfuCopyWuid(NULL), DfuCopyError(NULL), Clusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WULogicalFileCopyInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfWULogicalFileCopyInfo
#define SOAP_TYPE_ns6__ArrayOfWULogicalFileCopyInfo (266)
/* ns6:ArrayOfWULogicalFileCopyInfo */
class SOAP_CMAC ns6__ArrayOfWULogicalFileCopyInfo
{
public:
	std::vector<ns6__WULogicalFileCopyInfo * >WULogicalFileCopyInfo;	/* optional element of type ns6:WULogicalFileCopyInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 266; } /* = unique id SOAP_TYPE_ns6__ArrayOfWULogicalFileCopyInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfWULogicalFileCopyInfo() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfWULogicalFileCopyInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__ECLWorkunit_AllowedClusters
#define SOAP_TYPE__ns6__ECLWorkunit_AllowedClusters (616)
/* ns6:ECLWorkunit-AllowedClusters */
class SOAP_CMAC _ns6__ECLWorkunit_AllowedClusters
{
public:
	std::vector<std::wstring * >AllowedCluster;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 616; } /* = unique id SOAP_TYPE__ns6__ECLWorkunit_AllowedClusters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__ECLWorkunit_AllowedClusters()  { this->soap_default(NULL); }
	virtual ~_ns6__ECLWorkunit_AllowedClusters() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLWorkunit
#define SOAP_TYPE_ns6__ECLWorkunit (267)
/* ns6:ECLWorkunit */
class SOAP_CMAC ns6__ECLWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *RoxieCluster;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	int *StateID;	/* optional element of type xsd:int */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StateEx;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	bool *Protected;	/* optional element of type xsd:boolean */
	bool *Active;	/* optional element of type xsd:boolean */
	int *Action;	/* optional element of type xsd:int */
	std::wstring *ActionEx;	/* optional element of type xsd:string */
	time_t *DateTimeScheduled;	/* optional element of type xsd:dateTime */
	int *PriorityClass;	/* optional element of type xsd:int */
	int *PriorityLevel;	/* optional element of type xsd:int */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	int *ResultLimit;	/* optional element of type xsd:int */
	bool *Archived;	/* optional element of type xsd:boolean */
	bool IsPausing;	/* optional element of type xsd:boolean */
	bool ThorLCR;	/* optional element of type xsd:boolean */
	int *EventSchedule;	/* optional element of type xsd:int */
	bool *HaveSubGraphTimings;	/* optional element of type xsd:boolean */
	std::wstring *TotalThorTime;	/* optional element of type xsd:string */
	class ns6__ECLQuery *Query;	/* optional element of type ns6:ECLQuery */
	class ns6__ArrayOfECLHelpFile *Helpers;	/* optional element of type ns6:ArrayOfECLHelpFile */
	ns6__ArrayOfECLException *Exceptions;	/* optional element of type ns6:ArrayOfECLException */
	class ns6__ArrayOfECLGraph *Graphs;	/* optional element of type ns6:ArrayOfECLGraph */
	class ns6__ArrayOfECLSourceFile *SourceFiles;	/* optional element of type ns6:ArrayOfECLSourceFile */
	class ns6__ArrayOfECLResult *Results;	/* optional element of type ns6:ArrayOfECLResult */
	ns6__ArrayOfECLResult *Variables;	/* optional element of type ns6:ArrayOfECLResult */
	class ns6__ArrayOfECLTimer *Timers;	/* optional element of type ns6:ArrayOfECLTimer */
	class ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	class ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	class ns6__ArrayOfECLWorkflow *Workflows;	/* optional element of type ns6:ArrayOfECLWorkflow */
	class ns6__ArrayOfECLTimingData *TimingData;	/* optional element of type ns6:ArrayOfECLTimingData */
	_ns6__ECLWorkunit_AllowedClusters *AllowedClusters;	/* optional element of type ns6:ECLWorkunit-AllowedClusters */
	int *ErrorCount;	/* optional element of type xsd:int */
	int *WarningCount;	/* optional element of type xsd:int */
	int *InfoCount;	/* optional element of type xsd:int */
	int *GraphCount;	/* optional element of type xsd:int */
	int *SourceFileCount;	/* optional element of type xsd:int */
	int *ResultCount;	/* optional element of type xsd:int */
	int *VariableCount;	/* optional element of type xsd:int */
	int *TimerCount;	/* optional element of type xsd:int */
	bool *HasDebugValue;	/* optional element of type xsd:boolean */
	int *ApplicationValueCount;	/* optional element of type xsd:int */
	std::wstring *XmlParams;	/* optional element of type xsd:string */
	int *AccessFlag;	/* optional element of type xsd:int */
	int *ClusterFlag;	/* optional element of type xsd:int */
	std::wstring *HelpersDesc;	/* optional element of type xsd:string */
	std::wstring *GraphsDesc;	/* optional element of type xsd:string */
	std::wstring *SourceFilesDesc;	/* optional element of type xsd:string */
	std::wstring *ResultsDesc;	/* optional element of type xsd:string */
	std::wstring *VariablesDesc;	/* optional element of type xsd:string */
	std::wstring *TimersDesc;	/* optional element of type xsd:string */
	std::wstring *DebugValuesDesc;	/* optional element of type xsd:string */
	std::wstring *ApplicationValuesDesc;	/* optional element of type xsd:string */
	std::wstring *WorkflowsDesc;	/* optional element of type xsd:string */
	bool HasArchiveQuery;	/* optional element of type xsd:boolean */
	class ns6__ArrayOfThorLogInfo *ThorLogList;	/* optional element of type ns6:ArrayOfThorLogInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 267; } /* = unique id SOAP_TYPE_ns6__ECLWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLWorkunit() : Wuid(NULL), Owner(NULL), Cluster(NULL), RoxieCluster(NULL), Jobname(NULL), Queue(NULL), StateID(NULL), State(NULL), StateEx(NULL), Description(NULL), Protected(NULL), Active(NULL), Action(NULL), ActionEx(NULL), DateTimeScheduled(NULL), PriorityClass(NULL), PriorityLevel(NULL), Scope(NULL), Snapshot(NULL), ResultLimit(NULL), Archived(NULL), IsPausing((bool)0), ThorLCR((bool)0), EventSchedule(NULL), HaveSubGraphTimings(NULL), TotalThorTime(NULL), Query(NULL), Helpers(NULL), Exceptions(NULL), Graphs(NULL), SourceFiles(NULL), Results(NULL), Variables(NULL), Timers(NULL), DebugValues(NULL), ApplicationValues(NULL), Workflows(NULL), TimingData(NULL), AllowedClusters(NULL), ErrorCount(NULL), WarningCount(NULL), InfoCount(NULL), GraphCount(NULL), SourceFileCount(NULL), ResultCount(NULL), VariableCount(NULL), TimerCount(NULL), HasDebugValue(NULL), ApplicationValueCount(NULL), XmlParams(NULL), AccessFlag(NULL), ClusterFlag(NULL), HelpersDesc(NULL), GraphsDesc(NULL), SourceFilesDesc(NULL), ResultsDesc(NULL), VariablesDesc(NULL), TimersDesc(NULL), DebugValuesDesc(NULL), ApplicationValuesDesc(NULL), WorkflowsDesc(NULL), HasArchiveQuery((bool)0), ThorLogList(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLQuery
#define SOAP_TYPE_ns6__ECLQuery (268)
/* ns6:ECLQuery */
class SOAP_CMAC ns6__ECLQuery
{
public:
	std::wstring *Text;	/* optional element of type xsd:string */
	std::wstring *Cpp;	/* optional element of type xsd:string */
	std::wstring *ResTxt;	/* optional element of type xsd:string */
	std::wstring *Dll;	/* optional element of type xsd:string */
	std::wstring *ThorLog;	/* optional element of type xsd:string */
	std::wstring *QueryMainDefinition;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 268; } /* = unique id SOAP_TYPE_ns6__ECLQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLQuery() : Text(NULL), Cpp(NULL), ResTxt(NULL), Dll(NULL), ThorLog(NULL), QueryMainDefinition(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLQuery() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLHelpFile
#define SOAP_TYPE_ns6__ECLHelpFile (269)
/* ns6:ECLHelpFile */
class SOAP_CMAC ns6__ECLHelpFile
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *IPAddress;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 269; } /* = unique id SOAP_TYPE_ns6__ECLHelpFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLHelpFile() : Name(NULL), Type(NULL), IPAddress(NULL), Description(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLHelpFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLGraph
#define SOAP_TYPE_ns6__ECLGraph (270)
/* ns6:ECLGraph */
class SOAP_CMAC ns6__ECLGraph
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Label;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	bool *Running;	/* optional element of type xsd:boolean */
	bool *Complete;	/* optional element of type xsd:boolean */
	bool *Failed;	/* optional element of type xsd:boolean */
	LONG64 *RunningId;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 270; } /* = unique id SOAP_TYPE_ns6__ECLGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLGraph() : Name(NULL), Label(NULL), Type(NULL), Running(NULL), Complete(NULL), Failed(NULL), RunningId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLGraph() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLSourceFile
#define SOAP_TYPE_ns6__ECLSourceFile (271)
/* ns6:ECLSourceFile */
class SOAP_CMAC ns6__ECLSourceFile
{
public:
	std::wstring *FileCluster;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	bool *IsSuperFile;	/* optional element of type xsd:boolean */
	int *Subs;	/* optional element of type xsd:int */
	int *Count;	/* optional element of type xsd:int */
	ns6__ArrayOfECLSourceFile *ECLSourceFiles;	/* optional element of type ns6:ArrayOfECLSourceFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 271; } /* = unique id SOAP_TYPE_ns6__ECLSourceFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLSourceFile() : FileCluster(NULL), Name(NULL), IsSuperFile(NULL), Subs(NULL), Count(NULL), ECLSourceFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLSourceFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLSourceFile
#define SOAP_TYPE_ns6__ArrayOfECLSourceFile (272)
/* ns6:ArrayOfECLSourceFile */
class SOAP_CMAC ns6__ArrayOfECLSourceFile
{
public:
	std::vector<ns6__ECLSourceFile * >ECLSourceFile;	/* optional element of type ns6:ECLSourceFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 272; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLSourceFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLSourceFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLSourceFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLResult
#define SOAP_TYPE_ns6__ECLResult (273)
/* ns6:ECLResult */
class SOAP_CMAC ns6__ECLResult
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *Value;	/* optional element of type xsd:string */
	std::wstring *Link;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	bool *IsSupplied;	/* optional element of type xsd:boolean */
	bool ShowFileContent;	/* optional element of type xsd:boolean */
	LONG64 *Total;	/* optional element of type xsd:long */
	class ns6__ArrayOfECLSchemaItem *ECLSchemas;	/* optional element of type ns6:ArrayOfECLSchemaItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 273; } /* = unique id SOAP_TYPE_ns6__ECLResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLResult() : Name(NULL), Sequence(NULL), Value(NULL), Link(NULL), FileName(NULL), IsSupplied(NULL), ShowFileContent((bool)0), Total(NULL), ECLSchemas(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLSchemaItem
#define SOAP_TYPE_ns6__ECLSchemaItem (274)
/* ns6:ECLSchemaItem */
class SOAP_CMAC ns6__ECLSchemaItem
{
public:
	std::wstring *ColumnName;	/* optional element of type xsd:string */
	std::wstring *ColumnType;	/* optional element of type xsd:string */
	int *ColumnTypeCode;	/* optional element of type xsd:int */
	bool isConditional;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 274; } /* = unique id SOAP_TYPE_ns6__ECLSchemaItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLSchemaItem() : ColumnName(NULL), ColumnType(NULL), ColumnTypeCode(NULL), isConditional((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLSchemaItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLSchemaItem
#define SOAP_TYPE_ns6__ArrayOfECLSchemaItem (275)
/* ns6:ArrayOfECLSchemaItem */
class SOAP_CMAC ns6__ArrayOfECLSchemaItem
{
public:
	std::vector<ns6__ECLSchemaItem * >ECLSchemaItem;	/* optional element of type ns6:ECLSchemaItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 275; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLSchemaItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLSchemaItem() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLSchemaItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLTimer
#define SOAP_TYPE_ns6__ECLTimer (276)
/* ns6:ECLTimer */
class SOAP_CMAC ns6__ECLTimer
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	int *count;	/* optional element of type xsd:int */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	int *SubGraphId;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 276; } /* = unique id SOAP_TYPE_ns6__ECLTimer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLTimer() : Name(NULL), Value(NULL), count(NULL), GraphName(NULL), SubGraphId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLTimer() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DebugValue
#define SOAP_TYPE_ns6__DebugValue (277)
/* ns6:DebugValue */
class SOAP_CMAC ns6__DebugValue
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 277; } /* = unique id SOAP_TYPE_ns6__DebugValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DebugValue() : Name(NULL), Value(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__DebugValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ApplicationValue
#define SOAP_TYPE_ns6__ApplicationValue (278)
/* ns6:ApplicationValue */
class SOAP_CMAC ns6__ApplicationValue
{
public:
	std::wstring *Application;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 278; } /* = unique id SOAP_TYPE_ns6__ApplicationValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ApplicationValue() : Application(NULL), Name(NULL), Value(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ApplicationValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLWorkflow
#define SOAP_TYPE_ns6__ECLWorkflow (279)
/* ns6:ECLWorkflow */
class SOAP_CMAC ns6__ECLWorkflow
{
public:
	std::wstring *WFID;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *EventText;	/* optional element of type xsd:string */
	int Count;	/* optional element of type xsd:int */
	int CountRemaining;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 279; } /* = unique id SOAP_TYPE_ns6__ECLWorkflow */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLWorkflow() : WFID(NULL), EventName(NULL), EventText(NULL), Count(0), CountRemaining(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLWorkflow() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLTimingData
#define SOAP_TYPE_ns6__ECLTimingData (280)
/* ns6:ECLTimingData */
class SOAP_CMAC ns6__ECLTimingData
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	int *GraphNum;	/* optional element of type xsd:int */
	int *SubGraphNum;	/* optional element of type xsd:int */
	int *GID;	/* optional element of type xsd:int */
	int *Min;	/* optional element of type xsd:int */
	int *MS;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 280; } /* = unique id SOAP_TYPE_ns6__ECLTimingData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLTimingData() : Name(NULL), GraphNum(NULL), SubGraphNum(NULL), GID(NULL), Min(NULL), MS(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLTimingData() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ThorLogInfo
#define SOAP_TYPE_ns6__ThorLogInfo (281)
/* ns6:ThorLogInfo */
class SOAP_CMAC ns6__ThorLogInfo
{
public:
	std::wstring *ProcessName;	/* optional element of type xsd:string */
	std::wstring *ClusterGroup;	/* optional element of type xsd:string */
	std::wstring *LogDate;	/* optional element of type xsd:string */
	int *NumberSlaves;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 281; } /* = unique id SOAP_TYPE_ns6__ThorLogInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ThorLogInfo() : ProcessName(NULL), ClusterGroup(NULL), LogDate(NULL), NumberSlaves(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ThorLogInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfApplicationValue
#define SOAP_TYPE_ns6__ArrayOfApplicationValue (282)
/* ns6:ArrayOfApplicationValue */
class SOAP_CMAC ns6__ArrayOfApplicationValue
{
public:
	std::vector<ns6__ApplicationValue * >ApplicationValue;	/* optional element of type ns6:ApplicationValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 282; } /* = unique id SOAP_TYPE_ns6__ArrayOfApplicationValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfApplicationValue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfApplicationValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfDebugValue
#define SOAP_TYPE_ns6__ArrayOfDebugValue (283)
/* ns6:ArrayOfDebugValue */
class SOAP_CMAC ns6__ArrayOfDebugValue
{
public:
	std::vector<ns6__DebugValue * >DebugValue;	/* optional element of type ns6:DebugValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 283; } /* = unique id SOAP_TYPE_ns6__ArrayOfDebugValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfDebugValue() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfDebugValue() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLGraph
#define SOAP_TYPE_ns6__ArrayOfECLGraph (284)
/* ns6:ArrayOfECLGraph */
class SOAP_CMAC ns6__ArrayOfECLGraph
{
public:
	std::vector<ns6__ECLGraph * >ECLGraph;	/* optional element of type ns6:ECLGraph */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 284; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLGraph() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLGraph() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLHelpFile
#define SOAP_TYPE_ns6__ArrayOfECLHelpFile (285)
/* ns6:ArrayOfECLHelpFile */
class SOAP_CMAC ns6__ArrayOfECLHelpFile
{
public:
	std::vector<ns6__ECLHelpFile * >ECLHelpFile;	/* optional element of type ns6:ECLHelpFile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 285; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLHelpFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLHelpFile() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLHelpFile() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLResult
#define SOAP_TYPE_ns6__ArrayOfECLResult (286)
/* ns6:ArrayOfECLResult */
class SOAP_CMAC ns6__ArrayOfECLResult
{
public:
	std::vector<ns6__ECLResult * >ECLResult;	/* optional element of type ns6:ECLResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 286; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLResult() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLTimer
#define SOAP_TYPE_ns6__ArrayOfECLTimer (287)
/* ns6:ArrayOfECLTimer */
class SOAP_CMAC ns6__ArrayOfECLTimer
{
public:
	std::vector<ns6__ECLTimer * >ECLTimer;	/* optional element of type ns6:ECLTimer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 287; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLTimer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLTimer() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLTimer() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLTimingData
#define SOAP_TYPE_ns6__ArrayOfECLTimingData (288)
/* ns6:ArrayOfECLTimingData */
class SOAP_CMAC ns6__ArrayOfECLTimingData
{
public:
	std::vector<ns6__ECLTimingData * >ECLTimingData;	/* optional element of type ns6:ECLTimingData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 288; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLTimingData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLTimingData() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLTimingData() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLWorkflow
#define SOAP_TYPE_ns6__ArrayOfECLWorkflow (289)
/* ns6:ArrayOfECLWorkflow */
class SOAP_CMAC ns6__ArrayOfECLWorkflow
{
public:
	std::vector<ns6__ECLWorkflow * >ECLWorkflow;	/* optional element of type ns6:ECLWorkflow */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 289; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLWorkflow */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLWorkflow() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLWorkflow() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfThorLogInfo
#define SOAP_TYPE_ns6__ArrayOfThorLogInfo (290)
/* ns6:ArrayOfThorLogInfo */
class SOAP_CMAC ns6__ArrayOfThorLogInfo
{
public:
	std::vector<ns6__ThorLogInfo * >ThorLogInfo;	/* optional element of type ns6:ThorLogInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 290; } /* = unique id SOAP_TYPE_ns6__ArrayOfThorLogInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfThorLogInfo() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfThorLogInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLGraphEx
#define SOAP_TYPE_ns6__ECLGraphEx (291)
/* ns6:ECLGraphEx */
class SOAP_CMAC ns6__ECLGraphEx
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Label;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Graph;	/* optional element of type xsd:string */
	bool *Running;	/* optional element of type xsd:boolean */
	LONG64 *RunningId;	/* optional element of type xsd:long */
	bool *Complete;	/* optional element of type xsd:boolean */
	bool *Failed;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 291; } /* = unique id SOAP_TYPE_ns6__ECLGraphEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLGraphEx() : Name(NULL), Label(NULL), Type(NULL), Graph(NULL), Running(NULL), RunningId(NULL), Complete(NULL), Failed(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLGraphEx() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLGraphEx
#define SOAP_TYPE_ns6__ArrayOfECLGraphEx (292)
/* ns6:ArrayOfECLGraphEx */
class SOAP_CMAC ns6__ArrayOfECLGraphEx
{
public:
	std::vector<ns6__ECLGraphEx * >ECLGraphEx;	/* optional element of type ns6:ECLGraphEx */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 292; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLGraphEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLGraphEx() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLGraphEx() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ECLJob
#define SOAP_TYPE_ns6__ECLJob (293)
/* ns6:ECLJob */
class SOAP_CMAC ns6__ECLJob
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Graph;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartedDate;	/* optional element of type xsd:string */
	std::wstring *FinishedDate;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *GraphNum;	/* optional element of type xsd:string */
	std::wstring *SubGraphNum;	/* optional element of type xsd:string */
	std::wstring *NumOfRuns;	/* optional element of type xsd:string */
	int *Duration;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 293; } /* = unique id SOAP_TYPE_ns6__ECLJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ECLJob() : Wuid(NULL), Graph(NULL), State(NULL), StartedDate(NULL), FinishedDate(NULL), Cluster(NULL), GraphNum(NULL), SubGraphNum(NULL), NumOfRuns(NULL), Duration(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ECLJob() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLJob
#define SOAP_TYPE_ns6__ArrayOfECLJob (294)
/* ns6:ArrayOfECLJob */
class SOAP_CMAC ns6__ArrayOfECLJob
{
public:
	std::vector<ns6__ECLJob * >ECLJob;	/* optional element of type ns6:ECLJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 294; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLJob() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLJob() { }
};
#endif

#ifndef SOAP_TYPE_ns6__LogicalFileUpload
#define SOAP_TYPE_ns6__LogicalFileUpload (295)
/* ns6:LogicalFileUpload */
class SOAP_CMAC ns6__LogicalFileUpload
{
public:
	int *Type;	/* optional element of type xsd:int */
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Destination;	/* optional element of type xsd:string */
	std::wstring *EventTag;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 295; } /* = unique id SOAP_TYPE_ns6__LogicalFileUpload */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__LogicalFileUpload() : Type(NULL), Source(NULL), Destination(NULL), EventTag(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__LogicalFileUpload() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfLogicalFileUpload
#define SOAP_TYPE_ns6__ArrayOfLogicalFileUpload (296)
/* ns6:ArrayOfLogicalFileUpload */
class SOAP_CMAC ns6__ArrayOfLogicalFileUpload
{
public:
	std::vector<ns6__LogicalFileUpload * >LogicalFileUpload;	/* optional element of type ns6:LogicalFileUpload */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 296; } /* = unique id SOAP_TYPE_ns6__ArrayOfLogicalFileUpload */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfLogicalFileUpload() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfLogicalFileUpload() { }
};
#endif

#ifndef SOAP_TYPE_ns6__WUQuerySetDetail
#define SOAP_TYPE_ns6__WUQuerySetDetail (297)
/* ns6:WUQuerySetDetail */
class SOAP_CMAC ns6__WUQuerySetDetail
{
public:
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	class ns6__ArrayOfQuerySetQuery *Queries;	/* optional element of type ns6:ArrayOfQuerySetQuery */
	class ns6__ArrayOfQuerySetAlias *Aliases;	/* optional element of type ns6:ArrayOfQuerySetAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 297; } /* = unique id SOAP_TYPE_ns6__WUQuerySetDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__WUQuerySetDetail() : QuerySetName(NULL), Queries(NULL), Aliases(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__WUQuerySetDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQuery
#define SOAP_TYPE_ns6__QuerySetQuery (298)
/* ns6:QuerySetQuery */
class SOAP_CMAC ns6__QuerySetQuery
{
public:
	std::wstring *Id;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Dll;	/* optional element of type xsd:string */
	bool *Suspended;	/* optional element of type xsd:boolean */
	class ns6__ArrayOfClusterQueryState *Clusters;	/* optional element of type ns6:ArrayOfClusterQueryState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 298; } /* = unique id SOAP_TYPE_ns6__QuerySetQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQuery() : Id(NULL), Name(NULL), Wuid(NULL), Dll(NULL), Suspended(NULL), Clusters(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQuery() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ClusterQueryState
#define SOAP_TYPE_ns6__ClusterQueryState (299)
/* ns6:ClusterQueryState */
class SOAP_CMAC ns6__ClusterQueryState
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 299; } /* = unique id SOAP_TYPE_ns6__ClusterQueryState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ClusterQueryState() : Cluster(NULL), State(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ClusterQueryState() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfClusterQueryState
#define SOAP_TYPE_ns6__ArrayOfClusterQueryState (300)
/* ns6:ArrayOfClusterQueryState */
class SOAP_CMAC ns6__ArrayOfClusterQueryState
{
public:
	std::vector<ns6__ClusterQueryState * >ClusterQueryState;	/* optional element of type ns6:ClusterQueryState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 300; } /* = unique id SOAP_TYPE_ns6__ArrayOfClusterQueryState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfClusterQueryState() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfClusterQueryState() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAlias
#define SOAP_TYPE_ns6__QuerySetAlias (301)
/* ns6:QuerySetAlias */
class SOAP_CMAC ns6__QuerySetAlias
{
public:
	std::wstring *Id;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 301; } /* = unique id SOAP_TYPE_ns6__QuerySetAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetAlias() : Id(NULL), Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetAlias() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfQuerySetAlias
#define SOAP_TYPE_ns6__ArrayOfQuerySetAlias (302)
/* ns6:ArrayOfQuerySetAlias */
class SOAP_CMAC ns6__ArrayOfQuerySetAlias
{
public:
	std::vector<ns6__QuerySetAlias * >QuerySetAlias;	/* optional element of type ns6:QuerySetAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 302; } /* = unique id SOAP_TYPE_ns6__ArrayOfQuerySetAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfQuerySetAlias() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfQuerySetAlias() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfQuerySetQuery
#define SOAP_TYPE_ns6__ArrayOfQuerySetQuery (303)
/* ns6:ArrayOfQuerySetQuery */
class SOAP_CMAC ns6__ArrayOfQuerySetQuery
{
public:
	std::vector<ns6__QuerySetQuery * >QuerySetQuery;	/* optional element of type ns6:QuerySetQuery */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 303; } /* = unique id SOAP_TYPE_ns6__ArrayOfQuerySetQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfQuerySetQuery() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfQuerySetQuery() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfWUQuerySetDetail
#define SOAP_TYPE_ns6__ArrayOfWUQuerySetDetail (304)
/* ns6:ArrayOfWUQuerySetDetail */
class SOAP_CMAC ns6__ArrayOfWUQuerySetDetail
{
public:
	std::vector<ns6__WUQuerySetDetail * >WUQuerySetDetail;	/* optional element of type ns6:WUQuerySetDetail */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 304; } /* = unique id SOAP_TYPE_ns6__ArrayOfWUQuerySetDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfWUQuerySetDetail() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfWUQuerySetDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfECLWorkunit
#define SOAP_TYPE_ns6__ArrayOfECLWorkunit (305)
/* ns6:ArrayOfECLWorkunit */
class SOAP_CMAC ns6__ArrayOfECLWorkunit
{
public:
	std::vector<ns6__ECLWorkunit * >ECLWorkunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 305; } /* = unique id SOAP_TYPE_ns6__ArrayOfECLWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfECLWorkunit() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfECLWorkunit() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAliasActionItem
#define SOAP_TYPE_ns6__QuerySetAliasActionItem (306)
/* ns6:QuerySetAliasActionItem */
class SOAP_CMAC ns6__QuerySetAliasActionItem
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 306; } /* = unique id SOAP_TYPE_ns6__QuerySetAliasActionItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetAliasActionItem() : Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetAliasActionItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetAliasActionResult
#define SOAP_TYPE_ns6__QuerySetAliasActionResult (307)
/* ns6:QuerySetAliasActionResult */
class SOAP_CMAC ns6__QuerySetAliasActionResult
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	bool *Success;	/* optional element of type xsd:boolean */
	int *Code;	/* optional element of type xsd:int */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 307; } /* = unique id SOAP_TYPE_ns6__QuerySetAliasActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetAliasActionResult() : Name(NULL), Success(NULL), Code(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetAliasActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryActionItem
#define SOAP_TYPE_ns6__QuerySetQueryActionItem (308)
/* ns6:QuerySetQueryActionItem */
class SOAP_CMAC ns6__QuerySetQueryActionItem
{
public:
	std::wstring *QueryId;	/* optional element of type xsd:string */
	class ns6__QuerySetQueryClientState *ClientState;	/* optional element of type ns6:QuerySetQueryClientState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 308; } /* = unique id SOAP_TYPE_ns6__QuerySetQueryActionItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQueryActionItem() : QueryId(NULL), ClientState(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQueryActionItem() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryClientState
#define SOAP_TYPE_ns6__QuerySetQueryClientState (309)
/* ns6:QuerySetQueryClientState */
class SOAP_CMAC ns6__QuerySetQueryClientState
{
public:
	bool *Suspended;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 309; } /* = unique id SOAP_TYPE_ns6__QuerySetQueryClientState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQueryClientState() : Suspended(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQueryClientState() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySetQueryActionResult
#define SOAP_TYPE_ns6__QuerySetQueryActionResult (310)
/* ns6:QuerySetQueryActionResult */
class SOAP_CMAC ns6__QuerySetQueryActionResult
{
public:
	std::wstring *QueryId;	/* optional element of type xsd:string */
	bool *Suspended;	/* optional element of type xsd:boolean */
	bool *Success;	/* optional element of type xsd:boolean */
	int *Code;	/* optional element of type xsd:int */
	std::wstring *Message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 310; } /* = unique id SOAP_TYPE_ns6__QuerySetQueryActionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySetQueryActionResult() : QueryId(NULL), Suspended(NULL), Success(NULL), Code(NULL), Message(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySetQueryActionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QuerySet
#define SOAP_TYPE_ns6__QuerySet (311)
/* ns6:QuerySet */
class SOAP_CMAC ns6__QuerySet
{
public:
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 311; } /* = unique id SOAP_TYPE_ns6__QuerySet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QuerySet() : QuerySetName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__QuerySet() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfQuerySet
#define SOAP_TYPE_ns6__ArrayOfQuerySet (312)
/* ns6:ArrayOfQuerySet */
class SOAP_CMAC ns6__ArrayOfQuerySet
{
public:
	std::vector<ns6__QuerySet * >QuerySet;	/* optional element of type ns6:QuerySet */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 312; } /* = unique id SOAP_TYPE_ns6__ArrayOfQuerySet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfQuerySet() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfQuerySet() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ServerInfo
#define SOAP_TYPE_ns6__ServerInfo (313)
/* ns6:ServerInfo */
class SOAP_CMAC ns6__ServerInfo
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *NetAddress;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 313; } /* = unique id SOAP_TYPE_ns6__ServerInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ServerInfo() : Name(NULL), NetAddress(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ServerInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ScheduledWU
#define SOAP_TYPE_ns6__ScheduledWU (314)
/* ns6:ScheduledWU */
class SOAP_CMAC ns6__ScheduledWU
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *EventText;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 314; } /* = unique id SOAP_TYPE_ns6__ScheduledWU */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ScheduledWU() : Wuid(NULL), Cluster(NULL), EventName(NULL), EventText(NULL), JobName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ScheduledWU() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfScheduledWU
#define SOAP_TYPE_ns6__ArrayOfScheduledWU (315)
/* ns6:ArrayOfScheduledWU */
class SOAP_CMAC ns6__ArrayOfScheduledWU
{
public:
	std::vector<ns6__ScheduledWU * >ScheduledWU;	/* optional element of type ns6:ScheduledWU */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 315; } /* = unique id SOAP_TYPE_ns6__ArrayOfScheduledWU */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfScheduledWU() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfScheduledWU() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ArrayOfServerInfo
#define SOAP_TYPE_ns6__ArrayOfServerInfo (316)
/* ns6:ArrayOfServerInfo */
class SOAP_CMAC ns6__ArrayOfServerInfo
{
public:
	std::vector<ns6__ServerInfo * >ServerInfo;	/* optional element of type ns6:ServerInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 316; } /* = unique id SOAP_TYPE_ns6__ArrayOfServerInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ArrayOfServerInfo() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns6__ArrayOfServerInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__GVCAjaxGraph
#define SOAP_TYPE__ns6__GVCAjaxGraph (317)
/* ns6:GVCAjaxGraph */
class SOAP_CMAC _ns6__GVCAjaxGraph
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	int *SubGraphId;	/* optional element of type xsd:int */
	bool *SubGraphOnly;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 317; } /* = unique id SOAP_TYPE__ns6__GVCAjaxGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__GVCAjaxGraph() : Name(NULL), GraphName(NULL), SubGraphId(NULL), SubGraphOnly(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__GVCAjaxGraph() { }
};
#endif

#ifndef SOAP_TYPE__ns6__GVCAjaxGraphResponse
#define SOAP_TYPE__ns6__GVCAjaxGraphResponse (318)
/* ns6:GVCAjaxGraphResponse */
class SOAP_CMAC _ns6__GVCAjaxGraphResponse
{
public:
	std::wstring *Name;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	std::wstring *GraphType;	/* optional element of type xsd:string */
	int *SubGraphId;	/* optional element of type xsd:int */
	bool *SubGraphOnly;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 318; } /* = unique id SOAP_TYPE__ns6__GVCAjaxGraphResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__GVCAjaxGraphResponse() : Name(NULL), GraphName(NULL), GraphType(NULL), SubGraphId(NULL), SubGraphOnly(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__GVCAjaxGraphResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAbort
#define SOAP_TYPE__ns6__WUAbort (319)
/* ns6:WUAbort */
class SOAP_CMAC _ns6__WUAbort
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 319; } /* = unique id SOAP_TYPE__ns6__WUAbort */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAbort() : Wuids(NULL), BlockTillFinishTimer(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAbort() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAbortResponse
#define SOAP_TYPE__ns6__WUAbortResponse (320)
/* ns6:WUAbortResponse */
class SOAP_CMAC _ns6__WUAbortResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 320; } /* = unique id SOAP_TYPE__ns6__WUAbortResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAbortResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAbortResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAction
#define SOAP_TYPE__ns6__WUAction (321)
/* ns6:WUAction */
class SOAP_CMAC _ns6__WUAction
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	std::wstring *ActionType;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *Test;	/* optional element of type xsd:string */
	std::wstring *CurrentPage;	/* optional element of type xsd:string */
	std::wstring *PageSize;	/* optional element of type xsd:string */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	std::wstring *EventServer;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *PageFrom;	/* optional element of type xsd:string */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 321; } /* = unique id SOAP_TYPE__ns6__WUAction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAction() : Wuids(NULL), ActionType(NULL), Cluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), ECL(NULL), Jobname(NULL), Test(NULL), CurrentPage(NULL), PageSize(NULL), Sortby(NULL), Descending((bool)0), EventServer(NULL), EventName(NULL), PageFrom(NULL), BlockTillFinishTimer(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAction() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUActionResponse
#define SOAP_TYPE__ns6__WUActionResponse (322)
/* ns6:WUActionResponse */
class SOAP_CMAC _ns6__WUActionResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 322; } /* = unique id SOAP_TYPE__ns6__WUActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUActionResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAddLocalFileToWorkunit
#define SOAP_TYPE__ns6__WUAddLocalFileToWorkunit (323)
/* ns6:WUAddLocalFileToWorkunit */
class SOAP_CMAC _ns6__WUAddLocalFileToWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Val;	/* optional element of type xsd:string */
	std::wstring *DefVal;	/* optional element of type xsd:string */
	int *Type;	/* optional element of type xsd:int */
	int *Length;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 323; } /* = unique id SOAP_TYPE__ns6__WUAddLocalFileToWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAddLocalFileToWorkunit() : Wuid(NULL), Name(NULL), Val(NULL), DefVal(NULL), Type(NULL), Length(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAddLocalFileToWorkunit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUAddLocalFileToWorkunitResponse
#define SOAP_TYPE__ns6__WUAddLocalFileToWorkunitResponse (324)
/* ns6:WUAddLocalFileToWorkunitResponse */
class SOAP_CMAC _ns6__WUAddLocalFileToWorkunitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 324; } /* = unique id SOAP_TYPE__ns6__WUAddLocalFileToWorkunitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUAddLocalFileToWorkunitResponse() : Exceptions(NULL), Wuid(NULL), Name(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUAddLocalFileToWorkunitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCDebug
#define SOAP_TYPE__ns6__WUCDebug (325)
/* ns6:WUCDebug */
class SOAP_CMAC _ns6__WUCDebug
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Command;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 325; } /* = unique id SOAP_TYPE__ns6__WUCDebug */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCDebug() : Wuid(NULL), Command(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCDebug() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDebugResponse
#define SOAP_TYPE__ns6__WUDebugResponse (326)
/* ns6:WUDebugResponse */
class SOAP_CMAC _ns6__WUDebugResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 326; } /* = unique id SOAP_TYPE__ns6__WUDebugResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDebugResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDebugResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueLOG
#define SOAP_TYPE__ns6__WUClusterJobQueueLOG (327)
/* ns6:WUClusterJobQueueLOG */
class SOAP_CMAC _ns6__WUClusterJobQueueLOG
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 327; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueLOG */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueLOG() : Cluster(NULL), StartDate(NULL), EndDate(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueLOG() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueLOGResponse
#define SOAP_TYPE__ns6__WUClusterJobQueueLOGResponse (328)
/* ns6:WUClusterJobQueueLOGResponse */
class SOAP_CMAC _ns6__WUClusterJobQueueLOGResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 328; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueLOGResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueLOGResponse() : Exceptions(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueLOGResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueXLS
#define SOAP_TYPE__ns6__WUClusterJobQueueXLS (329)
/* ns6:WUClusterJobQueueXLS */
class SOAP_CMAC _ns6__WUClusterJobQueueXLS
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ShowType;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 329; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueXLS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueXLS() : Cluster(NULL), StartDate(NULL), EndDate(NULL), ShowType(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueXLS() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobQueueXLSResponse
#define SOAP_TYPE__ns6__WUClusterJobQueueXLSResponse (330)
/* ns6:WUClusterJobQueueXLSResponse */
class SOAP_CMAC _ns6__WUClusterJobQueueXLSResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 330; } /* = unique id SOAP_TYPE__ns6__WUClusterJobQueueXLSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobQueueXLSResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobQueueXLSResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobSummaryXLS
#define SOAP_TYPE__ns6__WUClusterJobSummaryXLS (331)
/* ns6:WUClusterJobSummaryXLS */
class SOAP_CMAC _ns6__WUClusterJobSummaryXLS
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	bool *ShowAll;	/* optional element of type xsd:boolean */
	std::wstring *BusinessStartTime;	/* optional element of type xsd:string */
	std::wstring *BusinessEndTime;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 331; } /* = unique id SOAP_TYPE__ns6__WUClusterJobSummaryXLS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobSummaryXLS() : Cluster(NULL), StartDate(NULL), EndDate(NULL), ShowAll(NULL), BusinessStartTime(NULL), BusinessEndTime(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobSummaryXLS() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobSummaryXLSResponse
#define SOAP_TYPE__ns6__WUClusterJobSummaryXLSResponse (332)
/* ns6:WUClusterJobSummaryXLSResponse */
class SOAP_CMAC _ns6__WUClusterJobSummaryXLSResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 332; } /* = unique id SOAP_TYPE__ns6__WUClusterJobSummaryXLSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobSummaryXLSResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobSummaryXLSResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobXLS
#define SOAP_TYPE__ns6__WUClusterJobXLS (333)
/* ns6:WUClusterJobXLS */
class SOAP_CMAC _ns6__WUClusterJobXLS
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	bool *ShowAll;	/* optional element of type xsd:boolean */
	std::wstring *BusinessStartTime;	/* optional element of type xsd:string */
	std::wstring *BusinessEndTime;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 333; } /* = unique id SOAP_TYPE__ns6__WUClusterJobXLS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobXLS() : Cluster(NULL), StartDate(NULL), EndDate(NULL), ShowAll(NULL), BusinessStartTime(NULL), BusinessEndTime(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobXLS() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUClusterJobXLSResponse
#define SOAP_TYPE__ns6__WUClusterJobXLSResponse (334)
/* ns6:WUClusterJobXLSResponse */
class SOAP_CMAC _ns6__WUClusterJobXLSResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 334; } /* = unique id SOAP_TYPE__ns6__WUClusterJobXLSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUClusterJobXLSResponse() : Exceptions(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUClusterJobXLSResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCompileECL
#define SOAP_TYPE__ns6__WUCompileECL (335)
/* ns6:WUCompileECL */
class SOAP_CMAC _ns6__WUCompileECL
{
public:
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	bool IncludeDependencies;	/* optional element of type xsd:boolean */
	bool *IncludeComplexity;	/* optional element of type xsd:boolean */
	int TimeToWait;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 335; } /* = unique id SOAP_TYPE__ns6__WUCompileECL */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCompileECL() : ECL(NULL), ModuleName(NULL), AttributeName(NULL), Queue(NULL), Cluster(NULL), Snapshot(NULL), IncludeDependencies((bool)0), IncludeComplexity(NULL), TimeToWait(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCompileECL() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCompileECLResponse_Dependencies
#define SOAP_TYPE__ns6__WUCompileECLResponse_Dependencies (670)
/* ns6:WUCompileECLResponse-Dependencies */
class SOAP_CMAC _ns6__WUCompileECLResponse_Dependencies
{
public:
	std::vector<ns6__WUECLAttribute * >ECLAttribute;	/* optional element of type ns6:WUECLAttribute */
public:
	virtual int soap_type() const { return 670; } /* = unique id SOAP_TYPE__ns6__WUCompileECLResponse_Dependencies */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCompileECLResponse_Dependencies()  { this->soap_default(NULL); }
	virtual ~_ns6__WUCompileECLResponse_Dependencies() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCompileECLResponse
#define SOAP_TYPE__ns6__WUCompileECLResponse (336)
/* ns6:WUCompileECLResponse */
class SOAP_CMAC _ns6__WUCompileECLResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Complexity;	/* optional element of type xsd:string */
	ns6__ArrayOfECLException *Errors;	/* optional element of type ns6:ArrayOfECLException */
	_ns6__WUCompileECLResponse_Dependencies *Dependencies;	/* optional element of type ns6:WUCompileECLResponse-Dependencies */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 336; } /* = unique id SOAP_TYPE__ns6__WUCompileECLResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCompileECLResponse() : Exceptions(NULL), Complexity(NULL), Errors(NULL), Dependencies(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCompileECLResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyLogicalFiles
#define SOAP_TYPE__ns6__WUCopyLogicalFiles (337)
/* ns6:WUCopyLogicalFiles */
class SOAP_CMAC _ns6__WUCopyLogicalFiles
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	bool *CopyLocal;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 337; } /* = unique id SOAP_TYPE__ns6__WUCopyLogicalFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyLogicalFiles() : Wuid(NULL), Cluster(NULL), CopyLocal(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyLogicalFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyLogicalFilesResponse_ClusterFiles
#define SOAP_TYPE__ns6__WUCopyLogicalFilesResponse_ClusterFiles (674)
/* ns6:WUCopyLogicalFilesResponse-ClusterFiles */
class SOAP_CMAC _ns6__WUCopyLogicalFilesResponse_ClusterFiles
{
public:
	std::vector<ns6__WUCopyLogicalClusterFileSections * >Cluster;	/* optional element of type ns6:WUCopyLogicalClusterFileSections */
public:
	virtual int soap_type() const { return 674; } /* = unique id SOAP_TYPE__ns6__WUCopyLogicalFilesResponse_ClusterFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyLogicalFilesResponse_ClusterFiles()  { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyLogicalFilesResponse_ClusterFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCopyLogicalFilesResponse
#define SOAP_TYPE__ns6__WUCopyLogicalFilesResponse (338)
/* ns6:WUCopyLogicalFilesResponse */
class SOAP_CMAC _ns6__WUCopyLogicalFilesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	_ns6__WUCopyLogicalFilesResponse_ClusterFiles *ClusterFiles;	/* optional element of type ns6:WUCopyLogicalFilesResponse-ClusterFiles */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 338; } /* = unique id SOAP_TYPE__ns6__WUCopyLogicalFilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCopyLogicalFilesResponse() : Exceptions(NULL), Wuid(NULL), ClusterFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCopyLogicalFilesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreate
#define SOAP_TYPE__ns6__WUCreate (339)
/* ns6:WUCreate */
class SOAP_CMAC _ns6__WUCreate
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 339; } /* = unique id SOAP_TYPE__ns6__WUCreate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreate() : soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreate() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreateResponse
#define SOAP_TYPE__ns6__WUCreateResponse (340)
/* ns6:WUCreateResponse */
class SOAP_CMAC _ns6__WUCreateResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 340; } /* = unique id SOAP_TYPE__ns6__WUCreateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreateResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUCreateAndUpdate
#define SOAP_TYPE__ns6__WUCreateAndUpdate (341)
/* ns6:WUCreateAndUpdate */
class SOAP_CMAC _ns6__WUCreateAndUpdate
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *State;	/* optional element of type xsd:int */
	int *StateOrig;	/* optional element of type xsd:int */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *JobnameOrig;	/* optional element of type xsd:string */
	std::wstring *QueryText;	/* optional element of type xsd:string */
	int *Action;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *DescriptionOrig;	/* optional element of type xsd:string */
	bool *AddDrilldownFields;	/* optional element of type xsd:boolean */
	int *ResultLimit;	/* optional element of type xsd:int */
	bool *Protected;	/* optional element of type xsd:boolean */
	bool *ProtectedOrig;	/* optional element of type xsd:boolean */
	int *PriorityClass;	/* optional element of type xsd:int */
	int *PriorityLevel;	/* optional element of type xsd:int */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *ScopeOrig;	/* optional element of type xsd:string */
	std::wstring *ClusterSelection;	/* optional element of type xsd:string */
	std::wstring *ClusterOrig;	/* optional element of type xsd:string */
	std::wstring *XmlParams;	/* optional element of type xsd:string */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	std::wstring *QueryMainDefinition;	/* optional element of type xsd:string */
	ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 341; } /* = unique id SOAP_TYPE__ns6__WUCreateAndUpdate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUCreateAndUpdate() : Wuid(NULL), State(NULL), StateOrig(NULL), Jobname(NULL), JobnameOrig(NULL), QueryText(NULL), Action(NULL), Description(NULL), DescriptionOrig(NULL), AddDrilldownFields(NULL), ResultLimit(NULL), Protected(NULL), ProtectedOrig(NULL), PriorityClass(NULL), PriorityLevel(NULL), Scope(NULL), ScopeOrig(NULL), ClusterSelection(NULL), ClusterOrig(NULL), XmlParams(NULL), ThorSlaveIP(NULL), QueryMainDefinition(NULL), DebugValues(NULL), ApplicationValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUCreateAndUpdate() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUUpdateResponse
#define SOAP_TYPE__ns6__WUUpdateResponse (342)
/* ns6:WUUpdateResponse */
class SOAP_CMAC _ns6__WUUpdateResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 342; } /* = unique id SOAP_TYPE__ns6__WUUpdateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUUpdateResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUUpdateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDelete
#define SOAP_TYPE__ns6__WUDelete (343)
/* ns6:WUDelete */
class SOAP_CMAC _ns6__WUDelete
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 343; } /* = unique id SOAP_TYPE__ns6__WUDelete */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDelete() : Wuids(NULL), BlockTillFinishTimer(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDelete() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDeleteResponse
#define SOAP_TYPE__ns6__WUDeleteResponse (344)
/* ns6:WUDeleteResponse */
class SOAP_CMAC _ns6__WUDeleteResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 344; } /* = unique id SOAP_TYPE__ns6__WUDeleteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDeleteResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDeleteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDeployWorkunit
#define SOAP_TYPE__ns6__WUDeployWorkunit (345)
/* ns6:WUDeployWorkunit */
class SOAP_CMAC _ns6__WUDeployWorkunit
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	std::wstring *ObjType;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	xsd__base64Binary *Object;	/* optional element of type xsd:base64Binary */
	int *ResultLimit;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 345; } /* = unique id SOAP_TYPE__ns6__WUDeployWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDeployWorkunit() : Cluster(NULL), Name(NULL), Wait(0), ObjType(NULL), FileName(NULL), Object(NULL), ResultLimit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDeployWorkunit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUDeployWorkunitResponse
#define SOAP_TYPE__ns6__WUDeployWorkunitResponse (346)
/* ns6:WUDeployWorkunitResponse */
class SOAP_CMAC _ns6__WUDeployWorkunitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 346; } /* = unique id SOAP_TYPE__ns6__WUDeployWorkunitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUDeployWorkunitResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUDeployWorkunitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUExport
#define SOAP_TYPE__ns6__WUExport (347)
/* ns6:WUExport */
class SOAP_CMAC _ns6__WUExport
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 347; } /* = unique id SOAP_TYPE__ns6__WUExport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUExport() : Cluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), ECL(NULL), Jobname(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUExport() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUExportResponse
#define SOAP_TYPE__ns6__WUExportResponse (348)
/* ns6:WUExportResponse */
class SOAP_CMAC _ns6__WUExportResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	xsd__base64Binary *ExportData;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 348; } /* = unique id SOAP_TYPE__ns6__WUExportResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUExportResponse() : Exceptions(NULL), ExportData(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUExportResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUFile
#define SOAP_TYPE__ns6__WUFile (349)
/* ns6:WUFile */
class SOAP_CMAC _ns6__WUFile
{
public:
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	int *Option;	/* optional element of type xsd:int */
	std::wstring *SlaveIP;	/* optional element of type xsd:string */
	std::wstring *IPAddress;	/* optional element of type xsd:string */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *Query;	/* optional element of type xsd:string */
	std::wstring *Process;	/* optional element of type xsd:string */
	std::wstring *ClusterGroup;	/* optional element of type xsd:string */
	std::wstring *LogDate;	/* optional element of type xsd:string */
	int SlaveNumber;	/* optional element of type xsd:int */
	std::wstring *PlainText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 349; } /* = unique id SOAP_TYPE__ns6__WUFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUFile() : Name(NULL), Wuid(NULL), Type(NULL), Option(NULL), SlaveIP(NULL), IPAddress(NULL), Description(NULL), QuerySet(NULL), Query(NULL), Process(NULL), ClusterGroup(NULL), LogDate(NULL), SlaveNumber(0), PlainText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUFile() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WULogFileResponse
#define SOAP_TYPE__ns6__WULogFileResponse (350)
/* ns6:WULogFileResponse */
class SOAP_CMAC _ns6__WULogFileResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *QueryName;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	std::wstring *FileName;	/* optional element of type xsd:string */
	xsd__base64Binary *thefile;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 350; } /* = unique id SOAP_TYPE__ns6__WULogFileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WULogFileResponse() : Exceptions(NULL), Wuid(NULL), QuerySet(NULL), QueryName(NULL), QueryId(NULL), FileName(NULL), thefile(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WULogFileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGVCGraphInfo
#define SOAP_TYPE__ns6__WUGVCGraphInfo (351)
/* ns6:WUGVCGraphInfo */
class SOAP_CMAC _ns6__WUGVCGraphInfo
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	int *SubgraphId;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 351; } /* = unique id SOAP_TYPE__ns6__WUGVCGraphInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGVCGraphInfo() : Wuid(NULL), Name(NULL), GID(NULL), BatchWU(NULL), SubgraphId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGVCGraphInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGVCGraphInfoResponse
#define SOAP_TYPE__ns6__WUGVCGraphInfoResponse (352)
/* ns6:WUGVCGraphInfoResponse */
class SOAP_CMAC _ns6__WUGVCGraphInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	bool *Running;	/* optional element of type xsd:boolean */
	std::wstring *TheGraph;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 352; } /* = unique id SOAP_TYPE__ns6__WUGVCGraphInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGVCGraphInfoResponse() : Exceptions(NULL), Wuid(NULL), Name(NULL), GID(NULL), Running(NULL), TheGraph(NULL), BatchWU(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGVCGraphInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetDependancyTrees
#define SOAP_TYPE__ns6__WUGetDependancyTrees (353)
/* ns6:WUGetDependancyTrees */
class SOAP_CMAC _ns6__WUGetDependancyTrees
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	std::wstring *Items;	/* optional element of type xsd:string */
	std::wstring *TimeoutMilliSec;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 353; } /* = unique id SOAP_TYPE__ns6__WUGetDependancyTrees */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetDependancyTrees() : Cluster(NULL), Queue(NULL), Snapshot(NULL), Items(NULL), TimeoutMilliSec(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetDependancyTrees() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetDependancyTreesResponse
#define SOAP_TYPE__ns6__WUGetDependancyTreesResponse (354)
/* ns6:WUGetDependancyTreesResponse */
class SOAP_CMAC _ns6__WUGetDependancyTreesResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfECLException *Errors;	/* optional element of type ns6:ArrayOfECLException */
	xsd__base64Binary *DependancyTrees;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 354; } /* = unique id SOAP_TYPE__ns6__WUGetDependancyTreesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetDependancyTreesResponse() : Exceptions(NULL), Errors(NULL), DependancyTrees(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetDependancyTreesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetGraph
#define SOAP_TYPE__ns6__WUGetGraph (355)
/* ns6:WUGetGraph */
class SOAP_CMAC _ns6__WUGetGraph
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *GraphName;	/* optional element of type xsd:string */
	std::wstring *SubGraphId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 355; } /* = unique id SOAP_TYPE__ns6__WUGetGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetGraph() : Wuid(NULL), GraphName(NULL), SubGraphId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetGraph() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGetGraphResponse
#define SOAP_TYPE__ns6__WUGetGraphResponse (356)
/* ns6:WUGetGraphResponse */
class SOAP_CMAC _ns6__WUGetGraphResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfECLGraphEx *Graphs;	/* optional element of type ns6:ArrayOfECLGraphEx */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 356; } /* = unique id SOAP_TYPE__ns6__WUGetGraphResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGetGraphResponse() : Exceptions(NULL), Graphs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGetGraphResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphInfo
#define SOAP_TYPE__ns6__WUGraphInfo (357)
/* ns6:WUGraphInfo */
class SOAP_CMAC _ns6__WUGraphInfo
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 357; } /* = unique id SOAP_TYPE__ns6__WUGraphInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphInfo() : Wuid(NULL), Name(NULL), GID(NULL), BatchWU(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphInfoResponse
#define SOAP_TYPE__ns6__WUGraphInfoResponse (358)
/* ns6:WUGraphInfoResponse */
class SOAP_CMAC _ns6__WUGraphInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	std::wstring *GID;	/* optional element of type xsd:string */
	int *BatchWU;	/* optional element of type xsd:int */
	bool *Running;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 358; } /* = unique id SOAP_TYPE__ns6__WUGraphInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphInfoResponse() : Exceptions(NULL), Wuid(NULL), Name(NULL), GID(NULL), BatchWU(NULL), Running(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphTiming
#define SOAP_TYPE__ns6__WUGraphTiming (359)
/* ns6:WUGraphTiming */
class SOAP_CMAC _ns6__WUGraphTiming
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 359; } /* = unique id SOAP_TYPE__ns6__WUGraphTiming */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphTiming() : Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphTiming() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUGraphTimingResponse
#define SOAP_TYPE__ns6__WUGraphTimingResponse (360)
/* ns6:WUGraphTimingResponse */
class SOAP_CMAC _ns6__WUGraphTimingResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 360; } /* = unique id SOAP_TYPE__ns6__WUGraphTimingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUGraphTimingResponse() : Exceptions(NULL), Workunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUGraphTimingResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfo
#define SOAP_TYPE__ns6__WUInfo (361)
/* ns6:WUInfo */
class SOAP_CMAC _ns6__WUInfo
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	bool TruncateEclTo64k;	/* optional element of type xsd:boolean */
	std::wstring *Type;	/* optional element of type xsd:string */
	bool IncludeExceptions;	/* optional element of type xsd:boolean */
	bool IncludeGraphs;	/* optional element of type xsd:boolean */
	bool IncludeSourceFiles;	/* optional element of type xsd:boolean */
	bool IncludeResults;	/* optional element of type xsd:boolean */
	bool IncludeResultsViewNames;	/* optional element of type xsd:boolean */
	bool IncludeVariables;	/* optional element of type xsd:boolean */
	bool IncludeTimers;	/* optional element of type xsd:boolean */
	bool IncludeDebugValues;	/* optional element of type xsd:boolean */
	bool IncludeApplicationValues;	/* optional element of type xsd:boolean */
	bool IncludeWorkflows;	/* optional element of type xsd:boolean */
	bool SuppressResultSchemas;	/* optional element of type xsd:boolean */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 361; } /* = unique id SOAP_TYPE__ns6__WUInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfo() : Wuid(NULL), TruncateEclTo64k((bool)0), Type(NULL), IncludeExceptions((bool)0), IncludeGraphs((bool)0), IncludeSourceFiles((bool)0), IncludeResults((bool)0), IncludeResultsViewNames((bool)0), IncludeVariables((bool)0), IncludeTimers((bool)0), IncludeDebugValues((bool)0), IncludeApplicationValues((bool)0), IncludeWorkflows((bool)0), SuppressResultSchemas((bool)0), ThorSlaveIP(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfoResponse_ResultViews
#define SOAP_TYPE__ns6__WUInfoResponse_ResultViews (679)
/* ns6:WUInfoResponse-ResultViews */
class SOAP_CMAC _ns6__WUInfoResponse_ResultViews
{
public:
	std::vector<std::wstring * >View;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 679; } /* = unique id SOAP_TYPE__ns6__WUInfoResponse_ResultViews */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfoResponse_ResultViews()  { this->soap_default(NULL); }
	virtual ~_ns6__WUInfoResponse_ResultViews() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfoResponse
#define SOAP_TYPE__ns6__WUInfoResponse (362)
/* ns6:WUInfoResponse */
class SOAP_CMAC _ns6__WUInfoResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ECLWorkunit *Workunit;	/* optional element of type ns6:ECLWorkunit */
	int *AutoRefresh;	/* optional element of type xsd:int */
	bool *CanCompile;	/* optional element of type xsd:boolean */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	_ns6__WUInfoResponse_ResultViews *ResultViews;	/* optional element of type ns6:WUInfoResponse-ResultViews */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 362; } /* = unique id SOAP_TYPE__ns6__WUInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfoResponse() : Exceptions(NULL), Workunit(NULL), AutoRefresh(NULL), CanCompile(NULL), ThorSlaveIP(NULL), ResultViews(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUInfoDetails
#define SOAP_TYPE__ns6__WUInfoDetails (363)
/* ns6:WUInfoDetails */
class SOAP_CMAC _ns6__WUInfoDetails
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	bool TruncateEclTo64k;	/* optional element of type xsd:boolean */
	std::wstring *Type;	/* optional element of type xsd:string */
	bool IncludeExceptions;	/* optional element of type xsd:boolean */
	bool IncludeGraphs;	/* optional element of type xsd:boolean */
	bool IncludeSourceFiles;	/* optional element of type xsd:boolean */
	bool IncludeResults;	/* optional element of type xsd:boolean */
	bool IncludeResultsViewNames;	/* optional element of type xsd:boolean */
	bool IncludeVariables;	/* optional element of type xsd:boolean */
	bool IncludeTimers;	/* optional element of type xsd:boolean */
	bool IncludeDebugValues;	/* optional element of type xsd:boolean */
	bool IncludeApplicationValues;	/* optional element of type xsd:boolean */
	bool IncludeWorkflows;	/* optional element of type xsd:boolean */
	bool SuppressResultSchemas;	/* optional element of type xsd:boolean */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 363; } /* = unique id SOAP_TYPE__ns6__WUInfoDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUInfoDetails() : Wuid(NULL), TruncateEclTo64k((bool)0), Type(NULL), IncludeExceptions((bool)0), IncludeGraphs((bool)0), IncludeSourceFiles((bool)0), IncludeResults((bool)0), IncludeResultsViewNames((bool)0), IncludeVariables((bool)0), IncludeTimers((bool)0), IncludeDebugValues((bool)0), IncludeApplicationValues((bool)0), IncludeWorkflows((bool)0), SuppressResultSchemas((bool)0), ThorSlaveIP(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUInfoDetails() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUJobList
#define SOAP_TYPE__ns6__WUJobList (364)
/* ns6:WUJobList */
class SOAP_CMAC _ns6__WUJobList
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	bool *ShowAll;	/* optional element of type xsd:boolean */
	int *BusinessStartHour;	/* optional element of type xsd:int */
	int *BusinessEndHour;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 364; } /* = unique id SOAP_TYPE__ns6__WUJobList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUJobList() : Cluster(NULL), StartDate(NULL), EndDate(NULL), ShowAll(NULL), BusinessStartHour(NULL), BusinessEndHour(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUJobList() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUJobListResponse
#define SOAP_TYPE__ns6__WUJobListResponse (365)
/* ns6:WUJobListResponse */
class SOAP_CMAC _ns6__WUJobListResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	ns6__ArrayOfECLJob *Jobs;	/* optional element of type ns6:ArrayOfECLJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 365; } /* = unique id SOAP_TYPE__ns6__WUJobListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUJobListResponse() : Exceptions(NULL), StartDate(NULL), EndDate(NULL), Jobs(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUJobListResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListLocalFileRequired
#define SOAP_TYPE__ns6__WUListLocalFileRequired (366)
/* ns6:WUListLocalFileRequired */
class SOAP_CMAC _ns6__WUListLocalFileRequired
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 366; } /* = unique id SOAP_TYPE__ns6__WUListLocalFileRequired */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListLocalFileRequired() : Wuid(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListLocalFileRequired() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUListLocalFileRequiredResponse
#define SOAP_TYPE__ns6__WUListLocalFileRequiredResponse (367)
/* ns6:WUListLocalFileRequiredResponse */
class SOAP_CMAC _ns6__WUListLocalFileRequiredResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfLogicalFileUpload *LocalFileUploads;	/* optional element of type ns6:ArrayOfLogicalFileUpload */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 367; } /* = unique id SOAP_TYPE__ns6__WUListLocalFileRequiredResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUListLocalFileRequiredResponse() : Exceptions(NULL), LocalFileUploads(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUListLocalFileRequiredResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUMultiQuerysetDetails
#define SOAP_TYPE__ns6__WUMultiQuerysetDetails (368)
/* ns6:WUMultiQuerysetDetails */
class SOAP_CMAC _ns6__WUMultiQuerysetDetails
{
public:
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	std::wstring *Filter;	/* optional element of type xsd:string */
	enum ns6__WUQuerySetFilterType FilterType;	/* optional element of type ns6:WUQuerySetFilterType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 368; } /* = unique id SOAP_TYPE__ns6__WUMultiQuerysetDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUMultiQuerysetDetails() : ClusterName(NULL), QuerySetName(NULL), Filter(NULL), FilterType((enum ns6__WUQuerySetFilterType)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUMultiQuerysetDetails() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUMultiQuerySetDetailsResponse
#define SOAP_TYPE__ns6__WUMultiQuerySetDetailsResponse (369)
/* ns6:WUMultiQuerySetDetailsResponse */
class SOAP_CMAC _ns6__WUMultiQuerySetDetailsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	ns6__ArrayOfWUQuerySetDetail *Querysets;	/* optional element of type ns6:ArrayOfWUQuerySetDetail */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 369; } /* = unique id SOAP_TYPE__ns6__WUMultiQuerySetDetailsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUMultiQuerySetDetailsResponse() : Exceptions(NULL), ClusterName(NULL), Querysets(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUMultiQuerySetDetailsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProcessGraph
#define SOAP_TYPE__ns6__WUProcessGraph (370)
/* ns6:WUProcessGraph */
class SOAP_CMAC _ns6__WUProcessGraph
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 370; } /* = unique id SOAP_TYPE__ns6__WUProcessGraph */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProcessGraph() : Wuid(NULL), Name(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProcessGraph() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProcessGraphResponse
#define SOAP_TYPE__ns6__WUProcessGraphResponse (371)
/* ns6:WUProcessGraphResponse */
class SOAP_CMAC _ns6__WUProcessGraphResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *theGraph;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 371; } /* = unique id SOAP_TYPE__ns6__WUProcessGraphResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProcessGraphResponse() : Exceptions(NULL), theGraph(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProcessGraphResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProtect
#define SOAP_TYPE__ns6__WUProtect (372)
/* ns6:WUProtect */
class SOAP_CMAC _ns6__WUProtect
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	bool Protect;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 372; } /* = unique id SOAP_TYPE__ns6__WUProtect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProtect() : Wuids(NULL), Protect((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProtect() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUProtectResponse
#define SOAP_TYPE__ns6__WUProtectResponse (373)
/* ns6:WUProtectResponse */
class SOAP_CMAC _ns6__WUProtectResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfWUActionResult *ActionResults;	/* optional element of type ns6:ArrayOfWUActionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 373; } /* = unique id SOAP_TYPE__ns6__WUProtectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUProtectResponse() : Exceptions(NULL), ActionResults(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUProtectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPublishWorkunit
#define SOAP_TYPE__ns6__WUPublishWorkunit (374)
/* ns6:WUPublishWorkunit */
class SOAP_CMAC _ns6__WUPublishWorkunit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *JobName;	/* optional element of type xsd:string */
	int *Activate;	/* optional element of type xsd:int */
	bool NotifyCluster;	/* optional element of type xsd:boolean */
	bool showFiles;	/* optional element of type xsd:boolean */
	bool CopyLocal;	/* optional element of type xsd:boolean */
	int Wait;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 374; } /* = unique id SOAP_TYPE__ns6__WUPublishWorkunit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPublishWorkunit() : Wuid(NULL), Cluster(NULL), JobName(NULL), Activate(NULL), NotifyCluster((bool)0), showFiles((bool)0), CopyLocal((bool)0), Wait(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPublishWorkunit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPublishWorkunitResponse_ClusterFiles
#define SOAP_TYPE__ns6__WUPublishWorkunitResponse_ClusterFiles (684)
/* ns6:WUPublishWorkunitResponse-ClusterFiles */
class SOAP_CMAC _ns6__WUPublishWorkunitResponse_ClusterFiles
{
public:
	std::vector<ns6__WUCopyLogicalClusterFileSections * >Cluster;	/* optional element of type ns6:WUCopyLogicalClusterFileSections */
public:
	virtual int soap_type() const { return 684; } /* = unique id SOAP_TYPE__ns6__WUPublishWorkunitResponse_ClusterFiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPublishWorkunitResponse_ClusterFiles()  { this->soap_default(NULL); }
	virtual ~_ns6__WUPublishWorkunitResponse_ClusterFiles() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPublishWorkunitResponse
#define SOAP_TYPE__ns6__WUPublishWorkunitResponse (375)
/* ns6:WUPublishWorkunitResponse */
class SOAP_CMAC _ns6__WUPublishWorkunitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *QueryName;	/* optional element of type xsd:string */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	bool *ReloadFailed;	/* optional element of type xsd:boolean */
	_ns6__WUPublishWorkunitResponse_ClusterFiles *ClusterFiles;	/* optional element of type ns6:WUPublishWorkunitResponse-ClusterFiles */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 375; } /* = unique id SOAP_TYPE__ns6__WUPublishWorkunitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPublishWorkunitResponse() : Exceptions(NULL), Wuid(NULL), Result(NULL), QuerySet(NULL), QueryName(NULL), QueryId(NULL), ReloadFailed(NULL), ClusterFiles(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPublishWorkunitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPushEvent
#define SOAP_TYPE__ns6__WUPushEvent (376)
/* ns6:WUPushEvent */
class SOAP_CMAC _ns6__WUPushEvent
{
public:
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *EventText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 376; } /* = unique id SOAP_TYPE__ns6__WUPushEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPushEvent() : EventName(NULL), EventText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPushEvent() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUPushEventResponse
#define SOAP_TYPE__ns6__WUPushEventResponse (377)
/* ns6:WUPushEventResponse */
class SOAP_CMAC _ns6__WUPushEventResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 377; } /* = unique id SOAP_TYPE__ns6__WUPushEventResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUPushEventResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUPushEventResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuery
#define SOAP_TYPE__ns6__WUQuery (378)
/* ns6:WUQuery */
class SOAP_CMAC _ns6__WUQuery
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *RoxieCluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *LogicalFile;	/* optional element of type xsd:string */
	std::wstring *LogicalFileSearchType;	/* optional element of type xsd:string */
	std::wstring *ApplicationName;	/* optional element of type xsd:string */
	std::wstring *ApplicationKey;	/* optional element of type xsd:string */
	std::wstring *ApplicationData;	/* optional element of type xsd:string */
	std::wstring *After;	/* optional element of type xsd:string */
	std::wstring *Before;	/* optional element of type xsd:string */
	int *Count;	/* optional element of type xsd:int */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *PageStartFrom;	/* optional element of type xsd:long */
	LONG64 *PageEndAt;	/* optional element of type xsd:long */
	int *LastNDays;	/* optional element of type xsd:int */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 378; } /* = unique id SOAP_TYPE__ns6__WUQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuery() : Wuid(NULL), Type(NULL), Cluster(NULL), RoxieCluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), ECL(NULL), Jobname(NULL), LogicalFile(NULL), LogicalFileSearchType(NULL), ApplicationName(NULL), ApplicationKey(NULL), ApplicationData(NULL), After(NULL), Before(NULL), Count(NULL), PageSize(NULL), PageStartFrom(NULL), PageEndAt(NULL), LastNDays(NULL), Sortby(NULL), Descending((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuery() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQueryResponse
#define SOAP_TYPE__ns6__WUQueryResponse (379)
/* ns6:WUQueryResponse */
class SOAP_CMAC _ns6__WUQueryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Type;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *RoxieCluster;	/* optional element of type xsd:string */
	std::wstring *Owner;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *LogicalFile;	/* optional element of type xsd:string */
	std::wstring *LogicalFileSearchType;	/* optional element of type xsd:string */
	std::wstring *Current;	/* optional element of type xsd:string */
	std::wstring *Next;	/* optional element of type xsd:string */
	int *Count;	/* optional element of type xsd:int */
	LONG64 *PageSize;	/* optional element of type xsd:long */
	LONG64 *PrevPage;	/* optional element of type xsd:long */
	LONG64 *NextPage;	/* optional element of type xsd:long */
	LONG64 LastPage;	/* optional element of type xsd:long */
	int *NumWUs;	/* optional element of type xsd:int */
	bool First;	/* optional element of type xsd:boolean */
	LONG64 PageStartFrom;	/* optional element of type xsd:long */
	LONG64 *PageEndAt;	/* optional element of type xsd:long */
	int *LastNDays;	/* optional element of type xsd:int */
	std::wstring *Sortby;	/* optional element of type xsd:string */
	bool Descending;	/* optional element of type xsd:boolean */
	std::wstring *BasicQuery;	/* optional element of type xsd:string */
	std::wstring *Filters;	/* optional element of type xsd:string */
	ns6__ArrayOfECLWorkunit *Workunits;	/* optional element of type ns6:ArrayOfECLWorkunit */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 379; } /* = unique id SOAP_TYPE__ns6__WUQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQueryResponse() : Exceptions(NULL), Type(NULL), Cluster(NULL), RoxieCluster(NULL), Owner(NULL), State(NULL), StartDate(NULL), EndDate(NULL), ECL(NULL), Jobname(NULL), LogicalFile(NULL), LogicalFileSearchType(NULL), Current(NULL), Next(NULL), Count(NULL), PageSize(NULL), PrevPage(NULL), NextPage(NULL), LastPage(0), NumWUs(NULL), First((bool)0), PageStartFrom(0), PageEndAt(NULL), LastNDays(NULL), Sortby(NULL), Descending((bool)0), BasicQuery(NULL), Filters(NULL), Workunits(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetAliasAction_Aliases
#define SOAP_TYPE__ns6__WUQuerysetAliasAction_Aliases (688)
/* ns6:WUQuerysetAliasAction-Aliases */
class SOAP_CMAC _ns6__WUQuerysetAliasAction_Aliases
{
public:
	std::vector<ns6__QuerySetAliasActionItem * >Alias;	/* optional element of type ns6:QuerySetAliasActionItem */
public:
	virtual int soap_type() const { return 688; } /* = unique id SOAP_TYPE__ns6__WUQuerysetAliasAction_Aliases */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetAliasAction_Aliases()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetAliasAction_Aliases() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetAliasAction
#define SOAP_TYPE__ns6__WUQuerysetAliasAction (380)
/* ns6:WUQuerysetAliasAction */
class SOAP_CMAC _ns6__WUQuerysetAliasAction
{
public:
	enum ns6__QuerySetAliasActionTypes *Action;	/* optional element of type ns6:QuerySetAliasActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerysetAliasAction_Aliases *Aliases;	/* optional element of type ns6:WUQuerysetAliasAction-Aliases */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 380; } /* = unique id SOAP_TYPE__ns6__WUQuerysetAliasAction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetAliasAction() : Action(NULL), QuerySetName(NULL), Aliases(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetAliasAction() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetAliasActionResponse_Results
#define SOAP_TYPE__ns6__WUQuerySetAliasActionResponse_Results (692)
/* ns6:WUQuerySetAliasActionResponse-Results */
class SOAP_CMAC _ns6__WUQuerySetAliasActionResponse_Results
{
public:
	std::vector<ns6__QuerySetAliasActionResult * >Result;	/* optional element of type ns6:QuerySetAliasActionResult */
public:
	virtual int soap_type() const { return 692; } /* = unique id SOAP_TYPE__ns6__WUQuerySetAliasActionResponse_Results */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetAliasActionResponse_Results()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetAliasActionResponse_Results() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetAliasActionResponse
#define SOAP_TYPE__ns6__WUQuerySetAliasActionResponse (381)
/* ns6:WUQuerySetAliasActionResponse */
class SOAP_CMAC _ns6__WUQuerySetAliasActionResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	enum ns6__QuerySetAliasActionTypes *Action;	/* optional element of type ns6:QuerySetAliasActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerySetAliasActionResponse_Results *Results;	/* optional element of type ns6:WUQuerySetAliasActionResponse-Results */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 381; } /* = unique id SOAP_TYPE__ns6__WUQuerySetAliasActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetAliasActionResponse() : Exceptions(NULL), Action(NULL), QuerySetName(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetAliasActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetCopyQuery
#define SOAP_TYPE__ns6__WUQuerysetCopyQuery (382)
/* ns6:WUQuerysetCopyQuery */
class SOAP_CMAC _ns6__WUQuerysetCopyQuery
{
public:
	std::wstring *Source;	/* optional element of type xsd:string */
	std::wstring *Target;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	int *Activate;	/* optional element of type xsd:int */
	int Wait;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 382; } /* = unique id SOAP_TYPE__ns6__WUQuerysetCopyQuery */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetCopyQuery() : Source(NULL), Target(NULL), Cluster(NULL), Activate(NULL), Wait(0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetCopyQuery() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse
#define SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse (383)
/* ns6:WUQuerySetCopyQueryResponse */
class SOAP_CMAC _ns6__WUQuerySetCopyQueryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *QueryId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 383; } /* = unique id SOAP_TYPE__ns6__WUQuerySetCopyQueryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetCopyQueryResponse() : Exceptions(NULL), QueryId(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetCopyQueryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetDetails
#define SOAP_TYPE__ns6__WUQuerysetDetails (384)
/* ns6:WUQuerysetDetails */
class SOAP_CMAC _ns6__WUQuerysetDetails
{
public:
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	std::wstring *Filter;	/* optional element of type xsd:string */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	enum ns6__WUQuerySetFilterType FilterType;	/* optional element of type ns6:WUQuerySetFilterType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 384; } /* = unique id SOAP_TYPE__ns6__WUQuerysetDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetDetails() : QuerySetName(NULL), Filter(NULL), ClusterName(NULL), FilterType((enum ns6__WUQuerySetFilterType)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetDetails() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetDetailsResponse
#define SOAP_TYPE__ns6__WUQuerySetDetailsResponse (385)
/* ns6:WUQuerySetDetailsResponse */
class SOAP_CMAC _ns6__WUQuerySetDetailsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	ns6__ArrayOfQuerySetQuery *QuerysetQueries;	/* optional element of type ns6:ArrayOfQuerySetQuery */
	ns6__ArrayOfQuerySetAlias *QuerysetAliases;	/* optional element of type ns6:ArrayOfQuerySetAlias */
	std::wstring *ClusterName;	/* optional element of type xsd:string */
	std::wstring *Filter;	/* optional element of type xsd:string */
	enum ns6__WUQuerySetFilterType *FilterType;	/* optional element of type ns6:WUQuerySetFilterType */
	ns6__EspStringArray *ClusterNames;	/* optional element of type ns6:EspStringArray */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 385; } /* = unique id SOAP_TYPE__ns6__WUQuerySetDetailsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetDetailsResponse() : Exceptions(NULL), QuerySetName(NULL), QuerysetQueries(NULL), QuerysetAliases(NULL), ClusterName(NULL), Filter(NULL), FilterType(NULL), ClusterNames(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetDetailsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetQueryAction_Queries
#define SOAP_TYPE__ns6__WUQuerysetQueryAction_Queries (698)
/* ns6:WUQuerysetQueryAction-Queries */
class SOAP_CMAC _ns6__WUQuerysetQueryAction_Queries
{
public:
	std::vector<ns6__QuerySetQueryActionItem * >Query;	/* optional element of type ns6:QuerySetQueryActionItem */
public:
	virtual int soap_type() const { return 698; } /* = unique id SOAP_TYPE__ns6__WUQuerysetQueryAction_Queries */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetQueryAction_Queries()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetQueryAction_Queries() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetQueryAction
#define SOAP_TYPE__ns6__WUQuerysetQueryAction (386)
/* ns6:WUQuerysetQueryAction */
class SOAP_CMAC _ns6__WUQuerysetQueryAction
{
public:
	enum ns6__QuerySetQueryActionTypes *Action;	/* optional element of type ns6:QuerySetQueryActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerysetQueryAction_Queries *Queries;	/* optional element of type ns6:WUQuerysetQueryAction-Queries */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 386; } /* = unique id SOAP_TYPE__ns6__WUQuerysetQueryAction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetQueryAction() : Action(NULL), QuerySetName(NULL), Queries(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetQueryAction() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetQueryActionResponse_Results
#define SOAP_TYPE__ns6__WUQuerySetQueryActionResponse_Results (702)
/* ns6:WUQuerySetQueryActionResponse-Results */
class SOAP_CMAC _ns6__WUQuerySetQueryActionResponse_Results
{
public:
	std::vector<ns6__QuerySetQueryActionResult * >Result;	/* optional element of type ns6:QuerySetQueryActionResult */
public:
	virtual int soap_type() const { return 702; } /* = unique id SOAP_TYPE__ns6__WUQuerySetQueryActionResponse_Results */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetQueryActionResponse_Results()  { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetQueryActionResponse_Results() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerySetQueryActionResponse
#define SOAP_TYPE__ns6__WUQuerySetQueryActionResponse (387)
/* ns6:WUQuerySetQueryActionResponse */
class SOAP_CMAC _ns6__WUQuerySetQueryActionResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	enum ns6__QuerySetQueryActionTypes *Action;	/* optional element of type ns6:QuerySetQueryActionTypes */
	std::wstring *QuerySetName;	/* optional element of type xsd:string */
	_ns6__WUQuerySetQueryActionResponse_Results *Results;	/* optional element of type ns6:WUQuerySetQueryActionResponse-Results */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 387; } /* = unique id SOAP_TYPE__ns6__WUQuerySetQueryActionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerySetQueryActionResponse() : Exceptions(NULL), Action(NULL), QuerySetName(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerySetQueryActionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysets
#define SOAP_TYPE__ns6__WUQuerysets (388)
/* ns6:WUQuerysets */
class SOAP_CMAC _ns6__WUQuerysets
{
public:
	bool *test;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 388; } /* = unique id SOAP_TYPE__ns6__WUQuerysets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysets() : test(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysets() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUQuerysetsResponse
#define SOAP_TYPE__ns6__WUQuerysetsResponse (389)
/* ns6:WUQuerysetsResponse */
class SOAP_CMAC _ns6__WUQuerysetsResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfQuerySet *Querysets;	/* optional element of type ns6:ArrayOfQuerySet */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 389; } /* = unique id SOAP_TYPE__ns6__WUQuerysetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUQuerysetsResponse() : Exceptions(NULL), Querysets(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUQuerysetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResubmit
#define SOAP_TYPE__ns6__WUResubmit (390)
/* ns6:WUResubmit */
class SOAP_CMAC _ns6__WUResubmit
{
public:
	ns6__EspStringArray *Wuids;	/* optional element of type ns6:EspStringArray */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	bool *ResetWorkflow;	/* optional element of type xsd:boolean */
	bool *CloneWorkunit;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 390; } /* = unique id SOAP_TYPE__ns6__WUResubmit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResubmit() : Wuids(NULL), BlockTillFinishTimer(NULL), ResetWorkflow(NULL), CloneWorkunit(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResubmit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResubmitResponse
#define SOAP_TYPE__ns6__WUResubmitResponse (391)
/* ns6:WUResubmitResponse */
class SOAP_CMAC _ns6__WUResubmitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 391; } /* = unique id SOAP_TYPE__ns6__WUResubmitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResubmitResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResubmitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResult
#define SOAP_TYPE__ns6__WUResult (392)
/* ns6:WUResult */
class SOAP_CMAC _ns6__WUResult
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *ResultName;	/* optional element of type xsd:string */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 392; } /* = unique id SOAP_TYPE__ns6__WUResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResult() : Wuid(NULL), Sequence(NULL), ResultName(NULL), LogicalName(NULL), Cluster(NULL), Start(NULL), Count(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResult() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultResponse
#define SOAP_TYPE__ns6__WUResultResponse (393)
/* ns6:WUResultResponse */
class SOAP_CMAC _ns6__WUResultResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Name;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Requested;	/* optional element of type xsd:int */
	int *Count;	/* optional element of type xsd:int */
	LONG64 *Total;	/* optional element of type xsd:long */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 393; } /* = unique id SOAP_TYPE__ns6__WUResultResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultResponse() : Exceptions(NULL), Wuid(NULL), Sequence(NULL), LogicalName(NULL), Cluster(NULL), Name(NULL), Start(NULL), Requested(NULL), Count(NULL), Total(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultBin
#define SOAP_TYPE__ns6__WUResultBin (394)
/* ns6:WUResultBin */
class SOAP_CMAC _ns6__WUResultBin
{
public:
	std::wstring *LogicalName;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *ResultName;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *Format;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 394; } /* = unique id SOAP_TYPE__ns6__WUResultBin */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultBin() : LogicalName(NULL), Wuid(NULL), ResultName(NULL), Sequence(NULL), Format(NULL), Start(NULL), Count(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultBin() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultBinResponse
#define SOAP_TYPE__ns6__WUResultBinResponse (395)
/* ns6:WUResultBinResponse */
class SOAP_CMAC _ns6__WUResultBinResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *Name;	/* optional element of type xsd:string */
	LONG64 *Start;	/* optional element of type xsd:long */
	int *Count;	/* optional element of type xsd:int */
	int *Requested;	/* optional element of type xsd:int */
	LONG64 *Total;	/* optional element of type xsd:long */
	xsd__base64Binary *Result;	/* optional element of type xsd:base64Binary */
	std::wstring *Format;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 395; } /* = unique id SOAP_TYPE__ns6__WUResultBinResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultBinResponse() : Exceptions(NULL), Wuid(NULL), Sequence(NULL), Name(NULL), Start(NULL), Count(NULL), Requested(NULL), Total(NULL), Result(NULL), Format(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultBinResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultSummary
#define SOAP_TYPE__ns6__WUResultSummary (396)
/* ns6:WUResultSummary */
class SOAP_CMAC _ns6__WUResultSummary
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 396; } /* = unique id SOAP_TYPE__ns6__WUResultSummary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultSummary() : Wuid(NULL), Sequence(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultSummary() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultSummaryResponse
#define SOAP_TYPE__ns6__WUResultSummaryResponse (397)
/* ns6:WUResultSummaryResponse */
class SOAP_CMAC _ns6__WUResultSummaryResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	int *Format;	/* optional element of type xsd:int */
	ns6__ECLResult *Result;	/* optional element of type ns6:ECLResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 397; } /* = unique id SOAP_TYPE__ns6__WUResultSummaryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultSummaryResponse() : Exceptions(NULL), Wuid(NULL), Sequence(NULL), Format(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultSummaryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultView
#define SOAP_TYPE__ns6__WUResultView (398)
/* ns6:WUResultView */
class SOAP_CMAC _ns6__WUResultView
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *ViewName;	/* optional element of type xsd:string */
	int *Sequence;	/* optional element of type xsd:int */
	std::wstring *ResultName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 398; } /* = unique id SOAP_TYPE__ns6__WUResultView */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultView() : Wuid(NULL), ViewName(NULL), Sequence(NULL), ResultName(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultView() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUResultViewResponse
#define SOAP_TYPE__ns6__WUResultViewResponse (399)
/* ns6:WUResultViewResponse */
class SOAP_CMAC _ns6__WUResultViewResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *ViewName;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 399; } /* = unique id SOAP_TYPE__ns6__WUResultViewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUResultViewResponse() : Exceptions(NULL), Wuid(NULL), ViewName(NULL), Result(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUResultViewResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WURun
#define SOAP_TYPE__ns6__WURun (400)
/* ns6:WURun */
class SOAP_CMAC _ns6__WURun
{
public:
	std::wstring *QuerySet;	/* optional element of type xsd:string */
	std::wstring *Query;	/* optional element of type xsd:string */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	bool *CloneWorkunit;	/* optional element of type xsd:boolean */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	std::wstring *Input;	/* optional element of type xsd:string */
	bool NoRootTag;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 400; } /* = unique id SOAP_TYPE__ns6__WURun */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WURun() : QuerySet(NULL), Query(NULL), Wuid(NULL), CloneWorkunit(NULL), Cluster(NULL), Wait(0), Input(NULL), NoRootTag((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WURun() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WURunResponse
#define SOAP_TYPE__ns6__WURunResponse (401)
/* ns6:WURunResponse */
class SOAP_CMAC _ns6__WURunResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *State;	/* optional element of type xsd:string */
	std::wstring *Results;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 401; } /* = unique id SOAP_TYPE__ns6__WURunResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WURunResponse() : Exceptions(NULL), Wuid(NULL), State(NULL), Results(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WURunResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSchedule
#define SOAP_TYPE__ns6__WUSchedule (402)
/* ns6:WUSchedule */
class SOAP_CMAC _ns6__WUSchedule
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	time_t *When;	/* optional element of type xsd:dateTime */
	int *MaxRunTime;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 402; } /* = unique id SOAP_TYPE__ns6__WUSchedule */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSchedule() : Wuid(NULL), Cluster(NULL), Queue(NULL), Snapshot(NULL), When(NULL), MaxRunTime(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSchedule() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUScheduleResponse
#define SOAP_TYPE__ns6__WUScheduleResponse (403)
/* ns6:WUScheduleResponse */
class SOAP_CMAC _ns6__WUScheduleResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 403; } /* = unique id SOAP_TYPE__ns6__WUScheduleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUScheduleResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUScheduleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUShowScheduled
#define SOAP_TYPE__ns6__WUShowScheduled (404)
/* ns6:WUShowScheduled */
class SOAP_CMAC _ns6__WUShowScheduled
{
public:
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *PushEventName;	/* optional element of type xsd:string */
	std::wstring *PushEventText;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 404; } /* = unique id SOAP_TYPE__ns6__WUShowScheduled */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUShowScheduled() : Cluster(NULL), EventName(NULL), PushEventName(NULL), PushEventText(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUShowScheduled() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUShowScheduledResponse
#define SOAP_TYPE__ns6__WUShowScheduledResponse (405)
/* ns6:WUShowScheduledResponse */
class SOAP_CMAC _ns6__WUShowScheduledResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	int *ClusterSelected;	/* optional element of type xsd:int */
	std::wstring *EventName;	/* optional element of type xsd:string */
	std::wstring *PushEventName;	/* optional element of type xsd:string */
	std::wstring *PushEventText;	/* optional element of type xsd:string */
	std::wstring *Query;	/* optional element of type xsd:string */
	ns6__ArrayOfServerInfo *Clusters;	/* optional element of type ns6:ArrayOfServerInfo */
	ns6__ArrayOfScheduledWU *Workunits;	/* optional element of type ns6:ArrayOfScheduledWU */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 405; } /* = unique id SOAP_TYPE__ns6__WUShowScheduledResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUShowScheduledResponse() : Exceptions(NULL), ClusterSelected(NULL), EventName(NULL), PushEventName(NULL), PushEventText(NULL), Query(NULL), Clusters(NULL), Workunits(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUShowScheduledResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSubmit
#define SOAP_TYPE__ns6__WUSubmit (406)
/* ns6:WUSubmit */
class SOAP_CMAC _ns6__WUSubmit
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	int *MaxRunTime;	/* optional element of type xsd:int */
	int *BlockTillFinishTimer;	/* optional element of type xsd:int */
	bool SyntaxCheck;	/* optional element of type xsd:boolean */
	bool NotifyCluster;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 406; } /* = unique id SOAP_TYPE__ns6__WUSubmit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSubmit() : Wuid(NULL), Cluster(NULL), Queue(NULL), Snapshot(NULL), MaxRunTime(NULL), BlockTillFinishTimer(NULL), SyntaxCheck((bool)0), NotifyCluster((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSubmit() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSubmitResponse
#define SOAP_TYPE__ns6__WUSubmitResponse (407)
/* ns6:WUSubmitResponse */
class SOAP_CMAC _ns6__WUSubmitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 407; } /* = unique id SOAP_TYPE__ns6__WUSubmitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSubmitResponse() : Exceptions(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSubmitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSyntaxCheckECL
#define SOAP_TYPE__ns6__WUSyntaxCheckECL (408)
/* ns6:WUSyntaxCheckECL */
class SOAP_CMAC _ns6__WUSyntaxCheckECL
{
public:
	std::wstring *ECL;	/* optional element of type xsd:string */
	std::wstring *ModuleName;	/* optional element of type xsd:string */
	std::wstring *AttributeName;	/* optional element of type xsd:string */
	std::wstring *Queue;	/* optional element of type xsd:string */
	std::wstring *Cluster;	/* optional element of type xsd:string */
	std::wstring *Snapshot;	/* optional element of type xsd:string */
	int TimeToWait;	/* optional element of type xsd:int */
	ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 408; } /* = unique id SOAP_TYPE__ns6__WUSyntaxCheckECL */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSyntaxCheckECL() : ECL(NULL), ModuleName(NULL), AttributeName(NULL), Queue(NULL), Cluster(NULL), Snapshot(NULL), TimeToWait(0), DebugValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSyntaxCheckECL() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUSyntaxCheckResponse
#define SOAP_TYPE__ns6__WUSyntaxCheckResponse (409)
/* ns6:WUSyntaxCheckResponse */
class SOAP_CMAC _ns6__WUSyntaxCheckResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	ns6__ArrayOfECLException *Errors;	/* optional element of type ns6:ArrayOfECLException */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 409; } /* = unique id SOAP_TYPE__ns6__WUSyntaxCheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUSyntaxCheckResponse() : Exceptions(NULL), Errors(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUSyntaxCheckResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUUpdate
#define SOAP_TYPE__ns6__WUUpdate (410)
/* ns6:WUUpdate */
class SOAP_CMAC _ns6__WUUpdate
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int *State;	/* optional element of type xsd:int */
	int *StateOrig;	/* optional element of type xsd:int */
	std::wstring *Jobname;	/* optional element of type xsd:string */
	std::wstring *JobnameOrig;	/* optional element of type xsd:string */
	std::wstring *QueryText;	/* optional element of type xsd:string */
	int *Action;	/* optional element of type xsd:int */
	std::wstring *Description;	/* optional element of type xsd:string */
	std::wstring *DescriptionOrig;	/* optional element of type xsd:string */
	bool *AddDrilldownFields;	/* optional element of type xsd:boolean */
	int *ResultLimit;	/* optional element of type xsd:int */
	bool *Protected;	/* optional element of type xsd:boolean */
	bool *ProtectedOrig;	/* optional element of type xsd:boolean */
	int *PriorityClass;	/* optional element of type xsd:int */
	int *PriorityLevel;	/* optional element of type xsd:int */
	std::wstring *Scope;	/* optional element of type xsd:string */
	std::wstring *ScopeOrig;	/* optional element of type xsd:string */
	std::wstring *ClusterSelection;	/* optional element of type xsd:string */
	std::wstring *ClusterOrig;	/* optional element of type xsd:string */
	std::wstring *XmlParams;	/* optional element of type xsd:string */
	std::wstring *ThorSlaveIP;	/* optional element of type xsd:string */
	std::wstring *QueryMainDefinition;	/* optional element of type xsd:string */
	ns6__ArrayOfDebugValue *DebugValues;	/* optional element of type ns6:ArrayOfDebugValue */
	ns6__ArrayOfApplicationValue *ApplicationValues;	/* optional element of type ns6:ArrayOfApplicationValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 410; } /* = unique id SOAP_TYPE__ns6__WUUpdate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUUpdate() : Wuid(NULL), State(NULL), StateOrig(NULL), Jobname(NULL), JobnameOrig(NULL), QueryText(NULL), Action(NULL), Description(NULL), DescriptionOrig(NULL), AddDrilldownFields(NULL), ResultLimit(NULL), Protected(NULL), ProtectedOrig(NULL), PriorityClass(NULL), PriorityLevel(NULL), Scope(NULL), ScopeOrig(NULL), ClusterSelection(NULL), ClusterOrig(NULL), XmlParams(NULL), ThorSlaveIP(NULL), QueryMainDefinition(NULL), DebugValues(NULL), ApplicationValues(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUUpdate() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUWaitCompiled
#define SOAP_TYPE__ns6__WUWaitCompiled (411)
/* ns6:WUWaitCompiled */
class SOAP_CMAC _ns6__WUWaitCompiled
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	bool ReturnOnWait;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 411; } /* = unique id SOAP_TYPE__ns6__WUWaitCompiled */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUWaitCompiled() : Wuid(NULL), Wait(0), ReturnOnWait((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUWaitCompiled() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUWaitResponse
#define SOAP_TYPE__ns6__WUWaitResponse (412)
/* ns6:WUWaitResponse */
class SOAP_CMAC _ns6__WUWaitResponse
{
public:
	ns6__ArrayOfEspException *Exceptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:ArrayOfEspException */
	int *StateID;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 412; } /* = unique id SOAP_TYPE__ns6__WUWaitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUWaitResponse() : Exceptions(NULL), StateID(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUWaitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__WUWaitComplete
#define SOAP_TYPE__ns6__WUWaitComplete (413)
/* ns6:WUWaitComplete */
class SOAP_CMAC _ns6__WUWaitComplete
{
public:
	std::wstring *Wuid;	/* optional element of type xsd:string */
	int Wait;	/* optional element of type xsd:int */
	bool ReturnOnWait;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 413; } /* = unique id SOAP_TYPE__ns6__WUWaitComplete */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__WUWaitComplete() : Wuid(NULL), Wait(0), ReturnOnWait((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~_ns6__WUWaitComplete() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (709)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns1__ArrayOfEspException *ns1__Exceptions;	/* optional element of type ns1:ArrayOfEspException */
	ns2__ArrayOfEspException *ns2__Exceptions;	/* optional element of type ns2:ArrayOfEspException */
	ns3__ArrayOfEspException *ns3__Exceptions;	/* optional element of type ns3:ArrayOfEspException */
	ns4__ArrayOfEspException *ns4__Exceptions;	/* optional element of type ns4:ArrayOfEspException */
	ns5__ArrayOfEspException *ns5__Exceptions;	/* optional element of type ns5:ArrayOfEspException */
	ns6__ArrayOfEspException *ns6__Exceptions;	/* optional element of type ns6:ArrayOfEspException */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns1__MyAccount
#define SOAP_TYPE___ns1__MyAccount (715)
/* Operation wrapper: */
struct __ns1__MyAccount
{
public:
	_ns1__MyAccountRequest *ns1__MyAccountRequest;	/* optional element of type ns1:MyAccountRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__UpdateUser
#define SOAP_TYPE___ns1__UpdateUser (719)
/* Operation wrapper: */
struct __ns1__UpdateUser
{
public:
	_ns1__UpdateUserRequest *ns1__UpdateUserRequest;	/* optional element of type ns1:UpdateUserRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__UpdateUserInput
#define SOAP_TYPE___ns1__UpdateUserInput (723)
/* Operation wrapper: */
struct __ns1__UpdateUserInput
{
public:
	_ns1__UpdateUserInputRequest *ns1__UpdateUserInputRequest;	/* optional element of type ns1:UpdateUserInputRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__VerifyUser
#define SOAP_TYPE___ns1__VerifyUser (727)
/* Operation wrapper: */
struct __ns1__VerifyUser
{
public:
	_ns1__VerifyUserRequest *ns1__VerifyUserRequest;	/* optional element of type ns1:VerifyUserRequest */
};
#endif

#ifndef SOAP_TYPE___ns2__CheckinAttributes
#define SOAP_TYPE___ns2__CheckinAttributes (731)
/* Operation wrapper: */
struct __ns2__CheckinAttributes
{
public:
	_ns2__CheckinAttributes *ns2__CheckinAttributes;	/* optional element of type ns2:CheckinAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__CheckoutAttributes
#define SOAP_TYPE___ns2__CheckoutAttributes (734)
/* Operation wrapper: */
struct __ns2__CheckoutAttributes
{
public:
	_ns2__CheckoutAttributes *ns2__CheckoutAttributes;	/* optional element of type ns2:CheckoutAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__CreateAttribute
#define SOAP_TYPE___ns2__CreateAttribute (738)
/* Operation wrapper: */
struct __ns2__CreateAttribute
{
public:
	_ns2__CreateAttribute *ns2__CreateAttribute;	/* optional element of type ns2:CreateAttribute */
};
#endif

#ifndef SOAP_TYPE___ns2__CreateLabel
#define SOAP_TYPE___ns2__CreateLabel (742)
/* Operation wrapper: */
struct __ns2__CreateLabel
{
public:
	_ns2__CreateLabel *ns2__CreateLabel;	/* optional element of type ns2:CreateLabel */
};
#endif

#ifndef SOAP_TYPE___ns2__CreateModule
#define SOAP_TYPE___ns2__CreateModule (746)
/* Operation wrapper: */
struct __ns2__CreateModule
{
public:
	_ns2__CreateModule *ns2__CreateModule;	/* optional element of type ns2:CreateModule */
};
#endif

#ifndef SOAP_TYPE___ns2__DeleteAttributes
#define SOAP_TYPE___ns2__DeleteAttributes (749)
/* Operation wrapper: */
struct __ns2__DeleteAttributes
{
public:
	_ns2__DeleteAttributes *ns2__DeleteAttributes;	/* optional element of type ns2:DeleteAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__DeleteLabel
#define SOAP_TYPE___ns2__DeleteLabel (753)
/* Operation wrapper: */
struct __ns2__DeleteLabel
{
public:
	_ns2__DeleteLabel *ns2__DeleteLabel;	/* optional element of type ns2:DeleteLabel */
};
#endif

#ifndef SOAP_TYPE___ns2__DeleteModule
#define SOAP_TYPE___ns2__DeleteModule (757)
/* Operation wrapper: */
struct __ns2__DeleteModule
{
public:
	_ns2__DeleteModule *ns2__DeleteModule;	/* optional element of type ns2:DeleteModule */
};
#endif

#ifndef SOAP_TYPE___ns2__FindAttributes
#define SOAP_TYPE___ns2__FindAttributes (761)
/* Operation wrapper: */
struct __ns2__FindAttributes
{
public:
	_ns2__FindAttributes *ns2__FindAttributes;	/* optional element of type ns2:FindAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttribute
#define SOAP_TYPE___ns2__GetAttribute (765)
/* Operation wrapper: */
struct __ns2__GetAttribute
{
public:
	_ns2__GetAttribute *ns2__GetAttribute;	/* optional element of type ns2:GetAttribute */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttributeHistory
#define SOAP_TYPE___ns2__GetAttributeHistory (769)
/* Operation wrapper: */
struct __ns2__GetAttributeHistory
{
public:
	_ns2__GetAttributeHistory *ns2__GetAttributeHistory;	/* optional element of type ns2:GetAttributeHistory */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttributeLabels
#define SOAP_TYPE___ns2__GetAttributeLabels (773)
/* Operation wrapper: */
struct __ns2__GetAttributeLabels
{
public:
	_ns2__GetAttributeLabels *ns2__GetAttributeLabels;	/* optional element of type ns2:GetAttributeLabels */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAttributes
#define SOAP_TYPE___ns2__GetAttributes (777)
/* Operation wrapper: */
struct __ns2__GetAttributes
{
public:
	_ns2__GetAttributes *ns2__GetAttributes;	/* optional element of type ns2:GetAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__GetLabels
#define SOAP_TYPE___ns2__GetLabels (781)
/* Operation wrapper: */
struct __ns2__GetLabels
{
public:
	_ns2__GetLabels *ns2__GetLabels;	/* optional element of type ns2:GetLabels */
};
#endif

#ifndef SOAP_TYPE___ns2__GetModules
#define SOAP_TYPE___ns2__GetModules (785)
/* Operation wrapper: */
struct __ns2__GetModules
{
public:
	_ns2__GetModules *ns2__GetModules;	/* optional element of type ns2:GetModules */
};
#endif

#ifndef SOAP_TYPE___ns2__ImportAttributes
#define SOAP_TYPE___ns2__ImportAttributes (788)
/* Operation wrapper: */
struct __ns2__ImportAttributes
{
public:
	_ns2__ImportAttributes *ns2__ImportAttributes;	/* optional element of type ns2:ImportAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__ListAttributeTypes
#define SOAP_TYPE___ns2__ListAttributeTypes (792)
/* Operation wrapper: */
struct __ns2__ListAttributeTypes
{
public:
	_ns2__ListAttributeTypes *ns2__ListAttributeTypes;	/* optional element of type ns2:ListAttributeTypes */
};
#endif

#ifndef SOAP_TYPE___ns2__RenameAttributes
#define SOAP_TYPE___ns2__RenameAttributes (795)
/* Operation wrapper: */
struct __ns2__RenameAttributes
{
public:
	_ns2__RenameAttributes *ns2__RenameAttributes;	/* optional element of type ns2:RenameAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__RenameModule
#define SOAP_TYPE___ns2__RenameModule (799)
/* Operation wrapper: */
struct __ns2__RenameModule
{
public:
	_ns2__RenameModule *ns2__RenameModule;	/* optional element of type ns2:RenameModule */
};
#endif

#ifndef SOAP_TYPE___ns2__RollbackAttributes
#define SOAP_TYPE___ns2__RollbackAttributes (802)
/* Operation wrapper: */
struct __ns2__RollbackAttributes
{
public:
	_ns2__RollbackAttributes *ns2__RollbackAttributes;	/* optional element of type ns2:RollbackAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__SaveAttributes
#define SOAP_TYPE___ns2__SaveAttributes (805)
/* Operation wrapper: */
struct __ns2__SaveAttributes
{
public:
	_ns2__SaveAttributes *ns2__SaveAttributes;	/* optional element of type ns2:SaveAttributes */
};
#endif

#ifndef SOAP_TYPE___ns2__SupportsEarMark
#define SOAP_TYPE___ns2__SupportsEarMark (809)
/* Operation wrapper: */
struct __ns2__SupportsEarMark
{
public:
	_ns2__SupportsEarMark *ns2__SupportsEarMark;	/* optional element of type ns2:SupportsEarMark */
};
#endif

#ifndef SOAP_TYPE___ns2__UpdateLabel
#define SOAP_TYPE___ns2__UpdateLabel (813)
/* Operation wrapper: */
struct __ns2__UpdateLabel
{
public:
	_ns2__UpdateLabel *ns2__UpdateLabel;	/* optional element of type ns2:UpdateLabel */
};
#endif

#ifndef SOAP_TYPE___ns3__Add
#define SOAP_TYPE___ns3__Add (817)
/* Operation wrapper: */
struct __ns3__Add
{
public:
	_ns3__AddRequest *ns3__AddRequest;	/* optional element of type ns3:AddRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__AddRemote
#define SOAP_TYPE___ns3__AddRemote (821)
/* Operation wrapper: */
struct __ns3__AddRemote
{
public:
	_ns3__AddRemoteRequest *ns3__AddRemoteRequest;	/* optional element of type ns3:AddRemoteRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__AddtoSuperfile
#define SOAP_TYPE___ns3__AddtoSuperfile (825)
/* Operation wrapper: */
struct __ns3__AddtoSuperfile
{
public:
	_ns3__AddtoSuperfileRequest *ns3__AddtoSuperfileRequest;	/* optional element of type ns3:AddtoSuperfileRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUArrayAction
#define SOAP_TYPE___ns3__DFUArrayAction (829)
/* Operation wrapper: */
struct __ns3__DFUArrayAction
{
public:
	_ns3__DFUArrayActionRequest *ns3__DFUArrayActionRequest;	/* optional element of type ns3:DFUArrayActionRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUBrowseData
#define SOAP_TYPE___ns3__DFUBrowseData (833)
/* Operation wrapper: */
struct __ns3__DFUBrowseData
{
public:
	_ns3__DFUBrowseDataRequest *ns3__DFUBrowseDataRequest;	/* optional element of type ns3:DFUBrowseDataRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUDefFile
#define SOAP_TYPE___ns3__DFUDefFile (837)
/* Operation wrapper: */
struct __ns3__DFUDefFile
{
public:
	_ns3__DFUDefFileRequest *ns3__DFUDefFileRequest;	/* optional element of type ns3:DFUDefFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUFileView
#define SOAP_TYPE___ns3__DFUFileView (841)
/* Operation wrapper: */
struct __ns3__DFUFileView
{
public:
	_ns3__DFUFileViewRequest *ns3__DFUFileViewRequest;	/* optional element of type ns3:DFUFileViewRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUGetDataColumns
#define SOAP_TYPE___ns3__DFUGetDataColumns (845)
/* Operation wrapper: */
struct __ns3__DFUGetDataColumns
{
public:
	_ns3__DFUGetDataColumnsRequest *ns3__DFUGetDataColumnsRequest;	/* optional element of type ns3:DFUGetDataColumnsRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUInfo
#define SOAP_TYPE___ns3__DFUInfo (849)
/* Operation wrapper: */
struct __ns3__DFUInfo
{
public:
	_ns3__DFUInfoRequest *ns3__DFUInfoRequest;	/* optional element of type ns3:DFUInfoRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUQuery
#define SOAP_TYPE___ns3__DFUQuery (853)
/* Operation wrapper: */
struct __ns3__DFUQuery
{
public:
	_ns3__DFUQueryRequest *ns3__DFUQueryRequest;	/* optional element of type ns3:DFUQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUSearch
#define SOAP_TYPE___ns3__DFUSearch (857)
/* Operation wrapper: */
struct __ns3__DFUSearch
{
public:
	_ns3__DFUSearchRequest *ns3__DFUSearchRequest;	/* optional element of type ns3:DFUSearchRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUSearchData
#define SOAP_TYPE___ns3__DFUSearchData (861)
/* Operation wrapper: */
struct __ns3__DFUSearchData
{
public:
	_ns3__DFUSearchDataRequest *ns3__DFUSearchDataRequest;	/* optional element of type ns3:DFUSearchDataRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__DFUSpace
#define SOAP_TYPE___ns3__DFUSpace (865)
/* Operation wrapper: */
struct __ns3__DFUSpace
{
public:
	_ns3__DFUSpaceRequest *ns3__DFUSpaceRequest;	/* optional element of type ns3:DFUSpaceRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__Savexml
#define SOAP_TYPE___ns3__Savexml (869)
/* Operation wrapper: */
struct __ns3__Savexml
{
public:
	_ns3__SavexmlRequest *ns3__SavexmlRequest;	/* optional element of type ns3:SavexmlRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__SuperfileAction
#define SOAP_TYPE___ns3__SuperfileAction (873)
/* Operation wrapper: */
struct __ns3__SuperfileAction
{
public:
	_ns3__SuperfileActionRequest *ns3__SuperfileActionRequest;	/* optional element of type ns3:SuperfileActionRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__SuperfileAddRaw
#define SOAP_TYPE___ns3__SuperfileAddRaw (877)
/* Operation wrapper: */
struct __ns3__SuperfileAddRaw
{
public:
	_ns3__SuperfileAddRawRequest *ns3__SuperfileAddRawRequest;	/* optional element of type ns3:SuperfileAddRawRequest */
};
#endif

#ifndef SOAP_TYPE___ns3__SuperfileList
#define SOAP_TYPE___ns3__SuperfileList (881)
/* Operation wrapper: */
struct __ns3__SuperfileList
{
public:
	_ns3__SuperfileListRequest *ns3__SuperfileListRequest;	/* optional element of type ns3:SuperfileListRequest */
};
#endif

#ifndef SOAP_TYPE___ns4__Activity
#define SOAP_TYPE___ns4__Activity (885)
/* Operation wrapper: */
struct __ns4__Activity
{
public:
	_ns4__Activity *ns4__Activity;	/* optional element of type ns4:Activity */
};
#endif

#ifndef SOAP_TYPE___ns4__BrowseResources
#define SOAP_TYPE___ns4__BrowseResources (889)
/* Operation wrapper: */
struct __ns4__BrowseResources
{
public:
	_ns4__BrowseResources *ns4__BrowseResources;	/* optional element of type ns4:BrowseResources */
};
#endif

#ifndef SOAP_TYPE___ns4__ClearQueue
#define SOAP_TYPE___ns4__ClearQueue (893)
/* Operation wrapper: */
struct __ns4__ClearQueue
{
public:
	_ns4__ClearQueue *ns4__ClearQueue;	/* optional element of type ns4:ClearQueue */
};
#endif

#ifndef SOAP_TYPE___ns4__GetThorQueueAvailability
#define SOAP_TYPE___ns4__GetThorQueueAvailability (897)
/* Operation wrapper: */
struct __ns4__GetThorQueueAvailability
{
public:
	_ns4__GetThorQueueAvailability *ns4__GetThorQueueAvailability;	/* optional element of type ns4:GetThorQueueAvailability */
};
#endif

#ifndef SOAP_TYPE___ns4__Index
#define SOAP_TYPE___ns4__Index (901)
/* Operation wrapper: */
struct __ns4__Index
{
public:
	_ns4__Index *ns4__Index;	/* optional element of type ns4:Index */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobBack
#define SOAP_TYPE___ns4__MoveJobBack (905)
/* Operation wrapper: */
struct __ns4__MoveJobBack
{
public:
	_ns4__MoveJobBack *ns4__MoveJobBack;	/* optional element of type ns4:MoveJobBack */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobDown
#define SOAP_TYPE___ns4__MoveJobDown (908)
/* Operation wrapper: */
struct __ns4__MoveJobDown
{
public:
	_ns4__MoveJobDown *ns4__MoveJobDown;	/* optional element of type ns4:MoveJobDown */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobFront
#define SOAP_TYPE___ns4__MoveJobFront (911)
/* Operation wrapper: */
struct __ns4__MoveJobFront
{
public:
	_ns4__MoveJobFront *ns4__MoveJobFront;	/* optional element of type ns4:MoveJobFront */
};
#endif

#ifndef SOAP_TYPE___ns4__MoveJobUp
#define SOAP_TYPE___ns4__MoveJobUp (914)
/* Operation wrapper: */
struct __ns4__MoveJobUp
{
public:
	_ns4__MoveJobUp *ns4__MoveJobUp;	/* optional element of type ns4:MoveJobUp */
};
#endif

#ifndef SOAP_TYPE___ns4__NotInCommunityEdition
#define SOAP_TYPE___ns4__NotInCommunityEdition (918)
/* Operation wrapper: */
struct __ns4__NotInCommunityEdition
{
public:
	_ns4__NotInCommunityEdition *ns4__NotInCommunityEdition;	/* optional element of type ns4:NotInCommunityEdition */
};
#endif

#ifndef SOAP_TYPE___ns4__PauseQueue
#define SOAP_TYPE___ns4__PauseQueue (921)
/* Operation wrapper: */
struct __ns4__PauseQueue
{
public:
	_ns4__PauseQueue *ns4__PauseQueue;	/* optional element of type ns4:PauseQueue */
};
#endif

#ifndef SOAP_TYPE___ns4__RemoveJob
#define SOAP_TYPE___ns4__RemoveJob (924)
/* Operation wrapper: */
struct __ns4__RemoveJob
{
public:
	_ns4__RemoveJob *ns4__RemoveJob;	/* optional element of type ns4:RemoveJob */
};
#endif

#ifndef SOAP_TYPE___ns4__ResumeQueue
#define SOAP_TYPE___ns4__ResumeQueue (927)
/* Operation wrapper: */
struct __ns4__ResumeQueue
{
public:
	_ns4__ResumeQueue *ns4__ResumeQueue;	/* optional element of type ns4:ResumeQueue */
};
#endif

#ifndef SOAP_TYPE___ns4__SetBanner
#define SOAP_TYPE___ns4__SetBanner (931)
/* Operation wrapper: */
struct __ns4__SetBanner
{
public:
	_ns4__SetBanner *ns4__SetBanner;	/* optional element of type ns4:SetBanner */
};
#endif

#ifndef SOAP_TYPE___ns4__SetJobPriority
#define SOAP_TYPE___ns4__SetJobPriority (935)
/* Operation wrapper: */
struct __ns4__SetJobPriority
{
public:
	_ns4__SetJobPriority *ns4__SetJobPriority;	/* optional element of type ns4:SetJobPriority */
};
#endif

#ifndef SOAP_TYPE___ns4__StopQueue
#define SOAP_TYPE___ns4__StopQueue (938)
/* Operation wrapper: */
struct __ns4__StopQueue
{
public:
	_ns4__StopQueue *ns4__StopQueue;	/* optional element of type ns4:StopQueue */
};
#endif

#ifndef SOAP_TYPE___ns5__SystemLog
#define SOAP_TYPE___ns5__SystemLog (942)
/* Operation wrapper: */
struct __ns5__SystemLog
{
public:
	_ns5__SystemLogRequest *ns5__SystemLogRequest;	/* optional element of type ns5:SystemLogRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpClusterInfo
#define SOAP_TYPE___ns5__TpClusterInfo (946)
/* Operation wrapper: */
struct __ns5__TpClusterInfo
{
public:
	_ns5__TpClusterInfoRequest *ns5__TpClusterInfoRequest;	/* optional element of type ns5:TpClusterInfoRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpClusterQuery
#define SOAP_TYPE___ns5__TpClusterQuery (950)
/* Operation wrapper: */
struct __ns5__TpClusterQuery
{
public:
	_ns5__TpClusterQueryRequest *ns5__TpClusterQueryRequest;	/* optional element of type ns5:TpClusterQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpGetComponentFile
#define SOAP_TYPE___ns5__TpGetComponentFile (954)
/* Operation wrapper: */
struct __ns5__TpGetComponentFile
{
public:
	_ns5__TpGetComponentFileRequest *ns5__TpGetComponentFileRequest;	/* optional element of type ns5:TpGetComponentFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpGroupQuery
#define SOAP_TYPE___ns5__TpGroupQuery (958)
/* Operation wrapper: */
struct __ns5__TpGroupQuery
{
public:
	_ns5__TpGroupQueryRequest *ns5__TpGroupQueryRequest;	/* optional element of type ns5:TpGroupQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpLogFile
#define SOAP_TYPE___ns5__TpLogFile (962)
/* Operation wrapper: */
struct __ns5__TpLogFile
{
public:
	_ns5__TpLogFileRequest *ns5__TpLogFileRequest;	/* optional element of type ns5:TpLogFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpLogFileDisplay
#define SOAP_TYPE___ns5__TpLogFileDisplay (964)
/* Operation wrapper: */
struct __ns5__TpLogFileDisplay
{
public:
	_ns5__TpLogFileRequest *ns5__TpLogFileRequest;	/* optional element of type ns5:TpLogFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpLogicalClusterQuery
#define SOAP_TYPE___ns5__TpLogicalClusterQuery (968)
/* Operation wrapper: */
struct __ns5__TpLogicalClusterQuery
{
public:
	_ns5__TpLogicalClusterQueryRequest *ns5__TpLogicalClusterQueryRequest;	/* optional element of type ns5:TpLogicalClusterQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpMachineQuery
#define SOAP_TYPE___ns5__TpMachineQuery (972)
/* Operation wrapper: */
struct __ns5__TpMachineQuery
{
public:
	_ns5__TpMachineQueryRequest *ns5__TpMachineQueryRequest;	/* optional element of type ns5:TpMachineQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpServiceQuery
#define SOAP_TYPE___ns5__TpServiceQuery (976)
/* Operation wrapper: */
struct __ns5__TpServiceQuery
{
public:
	_ns5__TpServiceQueryRequest *ns5__TpServiceQueryRequest;	/* optional element of type ns5:TpServiceQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpSetMachineStatus
#define SOAP_TYPE___ns5__TpSetMachineStatus (980)
/* Operation wrapper: */
struct __ns5__TpSetMachineStatus
{
public:
	_ns5__TpSetMachineStatusRequest *ns5__TpSetMachineStatusRequest;	/* optional element of type ns5:TpSetMachineStatusRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpSwapNode
#define SOAP_TYPE___ns5__TpSwapNode (984)
/* Operation wrapper: */
struct __ns5__TpSwapNode
{
public:
	_ns5__TpSwapNodeRequest *ns5__TpSwapNodeRequest;	/* optional element of type ns5:TpSwapNodeRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpTargetClusterQuery
#define SOAP_TYPE___ns5__TpTargetClusterQuery (988)
/* Operation wrapper: */
struct __ns5__TpTargetClusterQuery
{
public:
	_ns5__TpTargetClusterQueryRequest *ns5__TpTargetClusterQueryRequest;	/* optional element of type ns5:TpTargetClusterQueryRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpThorStatus
#define SOAP_TYPE___ns5__TpThorStatus (992)
/* Operation wrapper: */
struct __ns5__TpThorStatus
{
public:
	_ns5__TpThorStatusRequest *ns5__TpThorStatusRequest;	/* optional element of type ns5:TpThorStatusRequest */
};
#endif

#ifndef SOAP_TYPE___ns5__TpXMLFile
#define SOAP_TYPE___ns5__TpXMLFile (996)
/* Operation wrapper: */
struct __ns5__TpXMLFile
{
public:
	_ns5__TpXMLFileRequest *ns5__TpXMLFileRequest;	/* optional element of type ns5:TpXMLFileRequest */
};
#endif

#ifndef SOAP_TYPE___ns6__GVCAjaxGraph
#define SOAP_TYPE___ns6__GVCAjaxGraph (1000)
/* Operation wrapper: */
struct __ns6__GVCAjaxGraph
{
public:
	_ns6__GVCAjaxGraph *ns6__GVCAjaxGraph;	/* optional element of type ns6:GVCAjaxGraph */
};
#endif

#ifndef SOAP_TYPE___ns6__WUAbort
#define SOAP_TYPE___ns6__WUAbort (1004)
/* Operation wrapper: */
struct __ns6__WUAbort
{
public:
	_ns6__WUAbort *ns6__WUAbort;	/* optional element of type ns6:WUAbort */
};
#endif

#ifndef SOAP_TYPE___ns6__WUAction
#define SOAP_TYPE___ns6__WUAction (1008)
/* Operation wrapper: */
struct __ns6__WUAction
{
public:
	_ns6__WUAction *ns6__WUAction;	/* optional element of type ns6:WUAction */
};
#endif

#ifndef SOAP_TYPE___ns6__WUAddLocalFileToWorkunit
#define SOAP_TYPE___ns6__WUAddLocalFileToWorkunit (1012)
/* Operation wrapper: */
struct __ns6__WUAddLocalFileToWorkunit
{
public:
	_ns6__WUAddLocalFileToWorkunit *ns6__WUAddLocalFileToWorkunit;	/* optional element of type ns6:WUAddLocalFileToWorkunit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCDebug
#define SOAP_TYPE___ns6__WUCDebug (1016)
/* Operation wrapper: */
struct __ns6__WUCDebug
{
public:
	_ns6__WUCDebug *ns6__WUCDebug;	/* optional element of type ns6:WUCDebug */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobQueueLOG
#define SOAP_TYPE___ns6__WUClusterJobQueueLOG (1020)
/* Operation wrapper: */
struct __ns6__WUClusterJobQueueLOG
{
public:
	_ns6__WUClusterJobQueueLOG *ns6__WUClusterJobQueueLOG;	/* optional element of type ns6:WUClusterJobQueueLOG */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobQueueXLS
#define SOAP_TYPE___ns6__WUClusterJobQueueXLS (1024)
/* Operation wrapper: */
struct __ns6__WUClusterJobQueueXLS
{
public:
	_ns6__WUClusterJobQueueXLS *ns6__WUClusterJobQueueXLS;	/* optional element of type ns6:WUClusterJobQueueXLS */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobSummaryXLS
#define SOAP_TYPE___ns6__WUClusterJobSummaryXLS (1028)
/* Operation wrapper: */
struct __ns6__WUClusterJobSummaryXLS
{
public:
	_ns6__WUClusterJobSummaryXLS *ns6__WUClusterJobSummaryXLS;	/* optional element of type ns6:WUClusterJobSummaryXLS */
};
#endif

#ifndef SOAP_TYPE___ns6__WUClusterJobXLS
#define SOAP_TYPE___ns6__WUClusterJobXLS (1032)
/* Operation wrapper: */
struct __ns6__WUClusterJobXLS
{
public:
	_ns6__WUClusterJobXLS *ns6__WUClusterJobXLS;	/* optional element of type ns6:WUClusterJobXLS */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCompileECL
#define SOAP_TYPE___ns6__WUCompileECL (1036)
/* Operation wrapper: */
struct __ns6__WUCompileECL
{
public:
	_ns6__WUCompileECL *ns6__WUCompileECL;	/* optional element of type ns6:WUCompileECL */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCopyLogicalFiles
#define SOAP_TYPE___ns6__WUCopyLogicalFiles (1040)
/* Operation wrapper: */
struct __ns6__WUCopyLogicalFiles
{
public:
	_ns6__WUCopyLogicalFiles *ns6__WUCopyLogicalFiles;	/* optional element of type ns6:WUCopyLogicalFiles */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCreate
#define SOAP_TYPE___ns6__WUCreate (1044)
/* Operation wrapper: */
struct __ns6__WUCreate
{
public:
	_ns6__WUCreate *ns6__WUCreate;	/* optional element of type ns6:WUCreate */
};
#endif

#ifndef SOAP_TYPE___ns6__WUCreateAndUpdate
#define SOAP_TYPE___ns6__WUCreateAndUpdate (1048)
/* Operation wrapper: */
struct __ns6__WUCreateAndUpdate
{
public:
	_ns6__WUCreateAndUpdate *ns6__WUCreateAndUpdate;	/* optional element of type ns6:WUCreateAndUpdate */
};
#endif

#ifndef SOAP_TYPE___ns6__WUDelete
#define SOAP_TYPE___ns6__WUDelete (1052)
/* Operation wrapper: */
struct __ns6__WUDelete
{
public:
	_ns6__WUDelete *ns6__WUDelete;	/* optional element of type ns6:WUDelete */
};
#endif

#ifndef SOAP_TYPE___ns6__WUDeployWorkunit
#define SOAP_TYPE___ns6__WUDeployWorkunit (1056)
/* Operation wrapper: */
struct __ns6__WUDeployWorkunit
{
public:
	_ns6__WUDeployWorkunit *ns6__WUDeployWorkunit;	/* optional element of type ns6:WUDeployWorkunit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUExport
#define SOAP_TYPE___ns6__WUExport (1060)
/* Operation wrapper: */
struct __ns6__WUExport
{
public:
	_ns6__WUExport *ns6__WUExport;	/* optional element of type ns6:WUExport */
};
#endif

#ifndef SOAP_TYPE___ns6__WUFile
#define SOAP_TYPE___ns6__WUFile (1064)
/* Operation wrapper: */
struct __ns6__WUFile
{
public:
	_ns6__WUFile *ns6__WUFile;	/* optional element of type ns6:WUFile */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGVCGraphInfo
#define SOAP_TYPE___ns6__WUGVCGraphInfo (1068)
/* Operation wrapper: */
struct __ns6__WUGVCGraphInfo
{
public:
	_ns6__WUGVCGraphInfo *ns6__WUGVCGraphInfo;	/* optional element of type ns6:WUGVCGraphInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetDependancyTrees
#define SOAP_TYPE___ns6__WUGetDependancyTrees (1072)
/* Operation wrapper: */
struct __ns6__WUGetDependancyTrees
{
public:
	_ns6__WUGetDependancyTrees *ns6__WUGetDependancyTrees;	/* optional element of type ns6:WUGetDependancyTrees */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGetGraph
#define SOAP_TYPE___ns6__WUGetGraph (1076)
/* Operation wrapper: */
struct __ns6__WUGetGraph
{
public:
	_ns6__WUGetGraph *ns6__WUGetGraph;	/* optional element of type ns6:WUGetGraph */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGraphInfo
#define SOAP_TYPE___ns6__WUGraphInfo (1080)
/* Operation wrapper: */
struct __ns6__WUGraphInfo
{
public:
	_ns6__WUGraphInfo *ns6__WUGraphInfo;	/* optional element of type ns6:WUGraphInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUGraphTiming
#define SOAP_TYPE___ns6__WUGraphTiming (1084)
/* Operation wrapper: */
struct __ns6__WUGraphTiming
{
public:
	_ns6__WUGraphTiming *ns6__WUGraphTiming;	/* optional element of type ns6:WUGraphTiming */
};
#endif

#ifndef SOAP_TYPE___ns6__WUInfo
#define SOAP_TYPE___ns6__WUInfo (1088)
/* Operation wrapper: */
struct __ns6__WUInfo
{
public:
	_ns6__WUInfo *ns6__WUInfo;	/* optional element of type ns6:WUInfo */
};
#endif

#ifndef SOAP_TYPE___ns6__WUInfoDetails
#define SOAP_TYPE___ns6__WUInfoDetails (1091)
/* Operation wrapper: */
struct __ns6__WUInfoDetails
{
public:
	_ns6__WUInfoDetails *ns6__WUInfoDetails;	/* optional element of type ns6:WUInfoDetails */
};
#endif

#ifndef SOAP_TYPE___ns6__WUJobList
#define SOAP_TYPE___ns6__WUJobList (1095)
/* Operation wrapper: */
struct __ns6__WUJobList
{
public:
	_ns6__WUJobList *ns6__WUJobList;	/* optional element of type ns6:WUJobList */
};
#endif

#ifndef SOAP_TYPE___ns6__WUListLocalFileRequired
#define SOAP_TYPE___ns6__WUListLocalFileRequired (1099)
/* Operation wrapper: */
struct __ns6__WUListLocalFileRequired
{
public:
	_ns6__WUListLocalFileRequired *ns6__WUListLocalFileRequired;	/* optional element of type ns6:WUListLocalFileRequired */
};
#endif

#ifndef SOAP_TYPE___ns6__WUMultiQuerysetDetails
#define SOAP_TYPE___ns6__WUMultiQuerysetDetails (1103)
/* Operation wrapper: */
struct __ns6__WUMultiQuerysetDetails
{
public:
	_ns6__WUMultiQuerysetDetails *ns6__WUMultiQuerysetDetails;	/* optional element of type ns6:WUMultiQuerysetDetails */
};
#endif

#ifndef SOAP_TYPE___ns6__WUProcessGraph
#define SOAP_TYPE___ns6__WUProcessGraph (1107)
/* Operation wrapper: */
struct __ns6__WUProcessGraph
{
public:
	_ns6__WUProcessGraph *ns6__WUProcessGraph;	/* optional element of type ns6:WUProcessGraph */
};
#endif

#ifndef SOAP_TYPE___ns6__WUProtect
#define SOAP_TYPE___ns6__WUProtect (1111)
/* Operation wrapper: */
struct __ns6__WUProtect
{
public:
	_ns6__WUProtect *ns6__WUProtect;	/* optional element of type ns6:WUProtect */
};
#endif

#ifndef SOAP_TYPE___ns6__WUPublishWorkunit
#define SOAP_TYPE___ns6__WUPublishWorkunit (1115)
/* Operation wrapper: */
struct __ns6__WUPublishWorkunit
{
public:
	_ns6__WUPublishWorkunit *ns6__WUPublishWorkunit;	/* optional element of type ns6:WUPublishWorkunit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUPushEvent
#define SOAP_TYPE___ns6__WUPushEvent (1119)
/* Operation wrapper: */
struct __ns6__WUPushEvent
{
public:
	_ns6__WUPushEvent *ns6__WUPushEvent;	/* optional element of type ns6:WUPushEvent */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuery
#define SOAP_TYPE___ns6__WUQuery (1123)
/* Operation wrapper: */
struct __ns6__WUQuery
{
public:
	_ns6__WUQuery *ns6__WUQuery;	/* optional element of type ns6:WUQuery */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetAliasAction
#define SOAP_TYPE___ns6__WUQuerysetAliasAction (1127)
/* Operation wrapper: */
struct __ns6__WUQuerysetAliasAction
{
public:
	_ns6__WUQuerysetAliasAction *ns6__WUQuerysetAliasAction;	/* optional element of type ns6:WUQuerysetAliasAction */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetCopyQuery
#define SOAP_TYPE___ns6__WUQuerysetCopyQuery (1131)
/* Operation wrapper: */
struct __ns6__WUQuerysetCopyQuery
{
public:
	_ns6__WUQuerysetCopyQuery *ns6__WUQuerysetCopyQuery;	/* optional element of type ns6:WUQuerysetCopyQuery */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetDetails
#define SOAP_TYPE___ns6__WUQuerysetDetails (1135)
/* Operation wrapper: */
struct __ns6__WUQuerysetDetails
{
public:
	_ns6__WUQuerysetDetails *ns6__WUQuerysetDetails;	/* optional element of type ns6:WUQuerysetDetails */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysetQueryAction
#define SOAP_TYPE___ns6__WUQuerysetQueryAction (1139)
/* Operation wrapper: */
struct __ns6__WUQuerysetQueryAction
{
public:
	_ns6__WUQuerysetQueryAction *ns6__WUQuerysetQueryAction;	/* optional element of type ns6:WUQuerysetQueryAction */
};
#endif

#ifndef SOAP_TYPE___ns6__WUQuerysets
#define SOAP_TYPE___ns6__WUQuerysets (1143)
/* Operation wrapper: */
struct __ns6__WUQuerysets
{
public:
	_ns6__WUQuerysets *ns6__WUQuerysets;	/* optional element of type ns6:WUQuerysets */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResubmit
#define SOAP_TYPE___ns6__WUResubmit (1147)
/* Operation wrapper: */
struct __ns6__WUResubmit
{
public:
	_ns6__WUResubmit *ns6__WUResubmit;	/* optional element of type ns6:WUResubmit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResult
#define SOAP_TYPE___ns6__WUResult (1151)
/* Operation wrapper: */
struct __ns6__WUResult
{
public:
	_ns6__WUResult *ns6__WUResult;	/* optional element of type ns6:WUResult */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResultBin
#define SOAP_TYPE___ns6__WUResultBin (1155)
/* Operation wrapper: */
struct __ns6__WUResultBin
{
public:
	_ns6__WUResultBin *ns6__WUResultBin;	/* optional element of type ns6:WUResultBin */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResultSummary
#define SOAP_TYPE___ns6__WUResultSummary (1159)
/* Operation wrapper: */
struct __ns6__WUResultSummary
{
public:
	_ns6__WUResultSummary *ns6__WUResultSummary;	/* optional element of type ns6:WUResultSummary */
};
#endif

#ifndef SOAP_TYPE___ns6__WUResultView
#define SOAP_TYPE___ns6__WUResultView (1163)
/* Operation wrapper: */
struct __ns6__WUResultView
{
public:
	_ns6__WUResultView *ns6__WUResultView;	/* optional element of type ns6:WUResultView */
};
#endif

#ifndef SOAP_TYPE___ns6__WURun
#define SOAP_TYPE___ns6__WURun (1167)
/* Operation wrapper: */
struct __ns6__WURun
{
public:
	_ns6__WURun *ns6__WURun;	/* optional element of type ns6:WURun */
};
#endif

#ifndef SOAP_TYPE___ns6__WUSchedule
#define SOAP_TYPE___ns6__WUSchedule (1171)
/* Operation wrapper: */
struct __ns6__WUSchedule
{
public:
	_ns6__WUSchedule *ns6__WUSchedule;	/* optional element of type ns6:WUSchedule */
};
#endif

#ifndef SOAP_TYPE___ns6__WUShowScheduled
#define SOAP_TYPE___ns6__WUShowScheduled (1175)
/* Operation wrapper: */
struct __ns6__WUShowScheduled
{
public:
	_ns6__WUShowScheduled *ns6__WUShowScheduled;	/* optional element of type ns6:WUShowScheduled */
};
#endif

#ifndef SOAP_TYPE___ns6__WUSubmit
#define SOAP_TYPE___ns6__WUSubmit (1179)
/* Operation wrapper: */
struct __ns6__WUSubmit
{
public:
	_ns6__WUSubmit *ns6__WUSubmit;	/* optional element of type ns6:WUSubmit */
};
#endif

#ifndef SOAP_TYPE___ns6__WUSyntaxCheckECL
#define SOAP_TYPE___ns6__WUSyntaxCheckECL (1183)
/* Operation wrapper: */
struct __ns6__WUSyntaxCheckECL
{
public:
	_ns6__WUSyntaxCheckECL *ns6__WUSyntaxCheckECL;	/* optional element of type ns6:WUSyntaxCheckECL */
};
#endif

#ifndef SOAP_TYPE___ns6__WUUpdate
#define SOAP_TYPE___ns6__WUUpdate (1186)
/* Operation wrapper: */
struct __ns6__WUUpdate
{
public:
	_ns6__WUUpdate *ns6__WUUpdate;	/* optional element of type ns6:WUUpdate */
};
#endif

#ifndef SOAP_TYPE___ns6__WUWaitCompiled
#define SOAP_TYPE___ns6__WUWaitCompiled (1190)
/* Operation wrapper: */
struct __ns6__WUWaitCompiled
{
public:
	_ns6__WUWaitCompiled *ns6__WUWaitCompiled;	/* optional element of type ns6:WUWaitCompiled */
};
#endif

#ifndef SOAP_TYPE___ns6__WUWaitComplete
#define SOAP_TYPE___ns6__WUWaitComplete (1193)
/* Operation wrapper: */
struct __ns6__WUWaitComplete
{
public:
	_ns6__WUWaitComplete *ns6__WUWaitComplete;	/* optional element of type ns6:WUWaitComplete */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1194)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1195)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1197)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1198)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (15)
typedef std::wstring *xsd__string;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
